{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Welcome to jaxquantum","text":"<p>S. R. Jha, S. Chowdhury, G. Rolleri, M. Hays, J. A. Grover, W. D. Oliver</p> <p>Docs: equs.github.io/jaxquantum</p> <p>Community Discord: discord.gg/frWqbjvZ4s</p> <p><code>jaxquantum</code> leverages JAX to enable the auto differentiable and (CPU, GPU, TPU) accelerated simulation of quantum dynamical systems, including tooling such as operator construction, unitary evolution and master equation solving. As such, <code>jaxquantum</code> serves as a QuTiP drop-in replacement written entirely in JAX.</p> <p>Moreover, <code>jaxquantum</code> has recently absorbed <code>bosonic</code> and <code>qcsys</code>. As such, it is now a unified toolkit for quantum circuit design, simulation and control. </p>"},{"location":"index.html#installation","title":"Installation","text":""},{"location":"index.html#installing-from-source-recommended","title":"Installing from source (recommended)","text":"<p>Recommended: As this is a rapidly evolving project, we recommend installing the latest version of <code>jaxquantum</code> from source as follows: <pre><code>pip install git+https://github.com/EQuS/jaxquantum.git\n</code></pre></p> <p>If you are installing on a GPU (NVIDIA, CUDA12), then run this instead: <pre><code>pip install 'git+https://github.com/EQuS/jaxquantum.git#egg=jaxquantum[gpu]'\n</code></pre></p> <p>And, on a TPU, run this: <pre><code>pip install 'git+https://github.com/EQuS/jaxquantum.git#egg=jaxquantum[tpu]'\n</code></pre></p> <p>If you face issues running JAX on your hardware, visit this page: https://docs.jax.dev/en/latest/installation.html</p>"},{"location":"index.html#installing-from-source-in-editable-mode-recommended-for-developers","title":"Installing from source in editable mode (recommended for developers)","text":"<p>If you are interested in contributing to the package, please clone this repository and install this package in editable mode after changing into the root directory of this repository: <pre><code>pip install -e \".[dev,docs]\"\n</code></pre> This will also install extras from the <code>dev</code> and <code>docs</code> flags, which can be useful when developing the package. Since this is installed in editable mode, the package will automatically be updated after pulling new changes in the repository. Again, add the <code>gpu</code> or <code>tpu</code> extra, if needed.</p>"},{"location":"index.html#installing-from-pypi-not-recommended","title":"Installing from PyPI (not recommended)","text":"<p><code>jaxquantum</code> is also published on PyPI. Simply run the following code to install the package:</p> <pre><code>pip install jaxquantum\n</code></pre> <p>If you are installing on a GPU (NVIDIA, CUDA12), then run this instead: <pre><code>pip install 'jaxquantum[gpu]'\n</code></pre></p> <p>And, on a TPU, run this: <pre><code>pip install 'jaxquantum[tpu]'\n</code></pre></p> <p>If you face issues running JAX on your hardware, visit this page: https://docs.jax.dev/en/latest/installation.html</p> <p>For more details, please visit the getting started &gt; installation section of our docs.</p>"},{"location":"index.html#check-hardware","title":"Check Hardware","text":"<p>To check which hardware JAX is running on, run the following python code: <pre><code>import jax.numpy as jnp\nx = jnp.array([1.0, 2.0, 3.0])\nprint(x.device)\n</code></pre> This will, for example, print out <code>cuda:0</code> if running on a GPU.</p>"},{"location":"index.html#an-example","title":"An Example","text":"<p>Here's an example of how to set up a simulation in jaxquantum.</p> <p><pre><code>from jax import jit\nimport jaxquantum as jqt \nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nN = 100\n\nomega_a = 2.0*jnp.pi*5.0\nkappa = 2*jnp.pi*jnp.array([1,2]) # Batching to explore two different kappa values!\ninitial_state = jqt.displace(N, 0.1) @ jqt.basis(N,0)\ninitial_state_dm = initial_state.to_dm()\nts = jnp.linspace(0, 4*2*jnp.pi/omega_a, 101)\n\na = jqt.destroy(N)\nn = a.dag() @ a\n\nc_ops = jqt.Qarray.from_list([jnp.sqrt(kappa)*a])\n\n@jit\ndef Ht(t):\n    H0 = omega_a*n\n    return H0\n\nsolver_options = jqt.SolverOptions.create(progress_meter=True)\nstates = jqt.mesolve(Ht, initial_state_dm, ts, c_ops=c_ops, solver_options=solver_options) \nnt = jnp.real(jqt.overlap(n, states))\na_real = jnp.real(jqt.overlap(a, states))\na_imag = jnp.imag(jqt.overlap(a, states))\n\nfig, axs = plt.subplots(2,1, dpi=200, figsize=(6,5))\nax = axs[0]\nax.plot(ts, a_real[:,0], label=r\"$Re[\\langle a(t)\\rangle]$\", color=\"blue\") # Batch kappa value 0\nax.plot(ts, a_real[:,1], \"--\", label=r\"$Re[\\langle a(t)\\rangle]$\", color=\"blue\") # Batch kappa value 1\nax.plot(ts, a_imag[:,0], label=r\"$Re[\\langle a(t)\\rangle]$\", color=\"red\") # Batch kappa value 0\nax.plot(ts, a_imag[:,1], \"--\", label=r\"$Re[\\langle a(t)\\rangle]$\", color=\"red\") # Batch kappa value 1\nax.set_xlabel(\"Time (ns)\")\nax.set_ylabel(\"Expectations\")\nax.legend()\n\nax = axs[1]\nax.plot(ts, nt[:,0], label=r\"$Re[\\langle n(t)\\rangle]$\", color=\"green\") # Batch kappa value 0\nax.plot(ts, nt[:,1], \"--\", label=r\"$Re[\\langle n(t)\\rangle]$\", color=\"green\") # Batch kappa value 1\nax.set_xlabel(\"Time (ns)\")\nax.set_ylabel(\"Expectations\")\nax.legend()\nfig.tight_layout()\n</code></pre> </p>"},{"location":"index.html#acknowledgements-history","title":"Acknowledgements &amp; History","text":"<p>Core Devs: Shantanu R. Jha, Shoumik Chowdhury, Gabriele Rolleri</p> <p>This package was initially a small part of <code>bosonic</code>. In early 2022, <code>jaxquantum</code> was extracted and made into its own package. This package was briefly announced to the world at APS March Meeting 2023 and released to a select few academic groups shortly after. Since then, this package has been open sourced and developed while conducting research in the Engineering Quantum Systems Group at MIT with advice and support from Prof. William D. Oliver. </p>"},{"location":"gen_ref_pages.html","title":"Gen ref pages","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate the code reference pages.\"\"\"\n</pre> \"\"\"Generate the code reference pages.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\n</pre> nav = mkdocs_gen_files.Nav() In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(\"jaxquantum\").rglob(\"*.py\")):\n    module_path = path.relative_to(\".\").with_suffix(\"\")\n    doc_path = path.relative_to(\".\").with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = list(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n\n    nav[parts] = str(doc_path)\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        identifier = \".\".join(parts)\n        print(\"::: \" + identifier, file=fd)\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)\n</pre> for path in sorted(Path(\"jaxquantum\").rglob(\"*.py\")):     module_path = path.relative_to(\".\").with_suffix(\"\")     doc_path = path.relative_to(\".\").with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = list(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue      nav[parts] = str(doc_path)      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         identifier = \".\".join(parts)         print(\"::: \" + identifier, file=fd)      mkdocs_gen_files.set_edit_path(full_doc_path, path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/summary.md\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/summary.md\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"},{"location":"about/_contributors.html","title":"contributors","text":"<p>This markdown document is not processed into a docs page.</p>"},{"location":"about/_contributors.html#publishing-to-pypi","title":"Publishing to PyPI","text":"<p>Steps: 1. Update the version in <code>jaxquantum/PACKAGE.json</code>. 2. Check for meta-data errors when building the source distribution by running: <code>python setup.py check</code>. 3. Optionally, install the package locally: <code>pip install --upgrade -e .</code> 4. Create a source distribution: <code>python setup.py sdist</code>  5. Test upload to test-pypi: <code>twine upload --repository-url https://test.pypi.org/legacy/ dist/jaxquantum-&lt;VERSION&gt;.tar.gz</code> 6. Upload to pypi: <code>twine upload dist/jaxquantum-&lt;VERSION&gt;.tar.gz</code> 7. Create release on jaxquantum github: https://github.com/EQuS/jaxquantum/releases     1. Include package tar.    2. Generate release notes and add additional notes manually.</p>"},{"location":"about/citation.html","title":"Citation","text":""},{"location":"about/citation.html#citation","title":"Citation","text":"<p>Thank you for taking the time to try our package out. If you found it useful in your research, please cite us as follows:</p> <pre><code>@software{jha2025jaxquantum,\n  author = {Shantanu R. Jha and Shoumik Chowdhury and Gabriele Rolleri and Max Hays and Jeff A. Grover and William D. Oliver},\n  title  = {JAXQuantum: An auto-differentiable and hardware-accelerated toolkit for quantum hardware design, simulation, and control},\n  url    = {https://jaxquantum.org},\n  version = {0.2.2},\n  year   = {2025},\n}\n</code></pre> <p>S. R. Jha, S. Chowdhury, G. Rolleri, M. Hays, J. A. Grover, and W. D. Oliver. \"JAXQuantum: An auto-differentiable and hardware-accelerated toolkit for quantum hardware design, simulation, and control,\" jaxquantum.org (2025).</p>"},{"location":"about/community.html","title":"Discord","text":"<p>JAXquantum offers support over our community discord: discord.gg/frWqbjvZ4s</p>"},{"location":"about/contributors.html","title":"Contributions &amp; Contact","text":"<p>This package is open source and, as such, very open to contributions. Please don't hesitate to open an issue, report a bug, request a feature, or create a pull request. We are also open to deeper collaborations to create a tool that is more useful for everyone. If a discussion would be helpful, please email shanjha@mit.edu to set up a meeting. </p>"},{"location":"about/contributors.html#tests","title":"Tests","text":""},{"location":"about/contributors.html#install-contributor-extra","title":"Install contributor extra","text":"<p>As a contributor, you should install jaxquantum in editable mode with the <code>dev</code> and <code>docs</code> extra:</p> <pre><code>pip install --upgrade -e \".[dev,docs]\" \n</code></pre>"},{"location":"about/contributors.html#run-tests","title":"Run Tests","text":"<p>To run tests, simply clone this repository and in its root directory run: <pre><code>pytest\n</code></pre></p>"},{"location":"about/contributors.html#check-code-coverage","title":"Check code coverage","text":"<p>In the root directory of this repository, run: <pre><code>coverage run --source=jaxquantum -m pytest\n</code></pre></p> <p>Then, you can view a summary of the results by running: <pre><code>coverage report\n</code></pre></p> <p>If you want to dive deeper, then run: <pre><code>coverage html\n</code></pre></p>"},{"location":"documentation/advanced/enr.html","title":"Excitation Number Restricted Basis","text":"<p>This is a tutorial for the Energy Number Restricted (ENR) basis methods in jaxquantum.</p>"},{"location":"documentation/getting_started/index.html","title":"Index","text":""},{"location":"documentation/getting_started/examples.html","title":"Examples","text":"<p>Here are some examples to help you get started with <code>jaxquantum</code>. </p>"},{"location":"documentation/getting_started/examples.html#lossy-harmonic-oscillator","title":"Lossy Harmonic Oscillator","text":"<p>Let's simulate the time dynamics of a quantum harmonic oscillator with single photon loss. </p> <pre><code>from jax import jit\nimport jaxquantum as jqt \nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nN = 100\n\nomega_a = 2.0*jnp.pi*5.0\nkappa = 2*jnp.pi*1\ninitial_state = jqt.displace(N, 0.1) @ jqt.basis(N,0)\ninitial_state_dm = initial_state.to_dm()\nts = jnp.linspace(0, 4*2*jnp.pi/omega_a, 101)\n\na = jqt.destroy(N)\nn = a.dag() @ a\n\nc_ops = [a*jnp.sqrt(kappa)]\n\n@jit\ndef Ht(t):\n    H0 = omega_a*n\n    return H0\n\nsolver_options = jqt.SolverOptions.create(progress_meter=True)\nstates = jqt.mesolve(initial_state_dm, ts, c_ops=c_ops, Ht=Ht, solver_options=solver_options) \nnt = jnp.real(jqt.calc_expect(n, states))\na_real = jnp.real(jqt.calc_expect(a, states))\na_imag = jnp.imag(jqt.calc_expect(a, states))\n\nfig, axs = plt.subplots(2,1, dpi=200, figsize=(6,5))\nax = axs[0]\nax.plot(ts, a_real, label=r\"$Re[\\langle a(t)\\rangle]$\")\nax.plot(ts, a_imag, label=r\"$Re[\\langle a(t)\\rangle]$\")\nax.set_xlabel(\"Time (ns)\")\nax.set_ylabel(\"Expectations\")\nax.legend()\n\nax = axs[1]\nax.plot(ts, nt, label=r\"$Re[\\langle n(t)\\rangle]$\")\nax.set_xlabel(\"Time (ns)\")\nax.set_ylabel(\"Expectations\")\nax.legend()\nfig.tight_layout()\n</code></pre> <p>Output<pre><code>100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:01&lt;00:00, 93.89%/s] \n</code></pre> </p>"},{"location":"documentation/getting_started/installation.html","title":"Installation","text":""},{"location":"documentation/getting_started/installation.html#installation","title":"Installation","text":""},{"location":"documentation/getting_started/installation.html#installing-from-source-recommended","title":"Installing from source (recommended)","text":"<p>Recommended: As this is a rapidly evolving project, we recommend installing the latest version of <code>jaxquantum</code> from source as follows: <pre><code>pip install git+https://github.com/EQuS/jaxquantum.git\n</code></pre></p> <p>If you are installing on a GPU (NVIDIA, CUDA12), then run this instead: <pre><code>pip install 'git+https://github.com/EQuS/jaxquantum.git#egg=jaxquantum[gpu]'\n</code></pre></p> <p>And, on a TPU, run this: <pre><code>pip install 'git+https://github.com/EQuS/jaxquantum.git#egg=jaxquantum[tpu]'\n</code></pre></p> <p>If you face issues running JAX on your hardware, visit this page: https://docs.jax.dev/en/latest/installation.html</p>"},{"location":"documentation/getting_started/installation.html#installing-from-source-in-editable-mode-recommended-for-developers","title":"Installing from source in editable mode (recommended for developers)","text":"<p>If you are interested in contributing to the package, please clone this repository and install this package in editable mode after changing into the root directory of this repository: <pre><code>pip install -e \".[dev,docs]\"\n</code></pre> This will also install extras from the <code>dev</code> and <code>docs</code> flags, which can be useful when developing the package. Since this is installed in editable mode, the package will automatically be updated after pulling new changes in the repository. Again, add the <code>gpu</code> or <code>tpu</code> extra, if needed.</p>"},{"location":"documentation/getting_started/installation.html#installing-from-pypi-not-recommended","title":"Installing from PyPI (not recommended)","text":"<p><code>jaxquantum</code> is also published on PyPI. Simply run the following code to install the package:</p> <pre><code>pip install jaxquantum\n</code></pre> <p>If you are installing on a GPU (NVIDIA, CUDA12), then run this instead: <pre><code>pip install 'jaxquantum[gpu]'\n</code></pre></p> <p>And, on a TPU, run this: <pre><code>pip install 'jaxquantum[tpu]'\n</code></pre></p> <p>If you face issues running JAX on your hardware, visit this page: https://docs.jax.dev/en/latest/installation.html</p>"},{"location":"documentation/getting_started/installation.html#check-hardware","title":"Check Hardware","text":"<p>To check which hardware JAX is running on, run the following python code: <pre><code>import jax.numpy as jnp\nx = jnp.array([1.0, 2.0, 3.0])\nprint(x.device)\n</code></pre> This will, for example, print out <code>cuda:0</code> if running on a GPU.</p>"},{"location":"documentation/getting_started/installation.html#common-issues","title":"Common Issues","text":""},{"location":"documentation/getting_started/installation.html#errors-installing-with-gpu-support-linux","title":"Errors installing with GPU support (Linux)","text":"<p>For linux users who wish to enable Nvidia GPU support, here are some steps (ref):</p> <ol> <li>Make sure you NVIDIA drivers by running:    <code>cat /proc/driver/nvidia/version</code> or <code>sudo ubuntu-drivers list</code></li> <li>If your driver version is &gt;= 525.60.13 then run:    <code>pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html</code> otherwise, use <code>cuda11_pip</code></li> <li>Test that GPU support is enabled:</li> <li>Enjoy!</li> </ol> <p>Notes: If you receive this error: <pre><code>2024-02-27 14:10:45.052355: W external/xla/xla/service/gpu/nvptx_compiler.cc:742] The NVIDIA driver's CUDA version is 12.0 which is older than the ptxas CUDA version (12.3.107). Because the driver is older than the ptxas version, XLA is disabling parallel compilation, which may slow down compilation. You should update your NVIDIA driver or use the NVIDIA-provided CUDA forward compatibility packages.\n</code></pre></p> <p>Then, you should update your NVIDIA driver by running: <pre><code>conda install cuda -c nvidia\n</code></pre></p> <p>If you receive this error: <code>CUDA backend failed to initialize: jaxlib/cuda/versions_helpers.cc:98: operation cuInit(0) failed: CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)</code></p> <p>Try rebooting or running: <code>sudo reboot now</code></p>"},{"location":"documentation/getting_started/installation.html#jaxlib-error-after-installing-gpu-support","title":"jaxlib error after installing GPU support","text":"<pre><code>An NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.\n</code></pre> <p>Following this thread, try running: <pre><code>unset LD_LIBRARY_PATH\n</code></pre></p>"},{"location":"documentation/getting_started/qarray.html","title":"Qarray","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install git+https://github.com/EQuS/jaxquantum.git # Comment this out if running in colab to install jaxquantum.\n</pre> # !pip install git+https://github.com/EQuS/jaxquantum.git # Comment this out if running in colab to install jaxquantum. In\u00a0[1]: Copied! <pre>import jaxquantum as jqt\nimport jax.numpy as jnp\n</pre> import jaxquantum as jqt import jax.numpy as jnp In\u00a0[2]: Copied! <pre>N = 50\nstate = jqt.basis(N, 0)\ndisplaced_state = jqt.displace(N, 2.0) @ state\ndisplaced_state.to_dm().header\n</pre> N = 50 state = jqt.basis(N, 0) displaced_state = jqt.displace(N, 2.0) @ state displaced_state.to_dm().header Out[2]: <pre>'Quantum array: dims = ((50,), (50,)), bdims = (), shape = (50, 50), type = oper'</pre> In\u00a0[3]: Copied! <pre>pts = jnp.linspace(-4, 4, 100)\njqt.plot_wigner(displaced_state, pts)\n</pre> pts = jnp.linspace(-4, 4, 100) jqt.plot_wigner(displaced_state, pts) Out[3]: <pre>(&lt;Axes: xlabel='Re[$\\\\alpha$]', ylabel='Im[$\\\\alpha$]'&gt;,\n &lt;matplotlib.contour.QuadContourSet at 0x16ba610a0&gt;)</pre> <p>A crucial difference between a Qarray and Qobj is its <code>bdim</code> or batch dimension. This enables us to seamlessly use batching and numpy broadcasting in calculations using Qarray objects.</p> In\u00a0[4]: Copied! <pre>N = 50\nstate = jqt.basis(N, 0)\ndisplaced_state = jqt.displace(N, jnp.array([[0.0, 0.5, 1.0],[1.5,2.0,2.5]])) @ state\n\ndisplaced_state.header\n</pre> N = 50 state = jqt.basis(N, 0) displaced_state = jqt.displace(N, jnp.array([[0.0, 0.5, 1.0],[1.5,2.0,2.5]])) @ state  displaced_state.header Out[4]: <pre>'Quantum array: dims = ((50,), (1,)), bdims = (2, 3), shape = (2, 3, 50, 1), type = ket'</pre> In\u00a0[5]: Copied! <pre>pts = jnp.linspace(-4, 4, 100)\njqt.plot_wigner(displaced_state[0][0], pts)\njqt.plot_wigner(displaced_state[0][2], pts)\njqt.plot_wigner(displaced_state[1][1], pts)\n</pre> pts = jnp.linspace(-4, 4, 100) jqt.plot_wigner(displaced_state[0][0], pts) jqt.plot_wigner(displaced_state[0][2], pts) jqt.plot_wigner(displaced_state[1][1], pts) Out[5]: <pre>(&lt;Axes: xlabel='Re[$\\\\alpha$]', ylabel='Im[$\\\\alpha$]'&gt;,\n &lt;matplotlib.contour.QuadContourSet at 0x30f62b340&gt;)</pre> In\u00a0[6]: Copied! <pre>N = 50\na = jqt.displace(N, 0.0)\nb = jqt.displace(N, 1.0)\nc = jqt.displace(N, 2.0)\narr1 = jqt.Qarray.from_array([[a,b,c],[a,b,c]])\narr2 = jqt.displace(N, jnp.array([[0.0, 1.0, 2.0],[0.0, 1.0, 2.0]]))\n\njnp.max(jnp.abs(arr1[0][1].data-arr2[0][1].data))\n</pre> N = 50 a = jqt.displace(N, 0.0) b = jqt.displace(N, 1.0) c = jqt.displace(N, 2.0) arr1 = jqt.Qarray.from_array([[a,b,c],[a,b,c]]) arr2 = jqt.displace(N, jnp.array([[0.0, 1.0, 2.0],[0.0, 1.0, 2.0]]))  jnp.max(jnp.abs(arr1[0][1].data-arr2[0][1].data)) Out[6]: <pre>Array(6.10622664e-16, dtype=float64)</pre>"},{"location":"documentation/getting_started/qarray.html#qarray","title":"Qarray\u00b6","text":"<p>The Qarray is the fundamental building block of <code>jaxquantum</code>. It is heavily inspired by QuTiP's Qobj and built to be compatible with <code>JAX</code> patterns.</p>"},{"location":"documentation/getting_started/qarray.html#batching","title":"Batching\u00b6","text":""},{"location":"documentation/getting_started/qarray.html#constructing-a-batched-qarray-manually","title":"Constructing a batched Qarray manually\u00b6","text":""},{"location":"documentation/getting_started/sharp_bits.html","title":"The Sharp Bits \ud83d\udd2a","text":"<p>This is a non-exhaustive, but growing list of common pitfalls when using <code>jaxquantum</code>.</p>"},{"location":"documentation/getting_started/sharp_bits.html#jax","title":"JAX","text":"<p>Quote</p> <p>When walking about the countryside of Italy, the people will not hesitate to tell you that JAX has \u201cuna anima di pura programmazione funzionale\u201d. ~ JAX docs</p> <p>Often the sharp bits poking at you originate from the functional paradigm within which JAX operates. The JAX developers have compiled a great list of these common \"gotchas\": https://docs.jax.dev/en/latest/notebooks/Common_Gotchas_in_JAX.html </p>"},{"location":"documentation/getting_started/sharp_bits.html#constant-folding","title":"Constant folding","text":"<p>JAX constant folding is an optimization where constant expressions are evaluated at compile time rather than runtime, reducing computation during execution. For example, if a function contains only operations on constants, JAX may precompute the result and replace the expression with the constant value.</p> <p>While this can reduce the runtime of a jitted function on the second and subsequent runs, constant folding can greatly increase the compile time and, in turn, how long the first run of a jitted function takes. </p> <p>In computations where either only one run of a function is required or the first run (with constant folding enabled) is taking way too long, the user can try disabling constant folding. </p> <p>To do so, run this at the top of your Jupyter notebook or at the top of your python script: <pre><code>import os\nos.environ['XLA_FLAGS'] = \"--xla_disable_hlo_passes=constant_folding\"\n</code></pre> Note that this code must be run before JAX is imported. </p> <p>As an example, here's the timing results of running a simple <code>sesolve</code> simulation with and without jitting and with and without constant folding.  As shown above, constant folding rapidly increase the runtime of the first call to a function, while disabling constant folding significantly speeds up the first call of a function.</p> <p>However, the fastest runtime for a function call is the second call of a jitted function with constant folding. Notably, the second call of a function always runs on different inputs than the first call, in this benchmark.</p> <p>So, it may be worth paying the cost of the first call of a jitted function with constant folding, if the user wishes to use the jitted function many times. </p>"},{"location":"documentation/getting_started/sharp_bits.html#operations","title":"Operations","text":""},{"location":"documentation/getting_started/sharp_bits.html#tensor-product-shorthand","title":"Tensor product shorthand <code>^</code>","text":"<p>Note that the shorthand for tensor product <code>^</code> is evaluated after other basic math operations (e.g. <code>+,-,*,/,@</code>). So, when using this shorthand, it is best practice to use parentheses. </p> <p>Tensor shorthand.</p> <p>For example, the following code will fail: <pre><code>jqt.identity(2)^jqt.identity(3) + jqt.identity(2)^jqt.identity(3)\n</code></pre></p> <p>Output</p> <pre><code>ValueError: Dimensions are incompatible: ((3,), (3,)) and ((2,), (2,))\n</code></pre> <p>This is because <code>jqt.identity(3) + jqt.identity(2)</code> is running before the tensor products.</p> <p>Instead, we should use parentheses to specify the order of operations to begin with <code>^</code>.</p> <pre><code>(jqt.identity(2)^jqt.identity(3)) + (jqt.identity(2)^jqt.identity(3))\n</code></pre> <p>Output</p> <pre><code>Quantum array: dims = ((2, 3), (2, 3)), bdims = (), shape = (6, 6), type = oper\nQarray data =\n[[2.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n[0.+0.j 2.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n[0.+0.j 0.+0.j 2.+0.j 0.+0.j 0.+0.j 0.+0.j]\n[0.+0.j 0.+0.j 0.+0.j 2.+0.j 0.+0.j 0.+0.j]\n[0.+0.j 0.+0.j 0.+0.j 0.+0.j 2.+0.j 0.+0.j]\n[0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 2.+0.j]]\n</code></pre>"},{"location":"documentation/tutorials/circuits.html","title":"Circuits","text":"In\u00a0[1]: Copied! <pre># !pip install git+https://github.com/EQuS/jaxquantum.git # Comment this out if running in colab to install jaxquantum.\n</pre> # !pip install git+https://github.com/EQuS/jaxquantum.git # Comment this out if running in colab to install jaxquantum. <p>This is an executable IPython Notebook tutorial.</p> In\u00a0[2]: Copied! <pre>import jaxquantum as jqt\nimport jaxquantum.circuits as jqtc\nfrom jax import jit, grad\nimport jax.numpy as jnp\nfrom math import prod\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\n\nimport jax\nimport optax\nimport functools\n</pre> import jaxquantum as jqt import jaxquantum.circuits as jqtc from jax import jit, grad import jax.numpy as jnp from math import prod from tqdm import tqdm import matplotlib.pyplot as plt  import jax import optax import functools <p><code>jaxquantum.circuits</code> is a submodule of JAXquantum dedicated to multi-mode, gate parameterized quantum simulations.</p> <p>Our circuit design is inspired by Qiskit and Cirq.</p> <p>A JAXquantum circuit begins with a <code>Register</code>, which specifies the Hilbert space dimensions of the modes involved in the circuit.</p> <p>The <code>Circuit</code> class is then defined by the <code>Register</code> of modes it affects and its <code>Layer</code> objects. Each <code>Layer</code> consists of <code>Operation</code> objects, which are specified by a <code>Gate</code> and the register indices on which that gate acts. Finally, a <code>Gate</code> can be specified by a unitary operator, a Hamiltonian (with timesteps and collapse operators), or a Kraus map.</p> <p>To better understand how this object hierarchy works, let's work through a simple example.</p> In\u00a0[3]: Copied! <pre>N = 10\nbeta = 2\nreg = jqtc.Register([2,N])\ncirq = jqtc.Circuit.create(reg, layers=[])\ncirq.append(jqtc.X(),0)\ncirq.append(jqtc.CD(N, beta),[0,1])\n\n\nfig, axs = plt.subplots(1, 2, figsize=(8, 3))\n\nfor j in range(2):\n    initial_state = jqt.basis(2,j) ^ jqt.basis(N,0)\n    res = jqtc.simulate(cirq, initial_state)\n\n    pts = jnp.linspace(-2,2, 101)\n    ax, im = jqt.plot_wigner(jqt.ptrace(res[-1][-1],1), pts, ax=axs[j])\n    ax.set_title(f\"Initial Qubit State |{j}\u27e9\")\n    ax.set_xlabel(\"Re[\u03b1]\")\n    ax.set_ylabel(\"Im[\u03b1]\")\n\nfig.tight_layout()\n</pre> N = 10 beta = 2 reg = jqtc.Register([2,N]) cirq = jqtc.Circuit.create(reg, layers=[]) cirq.append(jqtc.X(),0) cirq.append(jqtc.CD(N, beta),[0,1])   fig, axs = plt.subplots(1, 2, figsize=(8, 3))  for j in range(2):     initial_state = jqt.basis(2,j) ^ jqt.basis(N,0)     res = jqtc.simulate(cirq, initial_state)      pts = jnp.linspace(-2,2, 101)     ax, im = jqt.plot_wigner(jqt.ptrace(res[-1][-1],1), pts, ax=axs[j])     ax.set_title(f\"Initial Qubit State |{j}\u27e9\")     ax.set_xlabel(\"Re[\u03b1]\")     ax.set_ylabel(\"Im[\u03b1]\")  fig.tight_layout() <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 13.47it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 430.38it/s]\n</pre> <p>The <code>jqtc.simulate</code> function takes a kwarg called <code>mode</code>, which can either be <code>\"unitary\"</code>, <code>\"kraus\"</code>, <code>\"hamiltonian\"</code> or <code>\"default\"</code> - as enumerated by the <code>SimulateMode</code> Enum class. By default, the simulation mode is \"default\". This means, the default simulation mode of each layer will be used to simulate that layer of the circuit. The <code>default_simulate_mode</code> of a layer is specified upon creation of that layer and by default the <code>default_simulate_mode</code> is set to <code>\"unitary\"</code> for a new layer.</p> <p>To illustrate these features, we will include a layer with one operation consisting of a gate that resets the qubit to the $\\ket{+}$ state. This layer will be simulated as a Kraus map, by setting <code>default_simulate_mode=\"kraus\"</code>.</p> <p>Using this reset operation, we will be able to create a cat state in the resonator.</p> <p>$$\\begin{align}&amp;\\ket{g}\\ket{0} \\\\&amp;\\to \\ket{+}\\ket{0} \\\\&amp;\\to \\ket{g}\\ket{\\beta/2} + \\ket{e}\\ket{-\\beta/2}\\\\&amp;\\to\\ket{+}\\left(\\frac{\\ket{\\beta/2} + \\ket{-\\beta/2}}{\\sqrt{2}}\\right) + \\ket{-}\\left(\\frac{\\ket{\\beta/2} - \\ket{-\\beta/2}}{\\sqrt{2}}\\right)\\\\&amp;\\to \\ket{+}\\left(\\frac{\\ket{\\beta/2} + \\ket{-\\beta/2}}{\\sqrt{2}}\\right)\\end{align}$$</p> <p>The entire sequence shown above is performed by the code written below.</p> In\u00a0[4]: Copied! <pre>N = 40\nbeta = 4\nreg = jqtc.Register([2,N])\ncirq = jqtc.Circuit.create(reg, layers=[])\ncirq.append(jqtc.H(),0)\ncirq.append(jqtc.CD(N, beta),[0,1])\ncirq.append(jqtc.MX_plus(), 0, default_simulate_mode=\"kraus\")\n\ninitial_state = jqt.basis(2,0) ^ jqt.basis(N,0)\nres = jqtc.simulate(cirq, initial_state)\n\nfinal_state = res[-1][-1].unit()\n\npts = jnp.linspace(-4,4, 101)\nax, im = jqt.plot_wigner(jqt.ptrace(final_state,1), pts)\nax.set_xlabel(\"Re[\u03b1]\")\nax.set_ylabel(\"Im[\u03b1]\")\n</pre> N = 40 beta = 4 reg = jqtc.Register([2,N]) cirq = jqtc.Circuit.create(reg, layers=[]) cirq.append(jqtc.H(),0) cirq.append(jqtc.CD(N, beta),[0,1]) cirq.append(jqtc.MX_plus(), 0, default_simulate_mode=\"kraus\")  initial_state = jqt.basis(2,0) ^ jqt.basis(N,0) res = jqtc.simulate(cirq, initial_state)  final_state = res[-1][-1].unit()  pts = jnp.linspace(-4,4, 101) ax, im = jqt.plot_wigner(jqt.ptrace(final_state,1), pts) ax.set_xlabel(\"Re[\u03b1]\") ax.set_ylabel(\"Im[\u03b1]\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00,  8.38it/s]\n</pre> Out[4]: <pre>Text(62.44444444444453, 0.5, 'Im[\u03b1]')</pre> <p>As usual, every function written using <code>jaxquantum</code> is auto-differentiable. This allows us to perform gradient-aware optimizations.</p> <p>In the cells below, we detail a very simple example of a <code>jaxquantum</code> circuit optimization. Here, we optimize over the qubit rotation angle $\\theta$ to achieve a pi pulse taking $\\ket{0}$ to $\\ket{1}$.</p> In\u00a0[5]: Copied! <pre># Setup metric =======\n@jit\ndef metric(params):\n    theta = 2*jnp.pi*params[0]\n    reg = jqtc.Register([2])\n    cirq = jqtc.Circuit.create(reg, layers=[])\n    cirq.append(jqtc.Rx(theta),0)\n\n    initial_state = jqt.basis(2,0)\n    res = jqtc.simulate(cirq, initial_state)\n\n    final_state = res[-1][-1]\n    target_state = jqt.basis(2,1)\n    return 1-jqt.overlap(final_state, target_state)\n\nmetric_grad = grad(metric)\nprint(\"Test\", metric(jnp.array([0.45])), metric_grad(jnp.array([0.45])))\n# ======\n\n\n# Setup Optimizer ======\nstart_learning_rate = 1e-2\noptimizer = optax.adam(start_learning_rate)\n\n# Initialize parameters of the model + optimizer.\nparams = jnp.array([0.1])\nopt_state = optimizer.init(params)\n# ======\n\n# Run optimization ======\nparams_history = [params[0]]\nfor _ in tqdm(range(1000)):\n  grads = metric_grad(params)\n  updates, opt_state = optimizer.update(grads, opt_state)\n  params = optax.apply_updates(params, updates)\n  params_history.append(params[0])\n\nparams_history = jnp.array(params_history)\n# ======\n\n# Plot parameter history ======\nfig, ax = plt.subplots(1,1, dpi=200, figsize=(3,2))\nax.plot(params_history)\nax.axhline(0.5, ls=\"--\", color=\"black\", label=\"optimal\")\nax.set_xlabel(\"Epoch\")\nax.set_ylabel(\"\u03b8 [2\u03c0]\")\nax.legend()\n# ======\n</pre> # Setup metric ======= @jit def metric(params):     theta = 2*jnp.pi*params[0]     reg = jqtc.Register([2])     cirq = jqtc.Circuit.create(reg, layers=[])     cirq.append(jqtc.Rx(theta),0)      initial_state = jqt.basis(2,0)     res = jqtc.simulate(cirq, initial_state)      final_state = res[-1][-1]     target_state = jqt.basis(2,1)     return 1-jqt.overlap(final_state, target_state)  metric_grad = grad(metric) print(\"Test\", metric(jnp.array([0.45])), metric_grad(jnp.array([0.45]))) # ======   # Setup Optimizer ====== start_learning_rate = 1e-2 optimizer = optax.adam(start_learning_rate)  # Initialize parameters of the model + optimizer. params = jnp.array([0.1]) opt_state = optimizer.init(params) # ======  # Run optimization ====== params_history = [params[0]] for _ in tqdm(range(1000)):   grads = metric_grad(params)   updates, opt_state = optimizer.update(grads, opt_state)   params = optax.apply_updates(params, updates)   params_history.append(params[0])  params_history = jnp.array(params_history) # ======  # Plot parameter history ====== fig, ax = plt.subplots(1,1, dpi=200, figsize=(3,2)) ax.plot(params_history) ax.axhline(0.5, ls=\"--\", color=\"black\", label=\"optimal\") ax.set_xlabel(\"Epoch\") ax.set_ylabel(\"\u03b8 [2\u03c0]\") ax.legend() # ====== <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 125.88it/s]\n</pre> <pre>Test 0.024471741852423127 [-0.97080552]\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:02&lt;00:00, 365.53it/s]\n</pre> Out[5]: <pre>&lt;matplotlib.legend.Legend at 0x32397af70&gt;</pre> <p>For a more practical example of offline state preparation optimizations, check out <code>experiments/circuit/10-jax-control-gkp-reg.ipynb</code> on the main branch of the <code>jaxquantum</code> repo. This will be polished into a tutorial in the future.</p> <p><code>jaxquantum</code> circuits can also be simulated in <code>\"hamiltonian\"</code> mode. In this mode, the Hamiltonians of operations within the same layer will be added together. This allows us to perform a displacement on a resonator, while it is dispersively coupled to a qubit. Because of the alway-on dispersive coupling, there is a conditional displacement orthogonal to the direction of the displacement gate and conditional on the state of the qubit (pushing the resonator state one way when the qubit is in $\\ket{g}$ and the opposite way when the qubit is in $\\ket{e}$).</p> In\u00a0[\u00a0]: Copied! <pre>displacement_final = 4.0j # try increasing this to get a larger final displacement!\nNa = 100 # and try increasing the resonator size to accommodate larger displacements!\nNq = 2\n\na = jqt.destroy(Na) ^ jqt.identity(Nq)\nsz = jqt.identity(Na) ^ jqt.sigmaz()\n\n\n# Dispersive coupling strength is 32kHz\n\u03c7 = 2 * jnp.pi * 32e-6 # [2pi x GHz]\n\nt_final = 1000 # [ns]\nts = jnp.linspace(0, t_final, 1001)\n\n\ndef Ht(t):\n    H = \u03c7 * (a.dag() @ a) @ sz\n    return H\n\nreg = jqtc.Register([Na,Nq])\ncirq = jqtc.Circuit.create(reg, layers=[])\n\n# Displacement gate\nD_gate = jqtc.D(Na, displacement_final, ts=ts)\n\n# Idle gate accounts for the always-on dispersive coupling\nIdle_gate = jqtc.Id([Na,Nq])\nIdle_gate = Idle_gate.add_Ht(Ht)\n\n# Displacement gate and idle gate are on the same layer\ncirq.append(D_gate, 0, default_simulate_mode=\"hamiltonian\")\ncirq.append(Idle_gate, [0,1], new_layer=False)\n\n\n# Qubit begins in ground state, resonator in vacuum state\ninitial_state = jqt.basis(Na, 0) ^ jqt.basis(Nq, 0)\nres_g = jqtc.simulate(cirq, initial_state, mode=\"default\")\n\n# Qubit begins in excited state, resonator in vacuum state\ninitial_state = jqt.basis(Na, 0) ^ jqt.basis(Nq, 1)\nres_e = jqtc.simulate(cirq, initial_state, mode=\"default\")\n\n\n# Plot ======\n\nresults_g = res_g[1]\nresults_e = res_e[1]\n\nq = (a + a.dag())/2\np = 1j * (a.dag() - a)/2\n\nq_exp_t_g = jqt.overlap(results_g, q)\np_exp_t_g = jqt.overlap(results_g, p)\nq_exp_t_e = jqt.overlap(results_e, q)\np_exp_t_e = jqt.overlap(results_e, p)\n\nplt.plot(q_exp_t_g.real, p_exp_t_g.real, color=\"blue\", label=\"Ground State\")\nplt.plot(q_exp_t_e.real, p_exp_t_e.real, color=\"red\", label=\"Excited State\")\n\nplt.axhline(jnp.imag(displacement_final), color=\"green\", linestyle=\"--\", label=\"Final Displacement\")\nplt.axvline(jnp.real(displacement_final), color=\"green\", linestyle=\"--\")\n\nplt.xlabel(\"q = Re[\u03b1]\")\nplt.ylabel(\"p = Im[\u03b1]\")\nplt.title(\"Phase Space Trajectory\")\nplt.legend()\nplt.grid()\nplt.show()\n</pre> displacement_final = 4.0j # try increasing this to get a larger final displacement! Na = 100 # and try increasing the resonator size to accommodate larger displacements! Nq = 2  a = jqt.destroy(Na) ^ jqt.identity(Nq) sz = jqt.identity(Na) ^ jqt.sigmaz()   # Dispersive coupling strength is 32kHz \u03c7 = 2 * jnp.pi * 32e-6 # [2pi x GHz]  t_final = 1000 # [ns] ts = jnp.linspace(0, t_final, 1001)   def Ht(t):     H = \u03c7 * (a.dag() @ a) @ sz     return H  reg = jqtc.Register([Na,Nq]) cirq = jqtc.Circuit.create(reg, layers=[])  # Displacement gate D_gate = jqtc.D(Na, displacement_final, ts=ts)  # Idle gate accounts for the always-on dispersive coupling Idle_gate = jqtc.Id([Na,Nq]) Idle_gate = Idle_gate.add_Ht(Ht)  # Displacement gate and idle gate are on the same layer cirq.append(D_gate, 0, default_simulate_mode=\"hamiltonian\") cirq.append(Idle_gate, [0,1], new_layer=False)   # Qubit begins in ground state, resonator in vacuum state initial_state = jqt.basis(Na, 0) ^ jqt.basis(Nq, 0) res_g = jqtc.simulate(cirq, initial_state, mode=\"default\")  # Qubit begins in excited state, resonator in vacuum state initial_state = jqt.basis(Na, 0) ^ jqt.basis(Nq, 1) res_e = jqtc.simulate(cirq, initial_state, mode=\"default\")   # Plot ======  results_g = res_g[1] results_e = res_e[1]  q = (a + a.dag())/2 p = 1j * (a.dag() - a)/2  q_exp_t_g = jqt.overlap(results_g, q) p_exp_t_g = jqt.overlap(results_g, p) q_exp_t_e = jqt.overlap(results_e, q) p_exp_t_e = jqt.overlap(results_e, p)  plt.plot(q_exp_t_g.real, p_exp_t_g.real, color=\"blue\", label=\"Ground State\") plt.plot(q_exp_t_e.real, p_exp_t_e.real, color=\"red\", label=\"Excited State\")  plt.axhline(jnp.imag(displacement_final), color=\"green\", linestyle=\"--\", label=\"Final Displacement\") plt.axvline(jnp.real(displacement_final), color=\"green\", linestyle=\"--\")  plt.xlabel(\"q = Re[\u03b1]\") plt.ylabel(\"p = Im[\u03b1]\") plt.title(\"Phase Space Trajectory\") plt.legend() plt.grid() plt.show() <pre>100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 9109.93%/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:01&lt;00:00,  1.64s/it]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 8516.53%/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:01&lt;00:00,  1.25s/it]\n</pre> <p>Here, we extend the last example to simulate the full echoed conditional displacement gate, as done in Sivak et al. Nature (2023) and as shown below.</p> <p></p> In\u00a0[8]: Copied! <pre># Setup simulation ====\nalpha = 4.0j # try increasing this to get a larger final displacement!\ndelay_time = 1000\nNa = 100 # and try increasing the resonator size to accommodate larger displacements!\nNq = 2\n\na = jqt.destroy(Na) ^ jqt.identity(Nq)\nsz = jqt.identity(Na) ^ jqt.sigmaz()\n\n# Dispersive coupling strength is 32kHz\n\u03c7 = 2 * jnp.pi * 32e-6 # [2pi x GHz]\nts = jnp.linspace(0, 100, 1001) # [ns]\n\n\ndef Ht(t):\n    H = \u03c7 * (a.dag() @ a) @ sz / 2\n    return H\n\nidle_gate = jqtc.Id([Na,Nq]) # no times specified\nidle_gate = idle_gate.add_Ht(Ht)\n\ndelay_gate = jqtc.Id([Na,Nq], ts=jnp.linspace(0, delay_time, 1001))\ndelay_gate = delay_gate.add_Ht(Ht)\n\nreg = jqtc.Register([Na,Nq])\ncirq = jqtc.Circuit.create(reg, layers=[])\n\n# Step 1: Displace out\ncirq.append(jqtc.D(Na, alpha, ts=ts), 0, default_simulate_mode=\"hamiltonian\")\ncirq.append(idle_gate.copy(), [0,1], new_layer=False)\n\n# Step 2: Wait\ncirq.append(delay_gate.copy(), [0,1], default_simulate_mode=\"hamiltonian\")\n\n# Step 3: Displace back\ncirq.append(jqtc.D(Na, -alpha*jnp.cos(\u03c7*delay_time/2), ts=ts), 0, default_simulate_mode=\"hamiltonian\")\ncirq.append(idle_gate.copy(), [0,1], new_layer=False)\n\n# Step 4: Qubit pi pulse\ncirq.append(jqtc.X(), 1)\n\n# Step 5: Displace out again\ncirq.append(jqtc.D(Na, -alpha*jnp.cos(\u03c7*delay_time/2), ts=ts), 0, default_simulate_mode=\"hamiltonian\")\ncirq.append(idle_gate.copy(), [0,1], new_layer=False)\n\n# Step 6: Wait\ncirq.append(delay_gate.copy(), [0,1], default_simulate_mode=\"hamiltonian\")\n\n# Step 7: Displace back\ncirq.append(jqtc.D(Na, alpha*jnp.cos(\u03c7*delay_time), ts=ts), 0, default_simulate_mode=\"hamiltonian\")\ncirq.append(idle_gate.copy(), [0,1], new_layer=False)\n# ====\n\n# Simulate ====\n\ninitial_state = jqt.basis(Na, 0) ^ jqt.basis(Nq, 0)\nres_g = jqtc.simulate(cirq, initial_state, mode=\"default\")\n\ninitial_state = jqt.basis(Na, 0) ^ jqt.basis(Nq, 1)\nres_e = jqtc.simulate(cirq, initial_state, mode=\"default\")\n# =====\n\n# Plot ====\nq = (a + a.dag())/2\np = 1j * (a.dag() - a)/2\n\nq_exp_t_g = jnp.concatenate([jqt.overlap(res_g_i, q) for res_g_i in res_g])\np_exp_t_g = jnp.concatenate([jqt.overlap(res_g_i, p) for res_g_i in res_g])\nq_exp_t_e = jnp.concatenate([jqt.overlap(res_e_i, q) for res_e_i in res_e])\np_exp_t_e = jnp.concatenate([jqt.overlap(res_e_i, p) for res_e_i in res_e])\n\nplt.plot(q_exp_t_g.real, p_exp_t_g.real, color=\"blue\", label=\"Ground State\")\nplt.plot(q_exp_t_e.real, p_exp_t_e.real, color=\"red\", label=\"Excited State\")\n\nplt.xlabel(\"q = Re[\u03b1]\")\nplt.ylabel(\"p = Im[\u03b1]\")\nplt.title(\"Phase Space Trajectory\")\nplt.legend()\nplt.grid()\nplt.show()\n# ====\n</pre> # Setup simulation ==== alpha = 4.0j # try increasing this to get a larger final displacement! delay_time = 1000 Na = 100 # and try increasing the resonator size to accommodate larger displacements! Nq = 2  a = jqt.destroy(Na) ^ jqt.identity(Nq) sz = jqt.identity(Na) ^ jqt.sigmaz()  # Dispersive coupling strength is 32kHz \u03c7 = 2 * jnp.pi * 32e-6 # [2pi x GHz] ts = jnp.linspace(0, 100, 1001) # [ns]   def Ht(t):     H = \u03c7 * (a.dag() @ a) @ sz / 2     return H  idle_gate = jqtc.Id([Na,Nq]) # no times specified idle_gate = idle_gate.add_Ht(Ht)  delay_gate = jqtc.Id([Na,Nq], ts=jnp.linspace(0, delay_time, 1001)) delay_gate = delay_gate.add_Ht(Ht)  reg = jqtc.Register([Na,Nq]) cirq = jqtc.Circuit.create(reg, layers=[])  # Step 1: Displace out cirq.append(jqtc.D(Na, alpha, ts=ts), 0, default_simulate_mode=\"hamiltonian\") cirq.append(idle_gate.copy(), [0,1], new_layer=False)  # Step 2: Wait cirq.append(delay_gate.copy(), [0,1], default_simulate_mode=\"hamiltonian\")  # Step 3: Displace back cirq.append(jqtc.D(Na, -alpha*jnp.cos(\u03c7*delay_time/2), ts=ts), 0, default_simulate_mode=\"hamiltonian\") cirq.append(idle_gate.copy(), [0,1], new_layer=False)  # Step 4: Qubit pi pulse cirq.append(jqtc.X(), 1)  # Step 5: Displace out again cirq.append(jqtc.D(Na, -alpha*jnp.cos(\u03c7*delay_time/2), ts=ts), 0, default_simulate_mode=\"hamiltonian\") cirq.append(idle_gate.copy(), [0,1], new_layer=False)  # Step 6: Wait cirq.append(delay_gate.copy(), [0,1], default_simulate_mode=\"hamiltonian\")  # Step 7: Displace back cirq.append(jqtc.D(Na, alpha*jnp.cos(\u03c7*delay_time), ts=ts), 0, default_simulate_mode=\"hamiltonian\") cirq.append(idle_gate.copy(), [0,1], new_layer=False) # ====  # Simulate ====  initial_state = jqt.basis(Na, 0) ^ jqt.basis(Nq, 0) res_g = jqtc.simulate(cirq, initial_state, mode=\"default\")  initial_state = jqt.basis(Na, 0) ^ jqt.basis(Nq, 1) res_e = jqtc.simulate(cirq, initial_state, mode=\"default\") # =====  # Plot ==== q = (a + a.dag())/2 p = 1j * (a.dag() - a)/2  q_exp_t_g = jnp.concatenate([jqt.overlap(res_g_i, q) for res_g_i in res_g]) p_exp_t_g = jnp.concatenate([jqt.overlap(res_g_i, p) for res_g_i in res_g]) q_exp_t_e = jnp.concatenate([jqt.overlap(res_e_i, q) for res_e_i in res_e]) p_exp_t_e = jnp.concatenate([jqt.overlap(res_e_i, p) for res_e_i in res_e])  plt.plot(q_exp_t_g.real, p_exp_t_g.real, color=\"blue\", label=\"Ground State\") plt.plot(q_exp_t_e.real, p_exp_t_e.real, color=\"red\", label=\"Excited State\")  plt.xlabel(\"q = Re[\u03b1]\") plt.ylabel(\"p = Im[\u03b1]\") plt.title(\"Phase Space Trajectory\") plt.legend() plt.grid() plt.show() # ==== <pre>100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 9135.13%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 13846.70%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 7107.91%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 7175.64%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 13842.59%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 5558.02%/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 7/7 [00:07&lt;00:00,  1.00s/it]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 9140.11%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 13987.54%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 7322.97%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 7397.10%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 13650.22%/s]\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:00&lt;00:00, 5291.30%/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 7/7 [00:07&lt;00:00,  1.02s/it]\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"documentation/tutorials/circuits.html#circuits","title":"Circuits\u00b6","text":""},{"location":"documentation/tutorials/circuits.html#basics","title":"Basics\u00b6","text":""},{"location":"documentation/tutorials/circuits.html#optimization","title":"Optimization\u00b6","text":""},{"location":"documentation/tutorials/circuits.html#hamiltonian-simulations","title":"Hamiltonian Simulations\u00b6","text":""},{"location":"documentation/tutorials/circuits.html#echoed-conditional-displacement-gate","title":"Echoed Conditional Displacement Gate\u00b6","text":""},{"location":"documentation/tutorials/visualization.html","title":"Visualization of Wigner and Q-Functions for Quantum States","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install git+https://github.com/EQuS/jaxquantum.git # Comment this out if running in colab to install jaxquantum.\n</pre> # !pip install git+https://github.com/EQuS/jaxquantum.git # Comment this out if running in colab to install jaxquantum. <p>This notebook demonstrates how to utilize <code>plot_wigner</code> and <code>plot_qfunc</code> functions for visualizing quantum states, including single and batched states such as coherent and GKP states.</p> In\u00a0[1]: Copied! <pre>import jaxquantum as jqt\nimport jaxquantum.codes as jqtb\nimport matplotlib.pyplot as plt\nimport jax.numpy as jnp\nimport numpy as np\n</pre> import jaxquantum as jqt import jaxquantum.codes as jqtb import matplotlib.pyplot as plt import jax.numpy as jnp import numpy as np In\u00a0[2]: Copied! <pre># Parameters for phase space grid\nxvec = jnp.linspace(-3, 3, 51)\nyvec = jnp.linspace(-3, 3, 51)\n\n# Create a coherent state |\u03b1\u27e9 with amplitude \u03b1 = 1.0\nalpha = 1.0\nstate = jqt.displace(30, alpha) @ jqt.basis(30, 0)\n\n# Plot the Wigner function\njqt.plot_wigner(state, xvec, yvec)\nplt.show()\n</pre> # Parameters for phase space grid xvec = jnp.linspace(-3, 3, 51) yvec = jnp.linspace(-3, 3, 51)  # Create a coherent state |\u03b1\u27e9 with amplitude \u03b1 = 1.0 alpha = 1.0 state = jqt.displace(30, alpha) @ jqt.basis(30, 0)  # Plot the Wigner function jqt.plot_wigner(state, xvec, yvec) plt.show() In\u00a0[3]: Copied! <pre># Multiple displacements (batch of coherent states)\nalphas = jnp.array([0.5, 1.0, 1.5])\nstates = jqt.displace(30, alphas) @ jqt.basis(30, 0)\n\n# Plot the batch of Wigner functions with subtitles\njqt.plot_wigner(states, xvec, yvec, subtitles=np.array([f\"\u03b1 = {alpha}\" for alpha in alphas]))\nplt.show()\n</pre> # Multiple displacements (batch of coherent states) alphas = jnp.array([0.5, 1.0, 1.5]) states = jqt.displace(30, alphas) @ jqt.basis(30, 0)  # Plot the batch of Wigner functions with subtitles jqt.plot_wigner(states, xvec, yvec, subtitles=np.array([f\"\u03b1 = {alpha}\" for alpha in alphas])) plt.show() In\u00a0[4]: Copied! <pre># Generate a GKP state (logical |+\u27e9 state)\ngkp_qubit = jqtb.GKPQubit({\"N\": 30, \"delta\": 0.4})\nstate = gkp_qubit.basis[\"+z\"]\n\n# Plot the Q-function\njqt.plot_qfunc(state, xvec, yvec)\nplt.show()\n</pre> # Generate a GKP state (logical |+\u27e9 state) gkp_qubit = jqtb.GKPQubit({\"N\": 30, \"delta\": 0.4}) state = gkp_qubit.basis[\"+z\"]  # Plot the Q-function jqt.plot_qfunc(state, xvec, yvec) plt.show()"},{"location":"documentation/tutorials/visualization.html#visualization-of-wigner-and-q-functions-for-quantum-states","title":"Visualization of Wigner and Q-Functions for Quantum States\u00b6","text":""},{"location":"documentation/tutorials/visualization.html#visualizing-the-wigner-function-for-coherent-states","title":"Visualizing the Wigner Function for Coherent States\u00b6","text":""},{"location":"documentation/tutorials/visualization.html#batched-visualization-of-wigner-functions-for-coherent-states","title":"Batched Visualization of Wigner Functions for Coherent States\u00b6","text":""},{"location":"documentation/tutorials/visualization.html#visualizing-the-q-function-for-gkp-states","title":"Visualizing the Q-Function for GKP States\u00b6","text":""},{"location":"reference/summary.html","title":"Summary","text":"<ul> <li>jaxquantum<ul> <li>circuits<ul> <li>circuits</li> <li>constants</li> <li>gates</li> <li>library<ul> <li>generic</li> <li>oscillator</li> <li>qubit</li> </ul> </li> <li>simulate</li> </ul> </li> <li>codes<ul> <li>base</li> <li>binomial</li> <li>cat</li> <li>gkp</li> <li>mode</li> <li>qubit</li> </ul> </li> <li>core<ul> <li>cfunctions</li> <li>conversions</li> <li>dims</li> <li>measurements</li> <li>operators</li> <li>qarray</li> <li>qp_distributions</li> <li>settings</li> <li>solvers</li> <li>visualization</li> </ul> </li> <li>devices<ul> <li>analysis<ul> <li>sweeps</li> </ul> </li> <li>base<ul> <li>base</li> <li>system</li> </ul> </li> <li>common<ul> <li>utils</li> </ul> </li> <li>superconducting<ul> <li>ats</li> <li>drive</li> <li>flux_base</li> <li>fluxonium</li> <li>ideal_qubit</li> <li>kno</li> <li>resonator</li> <li>snail</li> <li>transmon</li> <li>tunable_transmon</li> </ul> </li> </ul> </li> <li>utils<ul> <li>hermgauss</li> <li>units</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/jaxquantum/index.html","title":"jaxquantum","text":"<p>jaxquantum</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray","title":"<code>Qarray</code>","text":"Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@struct.dataclass  # this allows us to send in and return Qarray from jitted functions\nclass Qarray:\n    _data: Array\n    _qdims: Qdims = struct.field(pytree_node=False)\n    _bdims: tuple[int] = struct.field(pytree_node=False)\n\n    # Initialization ----\n    @classmethod\n    def create(cls, data, dims=None, bdims=None):\n        # Step 1: Prepare data ----\n        data = jnp.asarray(data)\n\n        if len(data.shape) == 1 and data.shape[0] &gt; 0:\n            data = data.reshape(data.shape[0], 1)\n\n        if len(data.shape) &gt;= 2:\n            if data.shape[-2] != data.shape[-1] and not (\n                data.shape[-2] == 1 or data.shape[-1] == 1\n            ):\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n\n        if bdims is not None:\n            if len(data.shape) - len(bdims) == 1:\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n        # ----\n\n        # Step 2: Prepare dimensions ----\n        if bdims is None:\n            bdims = tuple(data.shape[:-2])\n\n        if dims is None:\n            dims = ((data.shape[-2],), (data.shape[-1],))\n\n        if not isinstance(dims[0], (list, tuple)):\n            # This handles the case where only the hilbert space dimensions are sent in.\n            if data.shape[-1] == 1:\n                dims = (tuple(dims), tuple([1 for _ in dims]))\n            elif data.shape[-2] == 1:\n                dims = (tuple([1 for _ in dims]), tuple(dims))\n            else:\n                dims = (tuple(dims), tuple(dims))\n        else:\n            dims = (tuple(dims[0]), tuple(dims[1]))\n\n        check_dims(dims, bdims, data.shape)\n\n        qdims = Qdims(dims)\n\n        # NOTE: Constantly tidying up on Qarray creation might be a bit overkill.\n        # It increases the compilation time, but only very slightly\n        # increased the runtime of the jit compiled function.\n        # We could instead use this tidy_up where we think we need it.\n        data = tidy_up(data, SETTINGS[\"auto_tidyup_atol\"])\n\n        return cls(data, qdims, bdims)\n\n    # ----\n\n    @classmethod\n    def from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n        \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n        data = jnp.array([qarr.data for qarr in qarr_list])\n\n        if len(qarr_list) == 0:\n            dims = ((), ())\n            bdims = ()\n        else:\n            dims = qarr_list[0].dims\n            bdims = qarr_list[0].bdims\n\n        if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n            raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n        bdims = (len(qarr_list),) + bdims\n\n        return cls.create(data, dims=dims, bdims=bdims)\n\n    @classmethod\n    def from_array(cls, qarr_arr) -&gt; Qarray:\n        \"\"\"Create a Qarray from a nested list of Qarrays.\n\n        Args:\n            qarr_arr (list): nested list of Qarrays\n\n        Returns:\n            Qarray: Qarray object\n        \"\"\"\n        if isinstance(qarr_arr, Qarray):\n            return qarr_arr\n\n        bdims = ()\n        lvl = qarr_arr\n        while not isinstance(lvl, Qarray):\n            bdims = bdims + (len(lvl),)\n            if len(lvl) &gt; 0:\n                lvl = lvl[0]\n            else:\n                break\n\n        def flat(lis):\n            flatList = []\n            for element in lis:\n                if type(element) is list:\n                    flatList += flat(element)\n                else:\n                    flatList.append(element)\n            return flatList\n\n        qarr_list = flat(qarr_arr)\n        qarr = cls.from_list(qarr_list)\n        qarr = qarr.reshape_bdims(*bdims)\n        return qarr\n\n    # Properties ----\n    @property\n    def qtype(self):\n        return self._qdims.qtype\n\n    @property\n    def dtype(self):\n        return self._data.dtype\n\n    @property\n    def dims(self):\n        return self._qdims.dims\n\n    @property\n    def bdims(self):\n        return self._bdims\n\n    @property\n    def qdims(self):\n        return self._qdims\n\n    @property\n    def space_dims(self):\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return self.dims[0]\n        elif self.qtype == Qtypes.bra:\n            return self.dims[1]\n        else:\n            # TODO: not reached for some reason\n            raise ValueError(\"Unsupported qtype.\")\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def shaped_data(self):\n        return self._data.reshape(self.bdims + self.dims[0] + self.dims[1])\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def is_batched(self):\n        return len(self.bdims) &gt; 0\n\n    def __getitem__(self, index):\n        if len(self.bdims) &gt; 0:\n            return Qarray.create(\n                self.data[index],\n                dims=self.dims,\n            )\n        else:\n            raise ValueError(\"Cannot index a non-batched Qarray.\")\n\n    def reshape_bdims(self, *args):\n        \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n        new_bdims = tuple(args)\n\n        if prod(new_bdims) == 0:\n            new_shape = new_bdims\n        else:\n            new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n        return Qarray.create(\n            self.data.reshape(new_shape),\n            dims=self.dims,\n            bdims=new_bdims,\n        )\n\n    def space_to_qdims(self, space_dims: List[int]):\n        if isinstance(space_dims[0], (list, tuple)):\n            return space_dims\n\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return (tuple(space_dims), tuple([1 for _ in range(len(space_dims))]))\n        elif self.qtype == Qtypes.bra:\n            return (tuple([1 for _ in range(len(space_dims))]), tuple(space_dims))\n        else:\n            raise ValueError(\"Unsupported qtype for space_to_qdims conversion.\")\n\n    def reshape_qdims(self, *args):\n        \"\"\"Reshape the quantum dimensions of the Qarray.\n\n        Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n        Args:\n            *args: new Hilbert dimensions for the Qarray.\n\n        Returns:\n            Qarray: reshaped Qarray.\n        \"\"\"\n\n        new_space_dims = tuple(args)\n        current_space_dims = self.space_dims\n        assert prod(new_space_dims) == prod(current_space_dims)\n\n        new_qdims = self.space_to_qdims(new_space_dims)\n        new_bdims = self.bdims\n\n        return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n\n    def resize(self, new_shape):\n        \"\"\"Resize the Qarray to a new shape.\n\n        TODO: review and maybe deprecate this method.\n        \"\"\"\n        dims = self.dims\n        data = jnp.resize(self.data, new_shape)\n        return Qarray.create(\n            data,\n            dims=dims,\n        )\n\n    def __len__(self):\n        \"\"\"Length of the Qarray.\"\"\"\n        if len(self.bdims) &gt; 0:\n            return self.data.shape[0]\n        else:\n            raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Qarray):\n            raise ValueError(\"Cannot calculate equality of a Qarray with a non-Qarray.\")\n\n        if self.dims != other.dims:\n            return False\n\n        if self.bdims != other.bdims:\n            return False\n\n        return jnp.all(self.data == other.data)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # ----\n\n    # Elementary Math ----\n    def __matmul__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        _qdims_new = self._qdims @ other._qdims\n        return Qarray.create(\n            self.data @ other.data,\n            dims=_qdims_new.dims,\n        )\n\n    # NOTE: not possible to reach this.\n    # def __rmatmul__(self, other):\n    #     if not isinstance(other, Qarray):\n    #         return NotImplemented\n\n    #     _qdims_new = other._qdims @ self._qdims\n    #     return Qarray.create(\n    #         other.data @ self.data,\n    #         dims=_qdims_new.dims,\n    #     )\n\n    def __mul__(self, other):\n        if isinstance(other, Qarray):\n            return self.__matmul__(other)\n\n        other = other + 0.0j\n        if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n            other = other.reshape(other.shape + (1, 1))\n\n        return Qarray.create(\n            other * self.data,\n            dims=self._qdims.dims,\n        )\n\n    def __rmul__(self, other):\n        # NOTE: not possible to reach this.\n        # if isinstance(other, Qarray):\n        #     return self.__rmatmul__(other)\n\n        return self.__mul__(other)\n\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    def __truediv__(self, other):\n        \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n        if isinstance(other, Qarray):\n            raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n        return self.__mul__(1 / other)\n\n    def __add__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data + other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__add__(other)\n\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data - other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__sub__(other)\n\n        return NotImplemented\n\n    def __rsub__(self, other):\n        return self.__neg__().__add__(other)\n\n    def __xor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(self, other)\n\n    def __rxor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(other, self)\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n\n        return powm(self, other)\n\n    # ----\n\n    # String Representation ----\n    def _str_header(self):\n        out = \", \".join(\n            [\n                \"Quantum array: dims = \" + str(self.dims),\n                \"bdims = \" + str(self.bdims),\n                \"shape = \" + str(self._data.shape),\n                \"type = \" + str(self.qtype),\n            ]\n        )\n        return out\n\n    def __str__(self):\n        return self._str_header() + \"\\nQarray data =\\n\" + str(self.data)\n\n    @property\n    def header(self):\n        \"\"\"Print the header of the Qarray.\"\"\"\n        return self._str_header()\n\n    def __repr__(self):\n        return self.__str__()\n\n    # ----\n\n    # Utilities ----\n    def copy(self, memo=None):\n        # return Qarray.create(deepcopy(self.data), dims=self.dims)\n        return self.__deepcopy__(memo)\n\n    def __deepcopy__(self, memo):\n        \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n        return Qarray(\n            _data=deepcopy(self._data, memo=memo),\n            _qdims=deepcopy(self._qdims, memo=memo),\n            _bdims=deepcopy(self._bdims, memo=memo),\n        )\n\n    def __getattr__(self, method_name):\n        if \"__\" == method_name[:2]:\n            # NOTE: we return NotImplemented for binary special methods logic in python, plus things like __jax_array__\n            return lambda *args, **kwargs: NotImplemented\n\n        modules = [jnp, jnp.linalg, jsp, jsp.linalg]\n\n        method_f = None\n        for mod in modules:\n            method_f = getattr(mod, method_name, None)\n            if method_f is not None:\n                break\n\n        if method_f is None:\n            raise NotImplementedError(\n                f\"Method {method_name} does not exist. No backup method found in {modules}.\"\n            )\n\n        def func(*args, **kwargs):\n            res = method_f(self.data, *args, **kwargs)\n\n            if getattr(res, \"shape\", None) is None or res.shape != self.data.shape:\n                return res\n            else:\n                return Qarray.create(res, dims=self._qdims.dims)\n\n        return func\n\n    # ----\n\n    # Conversions / Reshaping ----\n    def dag(self):\n        return dag(self)\n\n    def to_dm(self):\n        return ket2dm(self)\n\n    def is_dm(self):\n        return self.qtype == Qtypes.oper\n\n    def is_vec(self):\n        return self.qtype == Qtypes.ket or self.qtype == Qtypes.bra\n\n    def to_ket(self):\n        return to_ket(self)\n\n    def transpose(self, *args):\n        return transpose(self, *args)\n\n    def keep_only_diag_elements(self):\n        return keep_only_diag_elements(self)\n\n    # ----\n\n    # Math Functions ----\n    def unit(self):\n        return unit(self)\n\n    def norm(self):\n        return norm(self)\n\n    def expm(self):\n        return expm(self)\n\n    def powm(self, n):\n        return powm(self, n)\n\n    def cosm(self):\n        return cosm(self)\n\n    def sinm(self):\n        return sinm(self)\n\n    def tr(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def trace(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def ptrace(self, indx):\n        return ptrace(self, indx)\n\n    def eigenstates(self):\n        return eigenstates(self)\n\n    def eigenenergies(self):\n        return eigenenergies(self)\n\n    def collapse(self, mode=\"sum\"):\n        return collapse(self, mode=mode)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.header","title":"<code>header</code>  <code>property</code>","text":"<p>Print the header of the Qarray.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Need to override this when defininig getattr.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n    return Qarray(\n        _data=deepcopy(self._data, memo=memo),\n        _qdims=deepcopy(self._qdims, memo=memo),\n        _bdims=deepcopy(self._bdims, memo=memo),\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.__len__","title":"<code>__len__()</code>","text":"<p>Length of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __len__(self):\n    \"\"\"Length of the Qarray.\"\"\"\n    if len(self.bdims) &gt; 0:\n        return self.data.shape[0]\n    else:\n        raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>For Qarray's, this only really makes sense in the context of division by a scalar.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n    if isinstance(other, Qarray):\n        raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n    return self.__mul__(1 / other)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.from_array","title":"<code>from_array(qarr_arr)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a nested list of Qarrays.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_arr</code> <code>list</code> <p>nested list of Qarrays</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Qarray object</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_array(cls, qarr_arr) -&gt; Qarray:\n    \"\"\"Create a Qarray from a nested list of Qarrays.\n\n    Args:\n        qarr_arr (list): nested list of Qarrays\n\n    Returns:\n        Qarray: Qarray object\n    \"\"\"\n    if isinstance(qarr_arr, Qarray):\n        return qarr_arr\n\n    bdims = ()\n    lvl = qarr_arr\n    while not isinstance(lvl, Qarray):\n        bdims = bdims + (len(lvl),)\n        if len(lvl) &gt; 0:\n            lvl = lvl[0]\n        else:\n            break\n\n    def flat(lis):\n        flatList = []\n        for element in lis:\n            if type(element) is list:\n                flatList += flat(element)\n            else:\n                flatList.append(element)\n        return flatList\n\n    qarr_list = flat(qarr_arr)\n    qarr = cls.from_list(qarr_list)\n    qarr = qarr.reshape_bdims(*bdims)\n    return qarr\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.from_list","title":"<code>from_list(qarr_list)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a list of Qarrays.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n    \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n    data = jnp.array([qarr.data for qarr in qarr_list])\n\n    if len(qarr_list) == 0:\n        dims = ((), ())\n        bdims = ()\n    else:\n        dims = qarr_list[0].dims\n        bdims = qarr_list[0].bdims\n\n    if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n        raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n    bdims = (len(qarr_list),) + bdims\n\n    return cls.create(data, dims=dims, bdims=bdims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.reshape_bdims","title":"<code>reshape_bdims(*args)</code>","text":"<p>Reshape the batch dimensions of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_bdims(self, *args):\n    \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n    new_bdims = tuple(args)\n\n    if prod(new_bdims) == 0:\n        new_shape = new_bdims\n    else:\n        new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n    return Qarray.create(\n        self.data.reshape(new_shape),\n        dims=self.dims,\n        bdims=new_bdims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.reshape_qdims","title":"<code>reshape_qdims(*args)</code>","text":"<p>Reshape the quantum dimensions of the Qarray.</p> <p>Note that this does not take in qdims but rather the new Hilbert space dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>new Hilbert dimensions for the Qarray.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>reshaped Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_qdims(self, *args):\n    \"\"\"Reshape the quantum dimensions of the Qarray.\n\n    Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n    Args:\n        *args: new Hilbert dimensions for the Qarray.\n\n    Returns:\n        Qarray: reshaped Qarray.\n    \"\"\"\n\n    new_space_dims = tuple(args)\n    current_space_dims = self.space_dims\n    assert prod(new_space_dims) == prod(current_space_dims)\n\n    new_qdims = self.space_to_qdims(new_space_dims)\n    new_bdims = self.bdims\n\n    return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Qarray.resize","title":"<code>resize(new_shape)</code>","text":"<p>Resize the Qarray to a new shape.</p> <p>TODO: review and maybe deprecate this method.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def resize(self, new_shape):\n    \"\"\"Resize the Qarray to a new shape.\n\n    TODO: review and maybe deprecate this method.\n    \"\"\"\n    dims = self.dims\n    data = jnp.resize(self.data, new_shape)\n    return Qarray.create(\n        data,\n        dims=dims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.QuantumStateTomography","title":"<code>QuantumStateTomography</code>","text":"Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>class QuantumStateTomography:\n    def __init__(\n        self,\n        rho_guess: Qarray,\n        measurement_basis: Qarray,\n        measurement_results: jnp.ndarray,\n        complete_basis: Optional[Qarray] = None,\n        true_rho: Optional[Qarray] = None,\n    ):\n        \"\"\"\n        Reconstruct a quantum state from measurement results using quantum state tomography.\n        The tomography can be performed either by direct inversion or by maximum likelihood estimation.\n\n        Args:\n            rho_guess (Qarray): The initial guess for the quantum state.\n            measurement_basis (Qarray): The basis in which measurements are performed.\n            measurement_results (jnp.ndarray): The results of the measurements.\n            complete_basis (Optional[Qarray]): The complete basis for state \n            reconstruction used when using direct inversion. \n            Defaults to the measurement basis if not provided.\n            true_rho (Optional[Qarray]): The true quantum state, if known.\n\n        \"\"\"\n        self.rho_guess = rho_guess.data\n        self.measurement_basis = measurement_basis.data\n        self.measurement_results = measurement_results\n        self.complete_basis = (\n            complete_basis.data\n            if (complete_basis is not None)\n            else measurement_basis.data\n        )\n        self.true_rho = true_rho\n        self._result = None\n\n    @property\n    def result(self) -&gt; Optional[MLETomographyResult]:\n        return self._result\n\n\n    def quantum_state_tomography_mle(\n        self, L1_reg_strength: float = 0.0, epochs: int = 10000, lr: float = 5e-3\n    ) -&gt; MLETomographyResult:\n        \"\"\"Perform quantum state tomography using maximum likelihood \n        estimation (MLE).\n\n        This method reconstructs the quantum state from measurement results \n        by optimizing\n        a likelihood function using gradient descent. The optimization \n        ensures the \n        resulting density matrix is positive semi-definite with trace 1.\n\n        Args:\n            L1_reg_strength (float, optional): Strength of L1 \n            regularization. Defaults to 0.0.\n            epochs (int, optional): Number of optimization iterations. \n            Defaults to 10000.\n            lr (float, optional): Learning rate for the Adam optimizer. \n            Defaults to 5e-3.\n\n        Returns:\n            MLETomographyResult: Named tuple containing:\n                - rho: Reconstructed quantum state as Qarray\n                - params_history: List of parameter values during optimization\n                - loss_history: List of loss values during optimization\n                - grads_history: List of gradient values during optimization\n                - infidelity_history: List of infidelities if true_rho was \n                provided, None otherwise\n        \"\"\"\n\n        dim = self.rho_guess.shape[0]\n        optimizer = optax.adam(lr)\n\n        # Initialize parameters from the initial guess for the density matrix\n        params = _parametrize_density_matrix(self.rho_guess, dim)\n        opt_state = optimizer.init(params)\n\n        compute_infidelity_flag = self.true_rho is not None\n\n        # Provide a dummy array if no true_rho is available. It won't be used.\n        true_rho_data_or_dummy = (\n            self.true_rho.data\n            if compute_infidelity_flag\n            else jnp.empty((dim, dim), dtype=jnp.complex64)\n        )\n\n        final_carry, history = _run_tomography_scan(\n            initial_params=params,\n            initial_opt_state=opt_state,\n            true_rho_data=true_rho_data_or_dummy,\n            measurement_basis=self.measurement_basis,\n            measurement_results=self.measurement_results,\n            dim=dim,\n            epochs=epochs,\n            optimizer=optimizer,\n            compute_infidelity=compute_infidelity_flag,\n            L1_reg_strength=L1_reg_strength,\n        )\n\n        final_params, _ = final_carry\n\n        rho = Qarray.create(_reconstruct_density_matrix(final_params, dim))\n\n        self._result = MLETomographyResult(\n            rho=rho,\n            params_history=history[\"params\"],\n            loss_history=history[\"loss\"],\n            grads_history=history[\"grads\"],\n            infidelity_history=history[\"infidelity\"]\n            if compute_infidelity_flag\n            else None,\n        )\n        return self._result\n\n    def quantum_state_tomography_direct(\n        self,\n    ) -&gt; Qarray:\n\n        \"\"\"Perform quantum state tomography using direct inversion.\n\n        This method reconstructs the quantum state from measurement results by \n        directly solving a system of linear equations. The method assumes that\n        the measurement basis is complete and the measurement results are \n        noise-free.\n\n        Returns:\n            Qarray: Reconstructed quantum state.\n        \"\"\"\n\n    # Compute overlaps of measurement and complete operator bases\n        A = jnp.einsum(\"ijk,ljk-&gt;il\", self.complete_basis, self.measurement_basis)\n        # Solve the linear system to find the coefficients\n        coefficients = jnp.linalg.solve(A, self.measurement_results)\n        # Reconstruct the density matrix\n        rho = jnp.einsum(\"i, ijk-&gt;jk\", coefficients, self.complete_basis)\n\n        return Qarray.create(rho)\n\n    def plot_results(self):\n        if self._result is None:\n            raise ValueError(\n                \"No results to plot. Run quantum_state_tomography_mle first.\"\n            )\n\n        fig, ax = plt.subplots(1, figsize=(5, 4))\n        if self._result.infidelity_history is not None:\n            ax2 = ax.twinx()\n\n        ax.plot(self._result.loss_history, color=\"C0\")\n        ax.set_xlabel(\"Epoch\")\n        ax.set_ylabel(\"$\\\\mathcal{L}$\", color=\"C0\")\n        ax.set_yscale(\"log\")\n\n        if self._result.infidelity_history is not None:\n            ax2.plot(self._result.infidelity_history, color=\"C1\")\n            ax2.set_yscale(\"log\")\n            ax2.set_ylabel(\"$1-\\\\mathcal{F}$\", color=\"C1\")\n            plt.grid(False)\n\n        plt.show()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.QuantumStateTomography.__init__","title":"<code>__init__(rho_guess, measurement_basis, measurement_results, complete_basis=None, true_rho=None)</code>","text":"<p>Reconstruct a quantum state from measurement results using quantum state tomography. The tomography can be performed either by direct inversion or by maximum likelihood estimation.</p> <p>Parameters:</p> Name Type Description Default <code>rho_guess</code> <code>Qarray</code> <p>The initial guess for the quantum state.</p> required <code>measurement_basis</code> <code>Qarray</code> <p>The basis in which measurements are performed.</p> required <code>measurement_results</code> <code>ndarray</code> <p>The results of the measurements.</p> required <code>complete_basis</code> <code>Optional[Qarray]</code> <p>The complete basis for state </p> <code>None</code> <code>true_rho</code> <code>Optional[Qarray]</code> <p>The true quantum state, if known.</p> <code>None</code> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def __init__(\n    self,\n    rho_guess: Qarray,\n    measurement_basis: Qarray,\n    measurement_results: jnp.ndarray,\n    complete_basis: Optional[Qarray] = None,\n    true_rho: Optional[Qarray] = None,\n):\n    \"\"\"\n    Reconstruct a quantum state from measurement results using quantum state tomography.\n    The tomography can be performed either by direct inversion or by maximum likelihood estimation.\n\n    Args:\n        rho_guess (Qarray): The initial guess for the quantum state.\n        measurement_basis (Qarray): The basis in which measurements are performed.\n        measurement_results (jnp.ndarray): The results of the measurements.\n        complete_basis (Optional[Qarray]): The complete basis for state \n        reconstruction used when using direct inversion. \n        Defaults to the measurement basis if not provided.\n        true_rho (Optional[Qarray]): The true quantum state, if known.\n\n    \"\"\"\n    self.rho_guess = rho_guess.data\n    self.measurement_basis = measurement_basis.data\n    self.measurement_results = measurement_results\n    self.complete_basis = (\n        complete_basis.data\n        if (complete_basis is not None)\n        else measurement_basis.data\n    )\n    self.true_rho = true_rho\n    self._result = None\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.QuantumStateTomography.quantum_state_tomography_direct","title":"<code>quantum_state_tomography_direct()</code>","text":"<p>Perform quantum state tomography using direct inversion.</p> <p>This method reconstructs the quantum state from measurement results by  directly solving a system of linear equations. The method assumes that the measurement basis is complete and the measurement results are  noise-free.</p> <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Reconstructed quantum state.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def quantum_state_tomography_direct(\n    self,\n) -&gt; Qarray:\n\n    \"\"\"Perform quantum state tomography using direct inversion.\n\n    This method reconstructs the quantum state from measurement results by \n    directly solving a system of linear equations. The method assumes that\n    the measurement basis is complete and the measurement results are \n    noise-free.\n\n    Returns:\n        Qarray: Reconstructed quantum state.\n    \"\"\"\n\n# Compute overlaps of measurement and complete operator bases\n    A = jnp.einsum(\"ijk,ljk-&gt;il\", self.complete_basis, self.measurement_basis)\n    # Solve the linear system to find the coefficients\n    coefficients = jnp.linalg.solve(A, self.measurement_results)\n    # Reconstruct the density matrix\n    rho = jnp.einsum(\"i, ijk-&gt;jk\", coefficients, self.complete_basis)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.QuantumStateTomography.quantum_state_tomography_mle","title":"<code>quantum_state_tomography_mle(L1_reg_strength=0.0, epochs=10000, lr=0.005)</code>","text":"<p>Perform quantum state tomography using maximum likelihood  estimation (MLE).</p> <p>This method reconstructs the quantum state from measurement results  by optimizing a likelihood function using gradient descent. The optimization  ensures the  resulting density matrix is positive semi-definite with trace 1.</p> <p>Parameters:</p> Name Type Description Default <code>L1_reg_strength</code> <code>float</code> <p>Strength of L1 </p> <code>0.0</code> <code>epochs</code> <code>int</code> <p>Number of optimization iterations. </p> <code>10000</code> <code>lr</code> <code>float</code> <p>Learning rate for the Adam optimizer. </p> <code>0.005</code> <p>Returns:</p> Name Type Description <code>MLETomographyResult</code> <code>MLETomographyResult</code> <p>Named tuple containing: - rho: Reconstructed quantum state as Qarray - params_history: List of parameter values during optimization - loss_history: List of loss values during optimization - grads_history: List of gradient values during optimization - infidelity_history: List of infidelities if true_rho was  provided, None otherwise</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def quantum_state_tomography_mle(\n    self, L1_reg_strength: float = 0.0, epochs: int = 10000, lr: float = 5e-3\n) -&gt; MLETomographyResult:\n    \"\"\"Perform quantum state tomography using maximum likelihood \n    estimation (MLE).\n\n    This method reconstructs the quantum state from measurement results \n    by optimizing\n    a likelihood function using gradient descent. The optimization \n    ensures the \n    resulting density matrix is positive semi-definite with trace 1.\n\n    Args:\n        L1_reg_strength (float, optional): Strength of L1 \n        regularization. Defaults to 0.0.\n        epochs (int, optional): Number of optimization iterations. \n        Defaults to 10000.\n        lr (float, optional): Learning rate for the Adam optimizer. \n        Defaults to 5e-3.\n\n    Returns:\n        MLETomographyResult: Named tuple containing:\n            - rho: Reconstructed quantum state as Qarray\n            - params_history: List of parameter values during optimization\n            - loss_history: List of loss values during optimization\n            - grads_history: List of gradient values during optimization\n            - infidelity_history: List of infidelities if true_rho was \n            provided, None otherwise\n    \"\"\"\n\n    dim = self.rho_guess.shape[0]\n    optimizer = optax.adam(lr)\n\n    # Initialize parameters from the initial guess for the density matrix\n    params = _parametrize_density_matrix(self.rho_guess, dim)\n    opt_state = optimizer.init(params)\n\n    compute_infidelity_flag = self.true_rho is not None\n\n    # Provide a dummy array if no true_rho is available. It won't be used.\n    true_rho_data_or_dummy = (\n        self.true_rho.data\n        if compute_infidelity_flag\n        else jnp.empty((dim, dim), dtype=jnp.complex64)\n    )\n\n    final_carry, history = _run_tomography_scan(\n        initial_params=params,\n        initial_opt_state=opt_state,\n        true_rho_data=true_rho_data_or_dummy,\n        measurement_basis=self.measurement_basis,\n        measurement_results=self.measurement_results,\n        dim=dim,\n        epochs=epochs,\n        optimizer=optimizer,\n        compute_infidelity=compute_infidelity_flag,\n        L1_reg_strength=L1_reg_strength,\n    )\n\n    final_params, _ = final_carry\n\n    rho = Qarray.create(_reconstruct_density_matrix(final_params, dim))\n\n    self._result = MLETomographyResult(\n        rho=rho,\n        params_history=history[\"params\"],\n        loss_history=history[\"loss\"],\n        grads_history=history[\"grads\"],\n        infidelity_history=history[\"infidelity\"]\n        if compute_infidelity_flag\n        else None,\n    )\n    return self._result\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.Ec_to_inv_pF","title":"<code>Ec_to_inv_pF(Ec)</code>","text":"<p>GHz -&gt; 1/picoFarad</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def Ec_to_inv_pF(Ec):\n    \"\"\"\n    GHz -&gt; 1/picoFarad\n    \"\"\"\n    joule = GHz_to_joule(Ec)\n    Gjoule = joule / 1e9\n    inv_nFarad = Gjoule / ((constants.e) ** 2 / (2))\n    return inv_nFarad * 1e-3\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.as_series","title":"<code>as_series(*arrs)</code>","text":"<p>Return arguments as a list of 1-d arrays.</p> <p>The returned list contains array(s) of dtype double, complex double, or object.  A 1-d argument of shape <code>(N,)</code> is parsed into <code>N</code> arrays of size one; a 2-d argument of shape <code>(M,N)</code> is parsed into <code>M</code> arrays of size <code>N</code> (i.e., is \"parsed by row\"); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.as_series--parameters","title":"Parameters","text":"<p>arrs : array_like     1- or 2-d array_like trim : boolean, optional     When True, trailing zeros are removed from the inputs.     When False, the inputs are passed through intact.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.as_series--returns","title":"Returns","text":"<p>a1, a2,... : 1-D arrays     A copy of the input data as 1-d arrays.</p> Source code in <code>jaxquantum/utils/hermgauss.py</code> <pre><code>def as_series(*arrs):\n    \"\"\"Return arguments as a list of 1-d arrays.\n\n    The returned list contains array(s) of dtype double, complex double, or\n    object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of\n    size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays\n    of size ``N`` (i.e., is \"parsed by row\"); and a higher dimensional array\n    raises a Value Error if it is not first reshaped into either a 1-d or 2-d\n    array.\n\n    Parameters\n    ----------\n    arrs : array_like\n        1- or 2-d array_like\n    trim : boolean, optional\n        When True, trailing zeros are removed from the inputs.\n        When False, the inputs are passed through intact.\n\n    Returns\n    -------\n    a1, a2,... : 1-D arrays\n        A copy of the input data as 1-d arrays.\n\n    \"\"\"\n    arrays = tuple(jnp.array(a, ndmin=1) for a in arrs)\n    arrays = promote_dtypes_inexact(*arrays)\n    if len(arrays) == 1:\n        return arrays[0]\n    return tuple(arrays)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.basis","title":"<code>basis(N, k)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert space dimension</p> required <code>k</code> <code>int</code> <p>fock number</p> required <p>Returns:</p> Type Description <p>Fock State |k&gt;</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis(N: int, k: int):\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.\n\n    Args:\n        N: Hilbert space dimension\n        k: fock number\n\n    Returns:\n        Fock State |k&gt;\n    \"\"\"\n    return Qarray.create(one_hot(k, N).reshape(N, 1))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.basis_like","title":"<code>basis_like(A, ks)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Qarray</code> <p>state or operator.</p> required <code>k</code> <p>fock number.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Fock State |k&gt; with the same space dims as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis_like(A: Qarray, ks: List[int]) -&gt; Qarray:\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.\n\n    Args:\n        A: state or operator.\n        k: fock number.\n\n    Returns:\n        Fock State |k&gt; with the same space dims as A.\n    \"\"\"\n    space_dims = A.space_dims\n    assert len(space_dims) == len(ks), \"len(ks) must be equal to len(space_dims)\"\n\n    kets = []\n    for j, k in enumerate(ks):\n        kets.append(basis(space_dims[j], k))\n    return tensor(*kets)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.cf_wigner","title":"<code>cf_wigner(psi, xvec, yvec)</code>","text":"<p>Wigner function for a state vector or density matrix at points <code>xvec + i * yvec</code>.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.cf_wigner--parameters","title":"Parameters","text":"Qarray <p>A state vector or density matrix.</p> array_like <p>x-coordinates at which to calculate the Wigner function.</p> array_like <p>y-coordinates at which to calculate the Wigner function.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.cf_wigner--returns","title":"Returns","text":"array <p>Values representing the Wigner function calculated over the specified range [xvec,yvec].</p> Source code in <code>jaxquantum/core/cfunctions.py</code> <pre><code>def cf_wigner(psi, xvec, yvec):\n    \"\"\"Wigner function for a state vector or density matrix at points\n    `xvec + i * yvec`.\n\n    Parameters\n    ----------\n\n    state : Qarray\n        A state vector or density matrix.\n\n    xvec : array_like\n        x-coordinates at which to calculate the Wigner function.\n\n    yvec : array_like\n        y-coordinates at which to calculate the Wigner function.\n\n\n    Returns\n    -------\n\n    W : array\n        Values representing the Wigner function calculated over the specified\n        range [xvec,yvec].\n\n\n    \"\"\"\n    N = psi.dims[0][0]\n    x, y = jnp.meshgrid(xvec, yvec)\n    alpha = x + 1.0j * y\n    displacement = jqt.displace(N, alpha)\n\n    vmapped_overlap = [vmap(vmap(jqt.overlap, in_axes=(None, 0)), in_axes=(\n        None, 0))]\n    for _ in psi.bdims:\n        vmapped_overlap.append(vmap(vmapped_overlap[-1], in_axes=(0, None)))\n\n    cf = vmapped_overlap[-1](psi, displacement)\n    return cf\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.coherent","title":"<code>coherent(N, \u03b1)</code>","text":"<p>Coherent state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>\u03b1</code> <code>complex</code> <p>coherent state amplitude.</p> required Return <p>Coherent state |\u03b1\u27e9.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def coherent(N: int, \u03b1: complex) -&gt; Qarray:\n    \"\"\"Coherent state.\n\n    Args:\n        N: Hilbert Space Size.\n        \u03b1: coherent state amplitude.\n\n    Return:\n        Coherent state |\u03b1\u27e9.\n    \"\"\"\n    return displace(N, \u03b1) @ basis(N, 0)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.collapse","title":"<code>collapse(qarr, mode='sum')</code>","text":"<p>Collapse the Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Collapsed quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def collapse(qarr: Qarray, mode=\"sum\") -&gt; Qarray:\n    \"\"\"Collapse the Qarray.\n\n    Args:\n        qarr (Qarray): quantum array array\n\n    Returns:\n        Collapsed quantum array\n    \"\"\"\n    if mode == \"sum\":\n        if len(qarr.bdims) == 0:\n            return qarr\n\n        batch_axes = list(range(len(qarr.bdims)))\n        return Qarray.create(jnp.sum(qarr.data, axis=batch_axes), dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.comb","title":"<code>comb(N, k)</code>","text":"<p>NCk</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.comb--todo-replace-with-jspspecialcomb-once-issue-is-closed","title":"TODO: replace with jsp.special.comb once issue is closed:","text":"<p>https://github.com/google/jax/issues/9709</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>total items</p> required <code>k</code> required <p>Returns:</p> Name Type Description <code>NCk</code> <p>N choose k</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def comb(N, k):\n    \"\"\"\n    NCk\n\n    #TODO: replace with jsp.special.comb once issue is closed:\n    https://github.com/google/jax/issues/9709\n\n    Args:\n        N: total items\n        k: # of items to choose\n\n    Returns:\n        NCk: N choose k\n    \"\"\"\n    one = 1\n    N_plus_1 = lax.add(N, one)\n    k_plus_1 = lax.add(k, one)\n    return lax.exp(\n        lax.sub(\n            gammaln(N_plus_1), lax.add(gammaln(k_plus_1), gammaln(lax.sub(N_plus_1, k)))\n        )\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.comb--of-items-to-choose","title":"of items to choose","text":""},{"location":"reference/jaxquantum/index.html#jaxquantum.concatenate","title":"<code>concatenate(qarr_list, axis=0)</code>","text":"<p>Concatenate a list of Qarrays along a specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_list</code> <code>List[Qarray]</code> <p>List of Qarrays to concatenate.</p> required <code>axis</code> <code>int</code> <p>Axis along which to concatenate. Default is 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Concatenated Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def concatenate(qarr_list: List[Qarray], axis: int = 0) -&gt; Qarray:\n    \"\"\"Concatenate a list of Qarrays along a specified axis.\n\n    Args:\n        qarr_list (List[Qarray]): List of Qarrays to concatenate.\n        axis (int): Axis along which to concatenate. Default is 0.\n\n    Returns:\n        Qarray: Concatenated Qarray.\n    \"\"\"\n\n    non_empty_qarr_list = [qarr for qarr in qarr_list if len(qarr.data) != 0]\n\n    if len(non_empty_qarr_list) == 0:\n        return Qarray.from_list([])\n\n    concatenated_data = jnp.concatenate(\n        [qarr.data for qarr in non_empty_qarr_list], axis=axis\n    )\n\n    dims = non_empty_qarr_list[0].dims\n    return Qarray.create(concatenated_data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.cosm","title":"<code>cosm(qarr)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Matrix cosine wrapper.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    dims = qarr.dims\n    data = cosm_data(qarr.data)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.cosm_data","title":"<code>cosm_data(data, **kwargs)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix cosine wrapper.\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    return (expm_data(1j * data) + expm_data(-1j * data)) / 2\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.dag","title":"<code>dag(qarr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>conjugate transpose of qarr</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        conjugate transpose of qarr\n    \"\"\"\n    dims = qarr.dims[::-1]\n\n    data = dag_data(qarr.data)\n\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.dag_data","title":"<code>dag_data(arr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag_data(arr: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        arr: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    # TODO: revisit this case...\n    if len(arr.shape) == 1:\n        return jnp.conj(arr)\n\n    return jnp.moveaxis(\n        jnp.conj(arr), -1, -2\n    )  # transposes last two axes, good for batching\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.displace","title":"<code>displace(N, \u03b1)</code>","text":"<p>Displacement operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>\u03b1</code> <p>Phase space displacement</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Displace operator D(\u03b1)</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def displace(N, \u03b1) -&gt; Qarray:\n    \"\"\"Displacement operator\n\n    Args:\n        N: Hilbert Space Size\n        \u03b1: Phase space displacement\n\n    Returns:\n        Displace operator D(\u03b1)\n    \"\"\"\n    a = destroy(N)\n    return (\u03b1 * a.dag() - jnp.conj(\u03b1) * a).expm()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.eigenenergies","title":"<code>eigenenergies(qarr)</code>","text":"<p>Eigenvalues of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>eigenvalues</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenenergies(qarr: Qarray) -&gt; Array:\n    \"\"\"Eigenvalues of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues\n    \"\"\"\n\n    evals = jnp.linalg.eigvalsh(qarr.data)\n    return evals\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.eigenstates","title":"<code>eigenstates(qarr)</code>","text":"<p>Eigenstates of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>eigenvalues and eigenstates</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenstates(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Eigenstates of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues and eigenstates\n    \"\"\"\n\n    evals, evecs = jnp.linalg.eigh(qarr.data)\n    idxs_sorted = jnp.argsort(evals, axis=-1)\n\n    dims = ket_from_op_dims(qarr.dims)\n\n    evals = jnp.take_along_axis(evals, idxs_sorted, axis=-1)\n    evecs = jnp.take_along_axis(evecs, idxs_sorted[..., None, :], axis=-1)\n\n    # numpy returns [batch, :, i] as the i-th eigenvector\n    # we want [batch, i, :] as the i-th eigenvector\n    evecs = jnp.swapaxes(evecs, -2, -1)\n\n    evecs = Qarray.create(\n        evecs,\n        dims=dims,\n        bdims=evecs.shape[:-1],\n    )\n\n    return evals, evecs\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.expm","title":"<code>expm(qarr, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm(qarr: Qarray, **kwargs) -&gt; Qarray:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    dims = qarr.dims\n    data = expm_data(qarr.data, **kwargs)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.expm_data","title":"<code>expm_data(data, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    return jsp.linalg.expm(data, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.extract_dims","title":"<code>extract_dims(arr, dims=None)</code>","text":"<p>Extract dims from a JAX array or Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>JAX array or Qarray.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray dims.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def extract_dims(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"Extract dims from a JAX array or Qarray.\n\n    Args:\n        arr: JAX array or Qarray.\n        dims: Qarray dims.\n\n    Returns:\n        Qarray dims.\n    \"\"\"\n    if isinstance(dims[0], Number):\n        is_op = arr.shape[-2] == arr.shape[-1]\n        if is_op:\n            dims = [dims, dims]\n        else:\n            dims = [dims, [1] * len(dims)]  # defaults to ket\n    return dims\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.fidelity","title":"<code>fidelity(rho, sigma, force_positivity=False)</code>","text":"<p>Fidelity between two states.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>Qarray</code> <p>state.</p> required <code>sigma</code> <code>Qarray</code> <p>state.</p> required <code>force_positivity</code> <code>bool</code> <p>force the states to be positive semidefinite</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Fidelity between rho and sigma.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def fidelity(rho: Qarray, sigma: Qarray, force_positivity: bool=False) -&gt; (\n        jnp.ndarray):\n    \"\"\"Fidelity between two states.\n\n    Args:\n        rho: state.\n        sigma: state.\n        force_positivity: force the states to be positive semidefinite\n\n    Returns:\n        Fidelity between rho and sigma.\n    \"\"\"\n    rho = rho.to_dm()\n    sigma = sigma.to_dm()\n\n    sqrt_rho = powm(rho, 0.5, clip_eigvals=force_positivity)\n\n    return jnp.real(((powm(sqrt_rho @ sigma @ sqrt_rho, 0.5,\n                           clip_eigvals=force_positivity)).tr())\n                    ** 2)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.hadamard","title":"<code>hadamard()</code>","text":"<p>H</p> <p>Returns:</p> Name Type Description <code>H</code> <code>Qarray</code> <p>Hadamard gate</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def hadamard() -&gt; Qarray:\n    \"\"\"H\n\n    Returns:\n        H: Hadamard gate\n    \"\"\"\n    return Qarray.create(jnp.array([[1, 1], [1, -1]]) / jnp.sqrt(2))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.hermcompanion","title":"<code>hermcompanion(c)</code>","text":"<p>Return the scaled companion matrix of c.</p> <p>The basis polynomials are scaled so that the companion matrix is symmetric when <code>c</code> is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if <code>jax.numpy.linalg.eigvalsh</code> is used to obtain them.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.hermcompanion--parameters","title":"Parameters","text":"<p>c : array_like     1-D array of Hermite series coefficients ordered from low to high     degree.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.hermcompanion--returns","title":"Returns","text":"<p>mat : ndarray     Scaled companion matrix of dimensions (deg, deg).</p> Source code in <code>jaxquantum/utils/hermgauss.py</code> <pre><code>@jit\ndef hermcompanion(c):\n    \"\"\"Return the scaled companion matrix of c.\n\n    The basis polynomials are scaled so that the companion matrix is\n    symmetric when `c` is an Hermite basis polynomial. This provides\n    better eigenvalue estimates than the unscaled case and for basis\n    polynomials the eigenvalues are guaranteed to be real if\n    `jax.numpy.linalg.eigvalsh` is used to obtain them.\n\n    Parameters\n    ----------\n    c : array_like\n        1-D array of Hermite series coefficients ordered from low to high\n        degree.\n\n    Returns\n    -------\n    mat : ndarray\n        Scaled companion matrix of dimensions (deg, deg).\n\n    \"\"\"\n    c = as_series(c)\n    if len(c) &lt; 2:\n        raise ValueError(\"Series must have maximum degree of at least 1.\")\n    if len(c) == 2:\n        return jnp.array([[-0.5 * c[0] / c[1]]])\n\n    n = len(c) - 1\n    mat = jnp.zeros((n, n), dtype=c.dtype)\n    scl = jnp.hstack((1.0, 1.0 / jnp.sqrt(2.0 * jnp.arange(n - 1, 0, -1))))\n    scl = jnp.cumprod(scl)[::-1]\n    shp = mat.shape\n    mat = mat.flatten()\n    mat = mat.at[1 :: n + 1].set(jnp.sqrt(0.5 * jnp.arange(1, n)))\n    mat = mat.at[n :: n + 1].set(jnp.sqrt(0.5 * jnp.arange(1, n)))\n    mat = mat.reshape(shp)\n    mat = mat.at[:, -1].add(-scl * c[:-1] / (2.0 * c[-1]))\n    return mat\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.identity_like","title":"<code>identity_like(A)</code>","text":"<p>Identity matrix with the same shape as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <p>Matrix.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix with the same shape as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity_like(A) -&gt; Qarray:\n    \"\"\"Identity matrix with the same shape as A.\n\n    Args:\n        A: Matrix.\n\n    Returns:\n        Identity matrix with the same shape as A.\n    \"\"\"\n    space_dims = A.space_dims\n    total_dim = prod(space_dims)\n    return Qarray.create(jnp.eye(total_dim, total_dim), dims=[space_dims, space_dims])\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.inductance_to_inductive_energy","title":"<code>inductance_to_inductive_energy(L)</code>","text":"<p>Convert inductance to inductive energy E_L.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>float</code> <p>Inductance in nH.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Inductive energy in GHz.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inductance_to_inductive_energy(L):\n    \"\"\"Convert inductance to inductive energy E_L.\n\n    Args:\n        L (float): Inductance in nH.\n\n    Returns:\n        float: Inductive energy in GHz.\n    \"\"\"\n\n    inv_L = 1e9 / L\n    El_joules = inv_L * (FLUX_QUANTUM**2) / (2 * np.pi) ** 2\n    return joule_to_GHz(El_joules)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.inductive_energy_to_inductance","title":"<code>inductive_energy_to_inductance(El)</code>","text":"<p>Convert inductive energy E_L to inductance.</p> <p>Parameters:</p> Name Type Description Default <code>El</code> <code>float</code> <p>inductive energy in GHz.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Inductance in nH.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inductive_energy_to_inductance(El):\n    \"\"\"Convert inductive energy E_L to inductance.\n\n    Args:\n        El (float): inductive energy in GHz.\n\n    Returns:\n        float: Inductance in nH.\n    \"\"\"\n\n    inv_L = GHz_to_joule(El) * (2 * np.pi) ** 2 / (FLUX_QUANTUM**2)\n    return 1e9 / inv_L\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.inv_pF_to_Ec","title":"<code>inv_pF_to_Ec(inv_pfarad)</code>","text":"<p>1/picoFarad -&gt; GHz</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inv_pF_to_Ec(inv_pfarad):\n    \"\"\"\n    1/picoFarad -&gt; GHz\n    \"\"\"\n    inv_nFarad = inv_pfarad * 1e3\n    Gjoule = (constants.e) ** 2 / (2) * inv_nFarad\n    return joule_to_GHz(Gjoule * 1e9)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.is_dm_data","title":"<code>is_dm_data(data)</code>","text":"<p>Check if data is a density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:     True if data is a density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def is_dm_data(data: Array) -&gt; bool:\n    \"\"\"Check if data is a density matrix.\n\n    Args:\n        data: matrix\n    Returns:\n        True if data is a density matrix\n    \"\"\"\n    return data.shape[-2] == data.shape[-1]\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.jnp2jqt","title":"<code>jnp2jqt(arr, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnp2jqt(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n        dims: Qarray dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    dims = extract_dims(arr, dims) if dims is not None else None\n    return Qarray.create(arr, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.jqt2qt","title":"<code>jqt2qt(jqt_obj)</code>","text":"<p>Qarray -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jqt_obj</code> <p>Qarray.</p> required <code>dims</code> <p>QuTiP dims.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqt2qt(jqt_obj):\n    \"\"\"Qarray -&gt; QuTiP state.\n\n    Args:\n        jqt_obj: Qarray.\n        dims: QuTiP dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    if isinstance(jqt_obj, Qobj) or jqt_obj is None:\n        return jqt_obj\n\n    if jqt_obj.is_batched:\n        res = []\n        for i in range(len(jqt_obj)):\n            res.append(jqt2qt(jqt_obj[i]))\n        return res\n\n    dims = [list(jqt_obj.dims[0]), list(jqt_obj.dims[1])]\n    return Qobj(np.array(jqt_obj.data), dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.ket2dm","title":"<code>ket2dm(qarr)</code>","text":"<p>Turns ket into density matrix. Does nothing if already operator.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>qarr</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ket2dm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Turns ket into density matrix.\n    Does nothing if already operator.\n\n    Args:\n        qarr (Qarray): qarr\n\n    Returns:\n        Density matrix\n    \"\"\"\n\n    if qarr.qtype == Qtypes.oper:\n        return qarr\n\n    if qarr.qtype == Qtypes.bra:\n        qarr = qarr.dag()\n\n    return qarr @ qarr.dag()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.mesolve","title":"<code>mesolve(H, rho0, tlist, saveat_tlist=None, c_ops=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[Qarray, Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function or time-independent Qarray.</p> required <code>rho0</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>tlist</code> <code>Array</code> <p>time list</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <code>c_ops</code> <code>Optional[Qarray]</code> <p>qarray list of collapse operators</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    rho0: Qarray,\n    tlist: Array,\n    saveat_tlist: Optional[Array] = None,\n    c_ops: Optional[Qarray] = None,\n    solver_options: Optional[SolverOptions] = None,\n) -&gt; Qarray:\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        H: time dependent Hamiltonian function or time-independent Qarray.\n        rho0: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        tlist: time list\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n        c_ops: qarray list of collapse operators\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    saveat_tlist = saveat_tlist if saveat_tlist is not None else tlist\n\n    saveat_tlist = jnp.atleast_1d(saveat_tlist)\n\n    c_ops = c_ops if c_ops is not None else Qarray.from_list([])\n\n    # if isinstance(H, Qarray):\n\n    if len(c_ops) == 0 and rho0.qtype != Qtypes.oper:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = rho0.to_dm()\n    dims = \u03c10.dims\n    \u03c10 = \u03c10.data\n\n    c_ops = c_ops.data\n\n    if isinstance(H, Qarray):\n        Ht_data = lambda t: H.data\n    else:\n        Ht_data = lambda t: H(t).data\n\n    ys = _mesolve_data(Ht_data, \u03c10, tlist, saveat_tlist, c_ops,\n                       solver_options=solver_options)\n\n    return jnp2jqt(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.multi_mode_basis_set","title":"<code>multi_mode_basis_set(Ns)</code>","text":"<p>Creates a multi-mode basis set.</p> <p>Parameters:</p> Name Type Description Default <code>Ns</code> <code>List[int]</code> <p>List of Hilbert space dimensions for each mode.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Multi-mode basis set.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def multi_mode_basis_set(Ns: List[int]) -&gt; Qarray:\n    \"\"\"Creates a multi-mode basis set.\n\n    Args:\n        Ns: List of Hilbert space dimensions for each mode.\n\n    Returns:\n        Multi-mode basis set.\n    \"\"\"\n    data = jnp.eye(prod(Ns))\n    dims = (tuple(Ns), tuple([1 for _ in Ns]))\n    return Qarray.create(data, dims=dims, bdims=(prod(Ns),))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.n_thermal","title":"<code>n_thermal(frequency, temperature)</code>","text":"<p>Calculate the average thermal photon number for a given frequency and temperature.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Frequency in GHz.</p> required <code>temperature</code> <code>float</code> <p>Temperature in Kelvin.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Average thermal photon number.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def n_thermal(frequency: float, temperature: float) -&gt; float:\n    \"\"\"Calculate the average thermal photon number for a given frequency and temperature.\n\n    Args:\n        frequency (float): Frequency in GHz.\n        temperature (float): Temperature in Kelvin.\n\n    Returns:\n        float: Average thermal photon number.\n    \"\"\"\n    k_B = constants.k  # Boltzmann constant in J/K\n    h = constants.h  # Planck constant in J\u00b7s\n\n    exponent = h * (frequency * 1e9) / (k_B * temperature)\n    n_avg = 1 / (np.exp(exponent) - 1)\n    return n_avg\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.num","title":"<code>num(N)</code>","text":"<p>Number operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>number operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def num(N) -&gt; Qarray:\n    \"\"\"Number operator\n\n    Args:\n        N: Hilbert Space size\n\n    Returns:\n        number operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.arange(N)))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.overlap","title":"<code>overlap(rho, sigma)</code>","text":"<p>Overlap between two states or operators.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>Qarray</code> <p>state/operator.</p> required <code>sigma</code> <code>Qarray</code> <p>state/operator.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Overlap between rho and sigma.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def overlap(rho: Qarray, sigma: Qarray) -&gt; Array:\n    \"\"\"Overlap between two states or operators.\n\n    Args:\n        rho: state/operator.\n        sigma: state/operator.\n\n    Returns:\n        Overlap between rho and sigma.\n    \"\"\"\n\n    if rho.is_vec() and sigma.is_vec():\n        return jnp.abs(((rho.to_ket().dag() @ sigma.to_ket()).trace())) ** 2\n    elif rho.is_vec():\n        rho = rho.to_ket()\n        res = (rho.dag() @ sigma @ rho).data\n        return res.squeeze(-1).squeeze(-1)\n    elif sigma.is_vec():\n        sigma = sigma.to_ket()\n        res = (sigma.dag() @ rho @ sigma).data\n        return res.squeeze(-1).squeeze(-1)\n    else:\n        return (rho.dag() @ sigma).trace()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.plot_cf","title":"<code>plot_cf(state, pts_x, pts_y=None, axs=None, contour=True, qp_type=WIGNER, cbar_label='', axis_scale_factor=1, plot_cbar=True, plot_grid=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot characteristic function.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\")</p> <code>WIGNER</code> <code>cbar_label</code> <p>labels for the real and imaginary cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_cf(\n        state,\n        pts_x,\n        pts_y=None,\n        axs=None,\n        contour=True,\n        qp_type=WIGNER,\n        cbar_label=\"\",\n        axis_scale_factor=1,\n        plot_cbar=True,\n        plot_grid=True,\n        x_ticks=None,\n        y_ticks=None,\n        z_ticks=None,\n        subtitles=None,\n        figtitle=None,\n):\n    \"\"\"Plot characteristic function.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\")\n        cbar_label: labels for the real and imaginary cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    if pts_y is None:\n        pts_y = pts_x\n    pts_x = jnp.array(pts_x)\n    pts_y = jnp.array(pts_y)\n\n    bdims = state.bdims\n    added_baxes = 0\n\n    if subtitles is not None:\n        if subtitles.shape != bdims:\n            raise ValueError(\n                f\"labels must have same shape as bdims, \"\n                f\"got shapes {subtitles.shape} and {bdims}\"\n            )\n\n    if len(bdims) == 0:\n        bdims = (1,)\n        added_baxes += 1\n    if len(bdims) == 1:\n        bdims = (1, bdims[0])\n        added_baxes += 1\n\n    extra_dims = bdims[2:]\n    if extra_dims != ():\n        state = state.reshape_bdims(\n            bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n        )\n        if subtitles is not None:\n            subtitles = subtitles.reshape(\n                bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n            )\n        bdims = state.bdims\n\n    if axs is None:\n        _, axs = plt.subplots(\n            bdims[0],\n            bdims[1]*2,\n            figsize=(4 * bdims[1]*2, 3 * bdims[0]),\n            dpi=200,\n        )\n\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = 1\n        cmap = \"seismic\"\n        cbar_label = [r\"$\\mathcal{Re}(\\chi_W(\\alpha))$\", r\"$\\mathcal{\"\n                                                         r\"Im}(\\chi_W(\"\n                                                         r\"\\alpha))$\"]\n        QP = scale * cf_wigner(state, pts_x, pts_y)\n\n    for _ in range(added_baxes):\n        QP = jnp.array([QP])\n        axs = np.array([axs])\n        if subtitles is not None:\n            subtitles = np.array([subtitles])\n\n    if added_baxes==2:\n        axs = axs[0] # When the input state is zero-dimensional, remove an\n                     # axis that is automatically added due to the subcolumns\n\n\n    pts_x = pts_x * axis_scale_factor\n    pts_y = pts_y * axis_scale_factor\n\n    x_ticks = (\n        jnp.linspace(jnp.min(pts_x), jnp.max(pts_x),\n                     5) if x_ticks is None else x_ticks\n    )\n    y_ticks = (\n        jnp.linspace(jnp.min(pts_y), jnp.max(pts_y),\n                     5) if y_ticks is None else y_ticks\n    )\n    z_ticks = jnp.linspace(vmin, vmax, 11) if z_ticks is None else z_ticks\n    print(axs.shape)\n    for row in range(bdims[0]):\n        for col in range(bdims[1]):\n            for subcol in range(2):\n                ax = axs[row, 2 * col + subcol]\n                if contour:\n                    im = ax.contourf(\n                        pts_x,\n                        pts_y,\n                        jnp.real(QP[row, col]) if subcol==0 else jnp.imag(QP[\n                                                                           row, col]),\n                        cmap=cmap,\n                        vmin=vmin,\n                        vmax=vmax,\n                        levels=np.linspace(vmin, vmax, 101),\n                    )\n                else:\n                    im = ax.pcolormesh(\n                        pts_x,\n                        pts_y,\n                        jnp.real(QP[row, col]) if subcol == 0 else jnp.imag(QP[\n                                                                                row, col]),\n                        cmap=cmap,\n                        vmin=vmin,\n                        vmax=vmax,\n                    )\n                ax.set_xticks(x_ticks)\n                ax.set_yticks(y_ticks)\n                # ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n                # ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n\n                if plot_grid:\n                    ax.grid()\n\n                ax.set_aspect(\"equal\", adjustable=\"box\")\n\n                if plot_cbar:\n                    cbar = plt.colorbar(\n                        im, ax=ax, orientation=\"vertical\",\n                        ticks=np.linspace(-1, 1, 11)\n                    )\n                    cbar.ax.set_title(cbar_label[subcol])\n                    cbar.set_ticks(z_ticks)\n\n                ax.set_xlabel(r\"Re[$\\alpha$]\")\n                ax.set_ylabel(r\"Im[$\\alpha$]\")\n                if subtitles is not None:\n                    ax.set_title(subtitles[row, col])\n\n    fig = ax.get_figure()\n    fig.tight_layout()\n    if figtitle is not None:\n        fig.suptitle(figtitle, y=1.04)\n    return axs, im\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.plot_cf_wigner","title":"<code>plot_cf_wigner(state, pts_x, pts_y=None, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, plot_grid=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the Wigner characteristic function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_cf_wigner(\n    state,\n    pts_x,\n    pts_y=None,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    plot_grid=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the Wigner characteristic function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_cf(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        axs=axs,\n        contour=contour,\n        qp_type=WIGNER,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        plot_grid=plot_grid,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.plot_qfunc","title":"<code>plot_qfunc(state, pts_x, pts_y=None, g=2, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the husimi function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qfunc(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the husimi function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_qp(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        g=g,\n        axs=axs,\n        contour=contour,\n        qp_type=HUSIMI,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.plot_qp","title":"<code>plot_qp(state, pts_x, pts_y=None, g=2, axs=None, contour=True, qp_type=WIGNER, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot quasi-probability distribution.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\", \"qfunc\")</p> <code>WIGNER</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qp(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    qp_type=WIGNER,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot quasi-probability distribution.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\", \"qfunc\")\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    if pts_y is None:\n        pts_y = pts_x\n    pts_x = jnp.array(pts_x)\n    pts_y = jnp.array(pts_y)\n\n    if len(state.bdims)==1 and state.bdims[0]==1:\n        state = state[0]\n\n\n    bdims = state.bdims\n    added_baxes = 0\n\n    if subtitles is not None:\n        if subtitles.shape != bdims:\n            raise ValueError(\n                f\"labels must have same shape as bdims, \"\n                f\"got shapes {subtitles.shape} and {bdims}\"\n            )\n\n    if len(bdims) == 0:\n        bdims = (1,)\n        added_baxes += 1\n    if len(bdims) == 1:\n        bdims = (1, bdims[0])\n        added_baxes += 1\n\n    extra_dims = bdims[2:]\n    if extra_dims != ():\n        state = state.reshape_bdims(\n            bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n        )\n        if subtitles is not None:\n            subtitles = subtitles.reshape(\n                bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n            )\n        bdims = state.bdims\n\n    if axs is None:\n        _, axs = plt.subplots(\n            bdims[0],\n            bdims[1],\n            figsize=(4 * bdims[1], 3 * bdims[0]),\n            dpi=200,\n        )\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = np.pi / 2\n        cmap = \"seismic\"\n        cbar_label = r\"$\\mathcal{W}(\\alpha)$\"\n        QP = scale * wigner(state, pts_x, pts_y, g=g)\n\n    elif qp_type == HUSIMI:\n        vmin = 0\n        vmax = 1\n        scale = np.pi\n        cmap = \"jet\"\n        cbar_label = r\"$\\mathcal{Q}(\\alpha)$\"\n        QP = scale * qfunc(state, pts_x, pts_y, g=g)\n\n\n\n    for _ in range(added_baxes):\n        QP = jnp.array([QP])\n        axs = np.array([axs])\n        if subtitles is not None:\n            subtitles = np.array([subtitles])\n\n\n\n\n    pts_x = pts_x * axis_scale_factor\n    pts_y = pts_y * axis_scale_factor\n\n    x_ticks = (\n        jnp.linspace(jnp.min(pts_x), jnp.max(pts_x), 5) if x_ticks is None else x_ticks\n    )\n    y_ticks = (\n        jnp.linspace(jnp.min(pts_y), jnp.max(pts_y), 5) if y_ticks is None else y_ticks\n    )\n    z_ticks = jnp.linspace(vmin, vmax, 3) if z_ticks is None else z_ticks\n\n    for row in range(bdims[0]):\n        for col in range(bdims[1]):\n            ax = axs[row, col]\n            if contour:\n                im = ax.contourf(\n                    pts_x,\n                    pts_y,\n                    QP[row, col],\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    levels=np.linspace(vmin, vmax, 101),\n                )\n            else:\n                im = ax.pcolormesh(\n                    pts_x,\n                    pts_y,\n                    QP[row, col],\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                )\n            ax.set_xticks(x_ticks)\n            ax.set_yticks(y_ticks)\n            ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n            ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n            ax.grid()\n            ax.set_aspect(\"equal\", adjustable=\"box\")\n\n            if plot_cbar:\n                cbar = plt.colorbar(\n                    im, ax=ax, orientation=\"vertical\", ticks=np.linspace(-1, 1, 11)\n                )\n                cbar.ax.set_title(cbar_label)\n                cbar.set_ticks(z_ticks)\n\n            ax.set_xlabel(r\"Re[$\\alpha$]\")\n            ax.set_ylabel(r\"Im[$\\alpha$]\")\n            if subtitles is not None:\n                ax.set_title(subtitles[row, col])\n\n    fig = ax.get_figure()\n    fig.tight_layout()\n    if figtitle is not None:\n        fig.suptitle(figtitle, y=1.04)\n    return axs, im\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.plot_wigner","title":"<code>plot_wigner(state, pts_x, pts_y=None, g=2, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the wigner function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_wigner(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the wigner function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_qp(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        g=g,\n        axs=axs,\n        contour=contour,\n        qp_type=WIGNER,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.powm","title":"<code>powm(qarr, n, clip_eigvals=False)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>n</code> <code>int</code> <p>power</p> required <code>clip_eigvals</code> <code>bool</code> <p>clip eigenvalues to always be able to compute</p> <code>False</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm(qarr: Qarray, n: Union[int, float], clip_eigvals=False) -&gt; Qarray:\n    \"\"\"Matrix power.\n\n    Args:\n        qarr (Qarray): quantum array\n        n (int): power\n        clip_eigvals (bool): clip eigenvalues to always be able to compute\n        non-integer powers\n\n    Returns:\n        matrix power\n    \"\"\"\n    if isinstance(n, int):\n        data_res = jnp.linalg.matrix_power(qarr.data, n)\n    else:\n        evalues, evectors = jnp.linalg.eig(qarr.data)\n        if clip_eigvals:\n            evalues = jnp.maximum(evalues, 0)\n        else:\n            if not (evalues &gt;= 0).all():\n                raise ValueError(\n                    \"Non-integer power of a matrix can only be \"\n                    \"computed if the matrix is positive semi-definite.\"\n                    \"Got a matrix with a negative eigenvalue.\"\n                )\n        data_res = evectors * jnp.pow(evalues, n) @ jnp.linalg.inv(evectors)\n    return Qarray.create(data_res, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.powm_data","title":"<code>powm_data(data, n)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <code>n</code> <code>int</code> <p>power</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm_data(data: Array, n: int) -&gt; Array:\n    \"\"\"Matrix power.\n\n    Args:\n        data: matrix\n        n: power\n\n    Returns:\n        matrix power\n    \"\"\"\n    return jnp.linalg.matrix_power(data, n)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.propagator","title":"<code>propagator(H, ts, saveat_tlist=None, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Qarray or callable</code> <p>A Qarray static Hamiltonian OR a function that takes a time argument and returns a Hamiltonian.</p> required <code>ts</code> <code>float or Array</code> <p>A single time point or an Array of time points.</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray or List[Qarray]: The propagator for the Hamiltonian at time t. OR a list of propagators for the Hamiltonian at each time in t.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    ts: Union[float, Array],\n    saveat_tlist: Optional[Array] = None,\n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian.\n\n    Args:\n        H (Qarray or callable):\n            A Qarray static Hamiltonian OR\n            a function that takes a time argument and returns a Hamiltonian.\n        ts (float or Array):\n            A single time point or\n            an Array of time points.\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n\n    Returns:\n        Qarray or List[Qarray]:\n            The propagator for the Hamiltonian at time t.\n            OR a list of propagators for the Hamiltonian at each time in t.\n\n    \"\"\"\n\n\n    ts_is_scalar = robust_isscalar(ts)\n    H_is_qarray = isinstance(H, Qarray)\n\n    if H_is_qarray:\n        return (-1j * H * ts).expm()\n    else:\n\n        if ts_is_scalar:\n            H_first = H(0.0)\n            if ts == 0:\n                return identity_like(H_first)\n            ts = jnp.array([0.0, ts])\n        else:\n            H_first = H(ts[0])\n\n        basis_states = multi_mode_basis_set(H_first.space_dims)\n        results = sesolve(H, basis_states, ts, saveat_tlist=saveat_tlist)\n        propagators_data = results.data.squeeze(-1).mT\n        propagators = Qarray.create(propagators_data, dims=H_first.space_dims)\n\n        return propagators\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.ptrace","title":"<code>ptrace(qarr, indx)</code>","text":"<p>Partial Trace.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <p>density matrix</p> required <code>indx</code> <p>index of quantum object to keep, rest will be partial traced out</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>partial traced out density matrix</p> <p>TODO: Fix weird tracing errors that arise with reshape</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ptrace(qarr: Qarray, indx) -&gt; Qarray:\n    \"\"\"Partial Trace.\n\n    Args:\n        rho: density matrix\n        indx: index of quantum object to keep, rest will be partial traced out\n\n    Returns:\n        partial traced out density matrix\n\n    TODO: Fix weird tracing errors that arise with reshape\n    \"\"\"\n\n    qarr = ket2dm(qarr)\n    rho = qarr.shaped_data\n    dims = qarr.dims\n\n    Nq = len(dims[0])\n\n    indxs = [indx, indx + Nq]\n    for j in range(Nq):\n        if j == indx:\n            continue\n        indxs.append(j)\n        indxs.append(j + Nq)\n\n    bdims = qarr.bdims\n    len_bdims = len(bdims)\n    bdims_indxs = list(range(len_bdims))\n    indxs = bdims_indxs + [j + len_bdims for j in indxs]\n    rho = rho.transpose(indxs)\n\n    for j in range(Nq - 1):\n        rho = jnp.trace(rho, axis1=2 + len_bdims, axis2=3 + len_bdims)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.qfunc","title":"<code>qfunc(psi, xvec, yvec, g=2)</code>","text":"<p>Husimi-Q function of a given state vector or density matrix at phase-space points <code>0.5 * g * (xvec + i*yvec)</code>.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.qfunc--parameters","title":"Parameters","text":"<p>state : Qarray     A state vector or density matrix. This cannot have tensor-product     structure.</p> <p>xvec, yvec : array_like     x- and y-coordinates at which to calculate the Husimi-Q function.</p> float, default: 2 <p>Scaling factor for <code>a = 0.5 * g * (x + iy)</code>.  The value of <code>g</code> is related to the value of :math:<code>\\hbar</code> in the commutation relation :math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.qfunc--returns","title":"Returns","text":"<p>jnp.ndarray     Values representing the Husimi-Q function calculated over the specified     range <code>[xvec, yvec]</code>.</p> Source code in <code>jaxquantum/core/qp_distributions.py</code> <pre><code>def qfunc(psi, xvec, yvec, g=2):\n    r\"\"\"\n    Husimi-Q function of a given state vector or density matrix at phase-space\n    points ``0.5 * g * (xvec + i*yvec)``.\n\n    Parameters\n    ----------\n    state : Qarray\n        A state vector or density matrix. This cannot have tensor-product\n        structure.\n\n    xvec, yvec : array_like\n        x- and y-coordinates at which to calculate the Husimi-Q function.\n\n    g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\hbar` via :math:`\\hbar=2/g^2`.\n\n    Returns\n    -------\n    jnp.ndarray\n        Values representing the Husimi-Q function calculated over the specified\n        range ``[xvec, yvec]``.\n\n    \"\"\"\n\n    alpha_grid, prefactor = _qfunc_coherent_grid(xvec, yvec, g)\n\n    if psi.is_vec():\n        psi = psi.to_ket()\n\n        def _compute_qfunc(psi, alpha_grid, prefactor, g):\n            out = _qfunc_iterative_single(psi, alpha_grid, prefactor, g)\n            out /= jnp.pi\n            return out\n    else:\n\n        def _compute_qfunc(psi, alpha_grid, prefactor, g):\n            values, vectors = jnp.linalg.eigh(psi)\n            vectors = vectors.T\n            out = values[0] * _qfunc_iterative_single(\n                vectors[0], alpha_grid, prefactor, g\n            )\n            for value, vector in zip(values[1:], vectors[1:]):\n                out += value * _qfunc_iterative_single(vector, alpha_grid, prefactor, g)\n            out /= jnp.pi\n\n            return out\n\n    psi = psi.data\n\n    vmapped_compute_qfunc = [_compute_qfunc]\n\n    for _ in psi.shape[:-2]:\n        vmapped_compute_qfunc.append(\n            vmap(\n                vmapped_compute_qfunc[-1],\n                in_axes=(0, None, None, None),\n                out_axes=0,\n            )\n        )\n    return vmapped_compute_qfunc[-1](psi, alpha_grid, prefactor, g)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.qt2jqt","title":"<code>qt2jqt(qt_obj, dtype=jnp.complex128)</code>","text":"<p>QuTiP state -&gt; Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <code>dtype</code> <p>JAX dtype.</p> <code>complex128</code> <p>Returns:</p> Type Description <p>Qarray.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def qt2jqt(qt_obj, dtype=jnp.complex128):\n    \"\"\"QuTiP state -&gt; Qarray.\n\n    Args:\n        qt_obj: QuTiP state.\n        dtype: JAX dtype.\n\n    Returns:\n        Qarray.\n    \"\"\"\n    if isinstance(qt_obj, Qarray) or qt_obj is None:\n        return qt_obj\n    return Qarray.create(jnp.array(qt_obj.full(), dtype=dtype), dims=qt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.qubit_rotation","title":"<code>qubit_rotation(theta, nx, ny, nz)</code>","text":"<p>Single qubit rotation.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>rotation angle.</p> required <code>nx</code> <p>rotation axis x component.</p> required <code>ny</code> <p>rotation axis y component.</p> required <code>nz</code> <p>rotation axis z component.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Single qubit rotation operator.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def qubit_rotation(theta: float, nx, ny, nz) -&gt; Qarray:\n    \"\"\"Single qubit rotation.\n\n    Args:\n        theta: rotation angle.\n        nx: rotation axis x component.\n        ny: rotation axis y component.\n        nz: rotation axis z component.\n\n    Returns:\n        Single qubit rotation operator.\n    \"\"\"\n    return jnp.cos(theta / 2) * identity(2) - 1j * jnp.sin(theta / 2) * (\n        nx * sigmax() + ny * sigmay() + nz * sigmaz()\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sesolve","title":"<code>sesolve(H, rho0, tlist, saveat_tlist=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[Qarray, Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function or time-independent Qarray.</p> required <code>rho0</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>tlist</code> <code>Array</code> <p>time list</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    rho0: Qarray,\n    tlist: Array,\n    saveat_tlist: Optional[Array] = None,\n    solver_options: Optional[SolverOptions] = None,\n) -&gt; Qarray:\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        H: time dependent Hamiltonian function or time-independent Qarray.\n        rho0: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        tlist: time list\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    saveat_tlist = saveat_tlist if saveat_tlist is not None else tlist\n\n    saveat_tlist = jnp.atleast_1d(saveat_tlist)\n\n    \u03c8 = rho0\n\n    if \u03c8.qtype == Qtypes.oper:\n        raise ValueError(\n            \"Please use `jqt.mesolve` for initial state inputs in density matrix form.\"\n        )\n\n    \u03c8 = \u03c8.to_ket()\n    dims = \u03c8.dims\n    \u03c8 = \u03c8.data\n\n    if isinstance(H, Qarray):\n        Ht_data = lambda t: H.data\n    else:\n        Ht_data = lambda t: H(t).data\n\n    ys = _sesolve_data(Ht_data, \u03c8, tlist, saveat_tlist,\n                       solver_options=solver_options)\n\n    return jnp2jqt(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.set_precision","title":"<code>set_precision(precision)</code>","text":"<p>Set the precision of JAX operations.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>Literal['single', 'double']</code> <p>'single' or 'double'</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if precision is not 'single' or 'double'</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def set_precision(precision: Literal[\"single\", \"double\"]):\n    \"\"\"\n    Set the precision of JAX operations.\n\n    Args:\n        precision: 'single' or 'double'\n\n    Raises:\n        ValueError: if precision is not 'single' or 'double'\n    \"\"\"\n    if precision == \"single\":\n        config.update(\"jax_enable_x64\", False)\n    elif precision == \"double\":\n        config.update(\"jax_enable_x64\", True)\n    else:\n        raise ValueError(\"precision must be 'single' or 'double'\")\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmam","title":"<code>sigmam()</code>","text":"<p>\u03c3-</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3- Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmam() -&gt; Qarray:\n    \"\"\"\u03c3-\n\n    Returns:\n        \u03c3- Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 0.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmap","title":"<code>sigmap()</code>","text":"<p>\u03c3+</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3+ Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmap() -&gt; Qarray:\n    \"\"\"\u03c3+\n\n    Returns:\n        \u03c3+ Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [0.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sinm_data","title":"<code>sinm_data(data, **kwargs)</code>","text":"<p>Matrix sine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix sine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def sinm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix sine wrapper.\n\n    Args:\n        data: matrix\n\n    Returns:\n        matrix sine\n    \"\"\"\n    return (expm_data(1j * data) - expm_data(-1j * data)) / (2j)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.solve","title":"<code>solve(f, \u03c10, tlist, saveat_tlist, args, solver_options=None)</code>","text":"<p>Gets teh desired solver from diffrax.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>function defining the ODE</p> required <code>\u03c10</code> <p>initial state</p> required <code>tlist</code> <p>time list</p> required <code>saveat_tlist</code> <p>list of times at which to save the state pass in [-1] to save only at final time</p> required <code>args</code> <p>additional arguments to f</p> required <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>dictionary with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>solution</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def solve(f, \u03c10, tlist, saveat_tlist, args, solver_options: Optional[\n    SolverOptions] = None):\n    \"\"\"Gets teh desired solver from diffrax.\n\n    Args:\n        f: function defining the ODE\n        \u03c10: initial state\n        tlist: time list\n        saveat_tlist: list of times at which to save the state\n            pass in [-1] to save only at final time\n        args: additional arguments to f\n        solver_options: dictionary with solver options\n\n    Returns:\n        solution\n    \"\"\"\n\n    # f and ts\n    term = ODETerm(f)\n\n    if saveat_tlist.shape[0] == 1 and saveat_tlist == -1:\n        saveat = SaveAt(t1=True)\n    else:\n        saveat = SaveAt(ts=saveat_tlist)\n\n    # solver\n    solver_options = solver_options or SolverOptions.create()\n\n    solver_name = solver_options.solver\n    solver = getattr(diffrax, solver_name)()\n    stepsize_controller = PIDController(rtol=solver_options.rtol, atol=solver_options.atol)\n\n    # solve!\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\",\n                                message=\"Complex dtype support in Diffrax\",\n                                category=UserWarning)  # NOTE: suppresses complex dtype warning in diffrax\n        sol = diffeqsolve(\n            term,\n            solver,\n            t0=tlist[0],\n            t1=tlist[-1],\n            dt0=tlist[1] - tlist[0],\n            y0=\u03c10,\n            saveat=saveat,\n            stepsize_controller=stepsize_controller,\n            args=args,\n            max_steps=solver_options.max_steps,\n            progress_meter=CustomProgressMeter()\n            if solver_options.progress_meter\n            else NoProgressMeter(),\n        )\n\n    return sol\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.squeeze","title":"<code>squeeze(N, z)</code>","text":"<p>Single-mode Squeezing operator.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>z</code> <p>squeezing parameter</p> required <p>Returns:</p> Type Description <p>Sqeezing operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def squeeze(N, z):\n    \"\"\"Single-mode Squeezing operator.\n\n\n    Args:\n        N: Hilbert Space Size\n        z: squeezing parameter\n\n    Returns:\n        Sqeezing operator\n    \"\"\"\n\n    a = destroy(N)\n    op = (1 / 2.0) * jnp.conj(z) * (a @ a) - (1 / 2.0) * z * (a.dag() @ a.dag())\n    return op.expm()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <code>parallel</code> <code>bool</code> <p>if True, use parallel einsum for tensor product true: [A,B] ^ [C,D] = [A^C, B^D] false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n        parallel (bool): if True, use parallel einsum for tensor product\n            true: [A,B] ^ [C,D] = [A^C, B^D]\n            false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n\n    parallel = kwargs.pop(\"parallel\", False)\n\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    dims_0 = dims[0]\n    dims_1 = dims[1]\n    for arg in args[1:]:\n        if parallel:\n            a = data\n            b = arg.data\n\n            if len(a.shape) &gt; len(b.shape):\n                batch_dim = a.shape[:-2]\n            elif len(a.shape) == len(b.shape):\n                if prod(a.shape[:-2]) &gt; prod(b.shape[:-2]):\n                    batch_dim = a.shape[:-2]\n                else:\n                    batch_dim = b.shape[:-2]\n            else:\n                batch_dim = b.shape[:-2]\n\n            data = jnp.einsum(\"...ij,...kl-&gt;...ikjl\", a, b).reshape(\n                *batch_dim, a.shape[-2] * b.shape[-2], -1\n            )\n        else:\n            data = jnp.kron(data, arg.data, **kwargs)\n\n        dims_0 = dims_0 + arg.dims[0]\n        dims_1 = dims_1 + arg.dims[1]\n\n    return Qarray.create(data, dims=(dims_0, dims_1))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.tensor_basis","title":"<code>tensor_basis(single_basis, n)</code>","text":"<p>Construct n-fold tensor product basis from a single-system basis.</p> <p>Parameters:</p> Name Type Description Default <code>single_basis</code> <code>Qarray</code> <p>The single-system operator basis as a Qarray.</p> required <code>n</code> <code>int</code> <p>Number of tensor copies to construct.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Qarray containing the n-fold tensor product basis operators.</p> <code>Qarray</code> <p>The resulting basis has b^n elements where b is the number</p> <code>Qarray</code> <p>of operators in the single-system basis.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def tensor_basis(single_basis: Qarray, n: int) -&gt; Qarray:\n    \"\"\"Construct n-fold tensor product basis from a single-system basis.\n\n    Args:\n        single_basis: The single-system operator basis as a Qarray.\n        n: Number of tensor copies to construct.\n\n    Returns:\n        Qarray containing the n-fold tensor product basis operators.\n        The resulting basis has b^n elements where b is the number\n        of operators in the single-system basis.\n    \"\"\"\n\n    dims = single_basis.dims\n\n    single_basis = single_basis.data\n    b, d, _ = single_basis.shape\n    indices = jnp.stack(jnp.meshgrid(*[jnp.arange(b)] * n, indexing=\"ij\"),\n                        axis=-1).reshape(-1, n)  # shape (b^n, n)\n\n    # Select the operators based on indices: shape (b^n, n, d, d)\n    selected = single_basis[indices]  # shape: (b^n, n, d, d)\n\n    # Vectorized Kronecker products\n    full_basis = vmap(lambda ops: reduce(jnp.kron, ops))(selected)\n\n    new_dims = tuple(tuple(x**n for x in row) for row in dims)\n\n    return Qarray.create(full_basis, dims=new_dims, bdims=(b**n,))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.thermal_dm","title":"<code>thermal_dm(N, n)</code>","text":"<p>Thermal state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>n</code> <code>float</code> <p>average photon number.</p> required Return <p>Thermal state.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def thermal_dm(N: int, n: float) -&gt; Qarray:\n    \"\"\"Thermal state.\n\n    Args:\n        N: Hilbert Space Size.\n        n: average photon number.\n\n    Return:\n        Thermal state.\n    \"\"\"\n\n    beta = jnp.log(1 + 1 / n)\n\n    return Qarray.create(\n        jnp.where(\n            jnp.isposinf(beta),\n            basis(N, 0).to_dm().data,\n            jnp.diag(jnp.exp(-beta * jnp.linspace(0, N - 1, N))),\n        )\n    ).unit()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.tr","title":"<code>tr(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tr(qarr: Qarray, **kwargs) -&gt; Array:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Full trace.\n    \"\"\"\n    axis1 = kwargs.get(\"axis1\", -2)\n    axis2 = kwargs.get(\"axis2\", -1)\n    return jnp.trace(qarr.data, axis1=axis1, axis2=axis2, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.trace","title":"<code>trace(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def trace(qarr: Qarray, **kwargs) -&gt; Array:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Full trace.\n    \"\"\"\n    return tr(qarr, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.transpose","title":"<code>transpose(qarr, indices)</code>","text":"<p>Transpose the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>*args</code> <p>axes to transpose</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>tranposed Qarray</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def transpose(qarr: Qarray, indices: List[int]) -&gt; Qarray:\n    \"\"\"Transpose the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n        *args: axes to transpose\n\n    Returns:\n        tranposed Qarray\n    \"\"\"\n\n    indices = list(indices)\n\n    shaped_data = qarr.shaped_data\n    dims = qarr.dims\n    bdims_indxs = list(range(len(qarr.bdims)))\n\n    reshape_indices = indices + [j + len(dims[0]) for j in indices]\n\n    reshape_indices = bdims_indxs + [j + len(bdims_indxs) for j in reshape_indices]\n\n    shaped_data = shaped_data.transpose(reshape_indices)\n    new_dims = (\n        tuple([dims[0][j] for j in indices]),\n        tuple([dims[1][j] for j in indices]),\n    )\n\n    full_dims = prod(dims[0])\n    full_data = shaped_data.reshape(*qarr.bdims, full_dims, -1)\n    return Qarray.create(full_data, dims=new_dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.unit","title":"<code>unit(qarr)</code>","text":"<p>Normalize the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Normalized quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def unit(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Normalize the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Normalized quantum array\n    \"\"\"\n    return qarr / qarr.norm()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.wigner","title":"<code>wigner(psi, xvec, yvec, method='clenshaw', g=2)</code>","text":"<p>Wigner function for a state vector or density matrix at points <code>xvec + i * yvec</code>.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.wigner--parameters","title":"Parameters","text":"Qarray <p>A state vector or density matrix.</p> array_like <p>x-coordinates at which to calculate the Wigner function.</p> array_like <p>y-coordinates at which to calculate the Wigner function.</p> float, default: 2 <p>Scaling factor for <code>a = 0.5 * g * (x + iy)</code>, default <code>g = 2</code>. The value of <code>g</code> is related to the value of <code>hbar</code> in the commutation relation <code>[x, y] = i * hbar</code> via <code>hbar=2/g^2</code>.</p> string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw' <p>Only 'clenshaw' is currently supported. Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' and 'iterative' use an iterative method to evaluate the Wigner functions for density matrices :math:<code>|m&gt;&lt;n|</code>, while 'laguerre' uses the Laguerre polynomials in scipy for the same task. The 'fft' method evaluates the Fourier transform of the density matrix. The 'iterative' method is default, and in general recommended, but the 'laguerre' method is more efficient for very sparse density matrices (e.g., superpositions of Fock states in a large Hilbert space). The 'clenshaw' method is the preferred method for dealing with density matrices that have a large number of excitations (&gt;~50). 'clenshaw' is a fast and numerically stable method.</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.wigner--returns","title":"Returns","text":"array <p>Values representing the Wigner function calculated over the specified range [xvec,yvec].</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.wigner--references","title":"References","text":"<p>Ulf Leonhardt, Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p> Source code in <code>jaxquantum/core/qp_distributions.py</code> <pre><code>def wigner(psi, xvec, yvec, method=\"clenshaw\", g=2):\n    \"\"\"Wigner function for a state vector or density matrix at points\n    `xvec + i * yvec`.\n\n    Parameters\n    ----------\n\n    state : Qarray\n        A state vector or density matrix.\n\n    xvec : array_like\n        x-coordinates at which to calculate the Wigner function.\n\n    yvec : array_like\n        y-coordinates at which to calculate the Wigner function.\n\n    g : float, default: 2\n        Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = 2`.\n        The value of `g` is related to the value of `hbar` in the commutation\n        relation `[x, y] = i * hbar` via `hbar=2/g^2`.\n\n    method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw'\n        Only 'clenshaw' is currently supported.\n        Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'\n        and 'iterative' use an iterative method to evaluate the Wigner functions for density\n        matrices :math:`|m&gt;&lt;n|`, while 'laguerre' uses the Laguerre polynomials\n        in scipy for the same task. The 'fft' method evaluates the Fourier\n        transform of the density matrix. The 'iterative' method is default, and\n        in general recommended, but the 'laguerre' method is more efficient for\n        very sparse density matrices (e.g., superpositions of Fock states in a\n        large Hilbert space). The 'clenshaw' method is the preferred method for\n        dealing with density matrices that have a large number of excitations\n        (&gt;~50). 'clenshaw' is a fast and numerically stable method.\n\n    Returns\n    -------\n\n    W : array\n        Values representing the Wigner function calculated over the specified\n        range [xvec,yvec].\n\n\n    References\n    ----------\n\n    Ulf Leonhardt,\n    Measuring the Quantum State of Light, (Cambridge University Press, 1997)\n\n    \"\"\"\n\n    if not (psi.is_vec() or psi.is_dm()):\n        raise TypeError(\"Input state is not a valid operator.\")\n\n    if method == \"fft\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    if method == \"iterative\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    elif method == \"laguerre\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    elif method == \"clenshaw\":\n        rho = psi.to_dm()\n        rho = rho.data\n\n        vmapped_wigner_clenshaw = [_wigner_clenshaw]\n\n        for _ in rho.shape[:-2]:\n            vmapped_wigner_clenshaw.append(\n                vmap(\n                    vmapped_wigner_clenshaw[-1],\n                    in_axes=(0, None, None, None),\n                    out_axes=0,\n                )\n            )\n        return vmapped_wigner_clenshaw[-1](rho, xvec, yvec, g)\n\n    else:\n        raise TypeError(\"method must be either 'iterative', 'laguerre', or 'fft'.\")\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html","title":"circuits","text":"<p>Quantum Circuits</p>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Gate","title":"<code>Gate</code>","text":"Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>@struct.dataclass\nclass Gate:\n    dims: List[int] = struct.field(pytree_node=False)\n    _U: Optional[Array] # Unitary\n    _Ht: Optional[Array] # Hamiltonian\n    _KM: Optional[Qarray] # Kraus map\n    _c_ops: Optional[Qarray]\n    _params: Dict[str, Any]\n    _ts: Array\n    _name: str = struct.field(pytree_node=False)\n    num_modes: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(\n        cls,\n        dims: Union[int, List[int]],\n        name: str = \"Gate\",\n        params: Optional[Dict[str, Any]] = None,\n        ts: Optional[Array] = None,\n        gen_U: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_Ht: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_c_ops: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_KM: Optional[Callable[[Dict[str, Any]], List[Qarray]]] = None,\n        num_modes: int = 1,\n    ):\n        \"\"\"Create a gate.\n\n        Args:\n            dims: Dimensions of the gate.\n            name: Name of the gate.\n            params: Parameters of the gate.\n            ts: Times of the gate.\n            gen_U: Function to generate the unitary of the gate.\n            gen_Ht: Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.\n            gen_KM: Function to generate the Kraus map of the gate.\n            num_modes: Number of modes of the gate.\n        \"\"\"\n\n        # TODO: add params to device?\n\n        if isinstance(dims, int):\n            dims = [dims]\n\n        assert len(dims) == num_modes, (\n            \"Number of dimensions must match number of modes.\"\n        )\n\n        # Unitary\n        _U = gen_U(params) if gen_U is not None else None \n        _Ht = gen_Ht(params) if gen_Ht is not None else None \n        _c_ops = gen_c_ops(params) if gen_c_ops is not None else Qarray.from_list([])\n\n        if gen_KM is not None:\n            _KM = gen_KM(params)\n        elif _U is not None:\n            _KM = Qarray.from_list([_U])\n\n        return Gate(\n            dims = dims,\n            _U = _U,\n            _Ht = _Ht,\n            _KM = _KM,\n            _c_ops = _c_ops,\n            _params = params if params is not None else {},\n            _ts=ts if ts is not None else jnp.array([]),\n            _name=name,\n            num_modes=num_modes,\n        )\n\n    def __str__(self):\n        return self._name\n\n    def __repr__(self):\n        return self._name\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def U(self):\n        return self._U\n\n    @property\n    def Ht(self):\n        return self._Ht\n\n    @property\n    def KM(self):\n        return self._KM\n\n    @property\n    def c_ops(self):\n        return self._c_ops\n\n    @property\n    def params(self):\n        return self._params\n\n    @property\n    def ts(self):\n        return self._ts\n\n    def add_Ht(self, Ht: Callable[[float], Qarray]):\n        \"\"\"Add a Hamiltonian function to the gate.\"\"\"\n        def new_Ht(t):\n            return Ht(t) + self.Ht(t) if self.Ht is not None else Ht(t)\n\n        return Gate(\n            dims = self.dims,\n            _U = self.U,\n            _Ht = new_Ht,\n            _KM = self.KM,\n            _c_ops = self.c_ops,\n            _params = self.params,\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n\n    def add_c_ops(self, c_ops: Qarray):\n        \"\"\"Add a c_ops to the gate.\"\"\"\n        return Gate(\n            dims = self.dims,\n            _U = self.U,\n            _Ht = self.Ht,\n            _KM = self.KM,\n            _c_ops = concatenate([self.c_ops, c_ops]),\n            _params = self.params,\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n\n    def copy(self):\n        \"\"\"Return a copy of the gate.\"\"\"\n        return Gate(\n            dims = deepcopy(self.dims),\n            _U = self.U,\n            _Ht = deepcopy(self.Ht),\n            _KM = self.KM,\n            _c_ops = self.c_ops,\n            _params = deepcopy(self.params),\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Gate.add_Ht","title":"<code>add_Ht(Ht)</code>","text":"<p>Add a Hamiltonian function to the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def add_Ht(self, Ht: Callable[[float], Qarray]):\n    \"\"\"Add a Hamiltonian function to the gate.\"\"\"\n    def new_Ht(t):\n        return Ht(t) + self.Ht(t) if self.Ht is not None else Ht(t)\n\n    return Gate(\n        dims = self.dims,\n        _U = self.U,\n        _Ht = new_Ht,\n        _KM = self.KM,\n        _c_ops = self.c_ops,\n        _params = self.params,\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Gate.add_c_ops","title":"<code>add_c_ops(c_ops)</code>","text":"<p>Add a c_ops to the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def add_c_ops(self, c_ops: Qarray):\n    \"\"\"Add a c_ops to the gate.\"\"\"\n    return Gate(\n        dims = self.dims,\n        _U = self.U,\n        _Ht = self.Ht,\n        _KM = self.KM,\n        _c_ops = concatenate([self.c_ops, c_ops]),\n        _params = self.params,\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Gate.copy","title":"<code>copy()</code>","text":"<p>Return a copy of the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def copy(self):\n    \"\"\"Return a copy of the gate.\"\"\"\n    return Gate(\n        dims = deepcopy(self.dims),\n        _U = self.U,\n        _Ht = deepcopy(self.Ht),\n        _KM = self.KM,\n        _c_ops = self.c_ops,\n        _params = deepcopy(self.params),\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Gate.create","title":"<code>create(dims, name='Gate', params=None, ts=None, gen_U=None, gen_Ht=None, gen_c_ops=None, gen_KM=None, num_modes=1)</code>  <code>classmethod</code>","text":"<p>Create a gate.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Union[int, List[int]]</code> <p>Dimensions of the gate.</p> required <code>name</code> <code>str</code> <p>Name of the gate.</p> <code>'Gate'</code> <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>Parameters of the gate.</p> <code>None</code> <code>ts</code> <code>Optional[Array]</code> <p>Times of the gate.</p> <code>None</code> <code>gen_U</code> <code>Optional[Callable[[Dict[str, Any]], Qarray]]</code> <p>Function to generate the unitary of the gate.</p> <code>None</code> <code>gen_Ht</code> <code>Optional[Callable[[Dict[str, Any]], Qarray]]</code> <p>Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.</p> <code>None</code> <code>gen_KM</code> <code>Optional[Callable[[Dict[str, Any]], List[Qarray]]]</code> <p>Function to generate the Kraus map of the gate.</p> <code>None</code> <code>num_modes</code> <code>int</code> <p>Number of modes of the gate.</p> <code>1</code> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    dims: Union[int, List[int]],\n    name: str = \"Gate\",\n    params: Optional[Dict[str, Any]] = None,\n    ts: Optional[Array] = None,\n    gen_U: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_Ht: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_c_ops: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_KM: Optional[Callable[[Dict[str, Any]], List[Qarray]]] = None,\n    num_modes: int = 1,\n):\n    \"\"\"Create a gate.\n\n    Args:\n        dims: Dimensions of the gate.\n        name: Name of the gate.\n        params: Parameters of the gate.\n        ts: Times of the gate.\n        gen_U: Function to generate the unitary of the gate.\n        gen_Ht: Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.\n        gen_KM: Function to generate the Kraus map of the gate.\n        num_modes: Number of modes of the gate.\n    \"\"\"\n\n    # TODO: add params to device?\n\n    if isinstance(dims, int):\n        dims = [dims]\n\n    assert len(dims) == num_modes, (\n        \"Number of dimensions must match number of modes.\"\n    )\n\n    # Unitary\n    _U = gen_U(params) if gen_U is not None else None \n    _Ht = gen_Ht(params) if gen_Ht is not None else None \n    _c_ops = gen_c_ops(params) if gen_c_ops is not None else Qarray.from_list([])\n\n    if gen_KM is not None:\n        _KM = gen_KM(params)\n    elif _U is not None:\n        _KM = Qarray.from_list([_U])\n\n    return Gate(\n        dims = dims,\n        _U = _U,\n        _Ht = _Ht,\n        _KM = _KM,\n        _c_ops = _c_ops,\n        _params = params if params is not None else {},\n        _ts=ts if ts is not None else jnp.array([]),\n        _name=name,\n        num_modes=num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray","title":"<code>Qarray</code>","text":"Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@struct.dataclass  # this allows us to send in and return Qarray from jitted functions\nclass Qarray:\n    _data: Array\n    _qdims: Qdims = struct.field(pytree_node=False)\n    _bdims: tuple[int] = struct.field(pytree_node=False)\n\n    # Initialization ----\n    @classmethod\n    def create(cls, data, dims=None, bdims=None):\n        # Step 1: Prepare data ----\n        data = jnp.asarray(data)\n\n        if len(data.shape) == 1 and data.shape[0] &gt; 0:\n            data = data.reshape(data.shape[0], 1)\n\n        if len(data.shape) &gt;= 2:\n            if data.shape[-2] != data.shape[-1] and not (\n                data.shape[-2] == 1 or data.shape[-1] == 1\n            ):\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n\n        if bdims is not None:\n            if len(data.shape) - len(bdims) == 1:\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n        # ----\n\n        # Step 2: Prepare dimensions ----\n        if bdims is None:\n            bdims = tuple(data.shape[:-2])\n\n        if dims is None:\n            dims = ((data.shape[-2],), (data.shape[-1],))\n\n        if not isinstance(dims[0], (list, tuple)):\n            # This handles the case where only the hilbert space dimensions are sent in.\n            if data.shape[-1] == 1:\n                dims = (tuple(dims), tuple([1 for _ in dims]))\n            elif data.shape[-2] == 1:\n                dims = (tuple([1 for _ in dims]), tuple(dims))\n            else:\n                dims = (tuple(dims), tuple(dims))\n        else:\n            dims = (tuple(dims[0]), tuple(dims[1]))\n\n        check_dims(dims, bdims, data.shape)\n\n        qdims = Qdims(dims)\n\n        # NOTE: Constantly tidying up on Qarray creation might be a bit overkill.\n        # It increases the compilation time, but only very slightly\n        # increased the runtime of the jit compiled function.\n        # We could instead use this tidy_up where we think we need it.\n        data = tidy_up(data, SETTINGS[\"auto_tidyup_atol\"])\n\n        return cls(data, qdims, bdims)\n\n    # ----\n\n    @classmethod\n    def from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n        \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n        data = jnp.array([qarr.data for qarr in qarr_list])\n\n        if len(qarr_list) == 0:\n            dims = ((), ())\n            bdims = ()\n        else:\n            dims = qarr_list[0].dims\n            bdims = qarr_list[0].bdims\n\n        if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n            raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n        bdims = (len(qarr_list),) + bdims\n\n        return cls.create(data, dims=dims, bdims=bdims)\n\n    @classmethod\n    def from_array(cls, qarr_arr) -&gt; Qarray:\n        \"\"\"Create a Qarray from a nested list of Qarrays.\n\n        Args:\n            qarr_arr (list): nested list of Qarrays\n\n        Returns:\n            Qarray: Qarray object\n        \"\"\"\n        if isinstance(qarr_arr, Qarray):\n            return qarr_arr\n\n        bdims = ()\n        lvl = qarr_arr\n        while not isinstance(lvl, Qarray):\n            bdims = bdims + (len(lvl),)\n            if len(lvl) &gt; 0:\n                lvl = lvl[0]\n            else:\n                break\n\n        def flat(lis):\n            flatList = []\n            for element in lis:\n                if type(element) is list:\n                    flatList += flat(element)\n                else:\n                    flatList.append(element)\n            return flatList\n\n        qarr_list = flat(qarr_arr)\n        qarr = cls.from_list(qarr_list)\n        qarr = qarr.reshape_bdims(*bdims)\n        return qarr\n\n    # Properties ----\n    @property\n    def qtype(self):\n        return self._qdims.qtype\n\n    @property\n    def dtype(self):\n        return self._data.dtype\n\n    @property\n    def dims(self):\n        return self._qdims.dims\n\n    @property\n    def bdims(self):\n        return self._bdims\n\n    @property\n    def qdims(self):\n        return self._qdims\n\n    @property\n    def space_dims(self):\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return self.dims[0]\n        elif self.qtype == Qtypes.bra:\n            return self.dims[1]\n        else:\n            # TODO: not reached for some reason\n            raise ValueError(\"Unsupported qtype.\")\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def shaped_data(self):\n        return self._data.reshape(self.bdims + self.dims[0] + self.dims[1])\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def is_batched(self):\n        return len(self.bdims) &gt; 0\n\n    def __getitem__(self, index):\n        if len(self.bdims) &gt; 0:\n            return Qarray.create(\n                self.data[index],\n                dims=self.dims,\n            )\n        else:\n            raise ValueError(\"Cannot index a non-batched Qarray.\")\n\n    def reshape_bdims(self, *args):\n        \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n        new_bdims = tuple(args)\n\n        if prod(new_bdims) == 0:\n            new_shape = new_bdims\n        else:\n            new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n        return Qarray.create(\n            self.data.reshape(new_shape),\n            dims=self.dims,\n            bdims=new_bdims,\n        )\n\n    def space_to_qdims(self, space_dims: List[int]):\n        if isinstance(space_dims[0], (list, tuple)):\n            return space_dims\n\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return (tuple(space_dims), tuple([1 for _ in range(len(space_dims))]))\n        elif self.qtype == Qtypes.bra:\n            return (tuple([1 for _ in range(len(space_dims))]), tuple(space_dims))\n        else:\n            raise ValueError(\"Unsupported qtype for space_to_qdims conversion.\")\n\n    def reshape_qdims(self, *args):\n        \"\"\"Reshape the quantum dimensions of the Qarray.\n\n        Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n        Args:\n            *args: new Hilbert dimensions for the Qarray.\n\n        Returns:\n            Qarray: reshaped Qarray.\n        \"\"\"\n\n        new_space_dims = tuple(args)\n        current_space_dims = self.space_dims\n        assert prod(new_space_dims) == prod(current_space_dims)\n\n        new_qdims = self.space_to_qdims(new_space_dims)\n        new_bdims = self.bdims\n\n        return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n\n    def resize(self, new_shape):\n        \"\"\"Resize the Qarray to a new shape.\n\n        TODO: review and maybe deprecate this method.\n        \"\"\"\n        dims = self.dims\n        data = jnp.resize(self.data, new_shape)\n        return Qarray.create(\n            data,\n            dims=dims,\n        )\n\n    def __len__(self):\n        \"\"\"Length of the Qarray.\"\"\"\n        if len(self.bdims) &gt; 0:\n            return self.data.shape[0]\n        else:\n            raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Qarray):\n            raise ValueError(\"Cannot calculate equality of a Qarray with a non-Qarray.\")\n\n        if self.dims != other.dims:\n            return False\n\n        if self.bdims != other.bdims:\n            return False\n\n        return jnp.all(self.data == other.data)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # ----\n\n    # Elementary Math ----\n    def __matmul__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        _qdims_new = self._qdims @ other._qdims\n        return Qarray.create(\n            self.data @ other.data,\n            dims=_qdims_new.dims,\n        )\n\n    # NOTE: not possible to reach this.\n    # def __rmatmul__(self, other):\n    #     if not isinstance(other, Qarray):\n    #         return NotImplemented\n\n    #     _qdims_new = other._qdims @ self._qdims\n    #     return Qarray.create(\n    #         other.data @ self.data,\n    #         dims=_qdims_new.dims,\n    #     )\n\n    def __mul__(self, other):\n        if isinstance(other, Qarray):\n            return self.__matmul__(other)\n\n        other = other + 0.0j\n        if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n            other = other.reshape(other.shape + (1, 1))\n\n        return Qarray.create(\n            other * self.data,\n            dims=self._qdims.dims,\n        )\n\n    def __rmul__(self, other):\n        # NOTE: not possible to reach this.\n        # if isinstance(other, Qarray):\n        #     return self.__rmatmul__(other)\n\n        return self.__mul__(other)\n\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    def __truediv__(self, other):\n        \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n        if isinstance(other, Qarray):\n            raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n        return self.__mul__(1 / other)\n\n    def __add__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data + other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__add__(other)\n\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data - other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__sub__(other)\n\n        return NotImplemented\n\n    def __rsub__(self, other):\n        return self.__neg__().__add__(other)\n\n    def __xor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(self, other)\n\n    def __rxor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(other, self)\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n\n        return powm(self, other)\n\n    # ----\n\n    # String Representation ----\n    def _str_header(self):\n        out = \", \".join(\n            [\n                \"Quantum array: dims = \" + str(self.dims),\n                \"bdims = \" + str(self.bdims),\n                \"shape = \" + str(self._data.shape),\n                \"type = \" + str(self.qtype),\n            ]\n        )\n        return out\n\n    def __str__(self):\n        return self._str_header() + \"\\nQarray data =\\n\" + str(self.data)\n\n    @property\n    def header(self):\n        \"\"\"Print the header of the Qarray.\"\"\"\n        return self._str_header()\n\n    def __repr__(self):\n        return self.__str__()\n\n    # ----\n\n    # Utilities ----\n    def copy(self, memo=None):\n        # return Qarray.create(deepcopy(self.data), dims=self.dims)\n        return self.__deepcopy__(memo)\n\n    def __deepcopy__(self, memo):\n        \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n        return Qarray(\n            _data=deepcopy(self._data, memo=memo),\n            _qdims=deepcopy(self._qdims, memo=memo),\n            _bdims=deepcopy(self._bdims, memo=memo),\n        )\n\n    def __getattr__(self, method_name):\n        if \"__\" == method_name[:2]:\n            # NOTE: we return NotImplemented for binary special methods logic in python, plus things like __jax_array__\n            return lambda *args, **kwargs: NotImplemented\n\n        modules = [jnp, jnp.linalg, jsp, jsp.linalg]\n\n        method_f = None\n        for mod in modules:\n            method_f = getattr(mod, method_name, None)\n            if method_f is not None:\n                break\n\n        if method_f is None:\n            raise NotImplementedError(\n                f\"Method {method_name} does not exist. No backup method found in {modules}.\"\n            )\n\n        def func(*args, **kwargs):\n            res = method_f(self.data, *args, **kwargs)\n\n            if getattr(res, \"shape\", None) is None or res.shape != self.data.shape:\n                return res\n            else:\n                return Qarray.create(res, dims=self._qdims.dims)\n\n        return func\n\n    # ----\n\n    # Conversions / Reshaping ----\n    def dag(self):\n        return dag(self)\n\n    def to_dm(self):\n        return ket2dm(self)\n\n    def is_dm(self):\n        return self.qtype == Qtypes.oper\n\n    def is_vec(self):\n        return self.qtype == Qtypes.ket or self.qtype == Qtypes.bra\n\n    def to_ket(self):\n        return to_ket(self)\n\n    def transpose(self, *args):\n        return transpose(self, *args)\n\n    def keep_only_diag_elements(self):\n        return keep_only_diag_elements(self)\n\n    # ----\n\n    # Math Functions ----\n    def unit(self):\n        return unit(self)\n\n    def norm(self):\n        return norm(self)\n\n    def expm(self):\n        return expm(self)\n\n    def powm(self, n):\n        return powm(self, n)\n\n    def cosm(self):\n        return cosm(self)\n\n    def sinm(self):\n        return sinm(self)\n\n    def tr(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def trace(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def ptrace(self, indx):\n        return ptrace(self, indx)\n\n    def eigenstates(self):\n        return eigenstates(self)\n\n    def eigenenergies(self):\n        return eigenenergies(self)\n\n    def collapse(self, mode=\"sum\"):\n        return collapse(self, mode=mode)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.header","title":"<code>header</code>  <code>property</code>","text":"<p>Print the header of the Qarray.</p>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Need to override this when defininig getattr.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n    return Qarray(\n        _data=deepcopy(self._data, memo=memo),\n        _qdims=deepcopy(self._qdims, memo=memo),\n        _bdims=deepcopy(self._bdims, memo=memo),\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.__len__","title":"<code>__len__()</code>","text":"<p>Length of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __len__(self):\n    \"\"\"Length of the Qarray.\"\"\"\n    if len(self.bdims) &gt; 0:\n        return self.data.shape[0]\n    else:\n        raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>For Qarray's, this only really makes sense in the context of division by a scalar.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n    if isinstance(other, Qarray):\n        raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n    return self.__mul__(1 / other)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.from_array","title":"<code>from_array(qarr_arr)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a nested list of Qarrays.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_arr</code> <code>list</code> <p>nested list of Qarrays</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Qarray object</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_array(cls, qarr_arr) -&gt; Qarray:\n    \"\"\"Create a Qarray from a nested list of Qarrays.\n\n    Args:\n        qarr_arr (list): nested list of Qarrays\n\n    Returns:\n        Qarray: Qarray object\n    \"\"\"\n    if isinstance(qarr_arr, Qarray):\n        return qarr_arr\n\n    bdims = ()\n    lvl = qarr_arr\n    while not isinstance(lvl, Qarray):\n        bdims = bdims + (len(lvl),)\n        if len(lvl) &gt; 0:\n            lvl = lvl[0]\n        else:\n            break\n\n    def flat(lis):\n        flatList = []\n        for element in lis:\n            if type(element) is list:\n                flatList += flat(element)\n            else:\n                flatList.append(element)\n        return flatList\n\n    qarr_list = flat(qarr_arr)\n    qarr = cls.from_list(qarr_list)\n    qarr = qarr.reshape_bdims(*bdims)\n    return qarr\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.from_list","title":"<code>from_list(qarr_list)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a list of Qarrays.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n    \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n    data = jnp.array([qarr.data for qarr in qarr_list])\n\n    if len(qarr_list) == 0:\n        dims = ((), ())\n        bdims = ()\n    else:\n        dims = qarr_list[0].dims\n        bdims = qarr_list[0].bdims\n\n    if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n        raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n    bdims = (len(qarr_list),) + bdims\n\n    return cls.create(data, dims=dims, bdims=bdims)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.reshape_bdims","title":"<code>reshape_bdims(*args)</code>","text":"<p>Reshape the batch dimensions of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_bdims(self, *args):\n    \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n    new_bdims = tuple(args)\n\n    if prod(new_bdims) == 0:\n        new_shape = new_bdims\n    else:\n        new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n    return Qarray.create(\n        self.data.reshape(new_shape),\n        dims=self.dims,\n        bdims=new_bdims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.reshape_qdims","title":"<code>reshape_qdims(*args)</code>","text":"<p>Reshape the quantum dimensions of the Qarray.</p> <p>Note that this does not take in qdims but rather the new Hilbert space dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>new Hilbert dimensions for the Qarray.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>reshaped Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_qdims(self, *args):\n    \"\"\"Reshape the quantum dimensions of the Qarray.\n\n    Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n    Args:\n        *args: new Hilbert dimensions for the Qarray.\n\n    Returns:\n        Qarray: reshaped Qarray.\n    \"\"\"\n\n    new_space_dims = tuple(args)\n    current_space_dims = self.space_dims\n    assert prod(new_space_dims) == prod(current_space_dims)\n\n    new_qdims = self.space_to_qdims(new_space_dims)\n    new_bdims = self.bdims\n\n    return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.Qarray.resize","title":"<code>resize(new_shape)</code>","text":"<p>Resize the Qarray to a new shape.</p> <p>TODO: review and maybe deprecate this method.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def resize(self, new_shape):\n    \"\"\"Resize the Qarray to a new shape.\n\n    TODO: review and maybe deprecate this method.\n    \"\"\"\n    dims = self.dims\n    data = jnp.resize(self.data, new_shape)\n    return Qarray.create(\n        data,\n        dims=dims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.CD","title":"<code>CD(N, beta, ts=None)</code>","text":"<p>Conditional displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>beta</code> <p>Conditional displacement amplitude.</p> required <code>ts</code> <p>Optional time sequence for hamiltonian simulation.</p> <code>None</code> <p>Returns:</p> Type Description <p>Conditional displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def CD(N, beta, ts=None):\n    \"\"\"Conditional displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        beta: Conditional displacement amplitude.\n        ts: Optional time sequence for hamiltonian simulation.\n\n    Returns:\n        Conditional displacement gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    gg = g @ g.dag()\n    ee = e @ e.dag()\n\n    gen_Ht = None\n    if ts is not None:\n        delta_t = ts[-1] - ts[0]\n        amp = 1j * beta / delta_t / 2\n        a = destroy(N)\n        gen_Ht = lambda params: lambda t: (\n            gg\n            ^ (jnp.conj(amp) * a + amp * a.dag()) + ee\n            ^ (jnp.conj(-amp) * a + (-amp) * a.dag())\n        )\n\n    return Gate.create(\n        [2, N],\n        name=\"CD\",\n        params={\"beta\": beta},\n        gen_U=lambda params: (gg ^ displace(N, params[\"beta\"] / 2))\n        + (ee ^ displace(N, -params[\"beta\"] / 2)),\n        gen_Ht=gen_Ht,\n        ts=ts,\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.CR","title":"<code>CR(N, theta)</code>","text":"<p>Conditional rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>theta</code> <p>Conditional rotation angle.</p> required <p>Returns:</p> Type Description <p>Conditional rotation gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def CR(N, theta):\n    \"\"\"Conditional rotation gate.\n\n    Args:\n        N: Hilbert space dimension.\n        theta: Conditional rotation angle.\n\n    Returns:\n        Conditional rotation gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    gg = g @ g.dag()\n    ee = e @ e.dag()\n\n\n    return Gate.create(\n        [2, N],\n        name=\"CR\",\n        params={\"theta\": theta},\n        gen_U=lambda params: (gg ^ (-1.j*theta/2*create(N)@destroy(N)).expm())\n        + (ee ^ (1.j*theta/2*create(N)@destroy(N)).expm()),\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.D","title":"<code>D(N, alpha, ts=None, c_ops=None)</code>","text":"<p>Displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>alpha</code> <p>Displacement amplitude.</p> required <code>ts</code> <p>Optional time array for hamiltonian simulation.</p> <code>None</code> <code>c_ops</code> <p>Optional collapse operators.</p> <code>None</code> <p>Returns:</p> Type Description <p>Displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def D(N, alpha, ts=None, c_ops=None):\n    \"\"\"Displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        alpha: Displacement amplitude.\n        ts: Optional time array for hamiltonian simulation.\n        c_ops: Optional collapse operators.\n\n    Returns:\n        Displacement gate.\n    \"\"\"\n    gen_Ht = None\n    if ts is not None:\n        delta_t = ts[-1] - ts[0]\n        amp = 1j * alpha / delta_t\n        a = destroy(N)\n        gen_Ht = lambda params: (lambda t: jnp.conj(amp) * a + amp * a.dag())\n\n    return Gate.create(\n        N,\n        name=\"D\",\n        params={\"alpha\": alpha},\n        gen_U=lambda params: displace(N, params[\"alpha\"]),\n        gen_Ht=gen_Ht,\n        ts=ts,\n        gen_c_ops=lambda params: Qarray.from_list([]) if c_ops is None else c_ops,\n        num_modes=1,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.ECD","title":"<code>ECD(N, beta, ts=None)</code>","text":"<p>Echoed conditional displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>beta</code> <p>Conditional displacement amplitude.</p> required <code>ts</code> <p>Optional time sequence for hamiltonian simulation.</p> <code>None</code> <p>Returns:</p> Type Description <p>Echoed conditional displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def ECD(N, beta, ts=None):\n    \"\"\"Echoed conditional displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        beta: Conditional displacement amplitude.\n        ts: Optional time sequence for hamiltonian simulation.\n\n    Returns:\n        Echoed conditional displacement gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    eg = e @ g.dag()\n    ge = g @ e.dag()\n\n    # gen_Ht = None\n    # if ts is not None:\n    #     delta_t = ts[-1] - ts[0]\n    #     amp = 1j * beta / delta_t / 2\n    #     a = destroy(N)\n    #     gen_Ht = lambda params: lambda t: (\n    #         eg\n    #         ^ (jnp.conj(amp) * a + amp * a.dag()) + ge\n    #         ^ (jnp.conj(-amp) * a + (-amp) * a.dag())\n    #     )\n\n    return Gate.create(\n        [2, N],\n        name=\"ECD\",\n        params={\"beta\": beta},\n        gen_U=lambda params: (eg ^ displace(N, params[\"beta\"] / 2))\n        + (ge ^ displace(N, -params[\"beta\"] / 2)),\n        gen_Ht=None,\n        ts=ts,\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.basis","title":"<code>basis(N, k)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert space dimension</p> required <code>k</code> <code>int</code> <p>fock number</p> required <p>Returns:</p> Type Description <p>Fock State |k&gt;</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis(N: int, k: int):\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.\n\n    Args:\n        N: Hilbert space dimension\n        k: fock number\n\n    Returns:\n        Fock State |k&gt;\n    \"\"\"\n    return Qarray.create(one_hot(k, N).reshape(N, 1))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.concatenate","title":"<code>concatenate(qarr_list, axis=0)</code>","text":"<p>Concatenate a list of Qarrays along a specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_list</code> <code>List[Qarray]</code> <p>List of Qarrays to concatenate.</p> required <code>axis</code> <code>int</code> <p>Axis along which to concatenate. Default is 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Concatenated Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def concatenate(qarr_list: List[Qarray], axis: int = 0) -&gt; Qarray:\n    \"\"\"Concatenate a list of Qarrays along a specified axis.\n\n    Args:\n        qarr_list (List[Qarray]): List of Qarrays to concatenate.\n        axis (int): Axis along which to concatenate. Default is 0.\n\n    Returns:\n        Qarray: Concatenated Qarray.\n    \"\"\"\n\n    non_empty_qarr_list = [qarr for qarr in qarr_list if len(qarr.data) != 0]\n\n    if len(non_empty_qarr_list) == 0:\n        return Qarray.from_list([])\n\n    concatenated_data = jnp.concatenate(\n        [qarr.data for qarr in non_empty_qarr_list], axis=axis\n    )\n\n    dims = non_empty_qarr_list[0].dims\n    return Qarray.create(concatenated_data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.diag_expm","title":"<code>diag_expm(diag_matrix)</code>","text":"<p>Computes expm of a diagonal matrix efficiently (O(N) instead of O(N^3)).</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def diag_expm(diag_matrix):\n    \"\"\"Computes expm of a diagonal matrix efficiently (O(N) instead of O(N^3)).\"\"\"\n    # Extract diagonal, exponentiate elements, put back on diagonal\n    return jnp.diag(jnp.exp(jnp.diagonal(diag_matrix)))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.displace","title":"<code>displace(N, \u03b1)</code>","text":"<p>Displacement operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>\u03b1</code> <p>Phase space displacement</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Displace operator D(\u03b1)</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def displace(N, \u03b1) -&gt; Qarray:\n    \"\"\"Displacement operator\n\n    Args:\n        N: Hilbert Space Size\n        \u03b1: Phase space displacement\n\n    Returns:\n        Displace operator D(\u03b1)\n    \"\"\"\n    a = destroy(N)\n    return (\u03b1 * a.dag() - jnp.conj(\u03b1) * a).expm()\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.hadamard","title":"<code>hadamard()</code>","text":"<p>H</p> <p>Returns:</p> Name Type Description <code>H</code> <code>Qarray</code> <p>Hadamard gate</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def hadamard() -&gt; Qarray:\n    \"\"\"H\n\n    Returns:\n        H: Hadamard gate\n    \"\"\"\n    return Qarray.create(jnp.array([[1, 1], [1, -1]]) / jnp.sqrt(2))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.ket2dm","title":"<code>ket2dm(qarr)</code>","text":"<p>Turns ket into density matrix. Does nothing if already operator.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>qarr</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ket2dm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Turns ket into density matrix.\n    Does nothing if already operator.\n\n    Args:\n        qarr (Qarray): qarr\n\n    Returns:\n        Density matrix\n    \"\"\"\n\n    if qarr.qtype == Qtypes.oper:\n        return qarr\n\n    if qarr.qtype == Qtypes.bra:\n        qarr = qarr.dag()\n\n    return qarr @ qarr.dag()\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.mesolve","title":"<code>mesolve(H, rho0, tlist, saveat_tlist=None, c_ops=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[Qarray, Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function or time-independent Qarray.</p> required <code>rho0</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>tlist</code> <code>Array</code> <p>time list</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <code>c_ops</code> <code>Optional[Qarray]</code> <p>qarray list of collapse operators</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    rho0: Qarray,\n    tlist: Array,\n    saveat_tlist: Optional[Array] = None,\n    c_ops: Optional[Qarray] = None,\n    solver_options: Optional[SolverOptions] = None,\n) -&gt; Qarray:\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        H: time dependent Hamiltonian function or time-independent Qarray.\n        rho0: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        tlist: time list\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n        c_ops: qarray list of collapse operators\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    saveat_tlist = saveat_tlist if saveat_tlist is not None else tlist\n\n    saveat_tlist = jnp.atleast_1d(saveat_tlist)\n\n    c_ops = c_ops if c_ops is not None else Qarray.from_list([])\n\n    # if isinstance(H, Qarray):\n\n    if len(c_ops) == 0 and rho0.qtype != Qtypes.oper:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = rho0.to_dm()\n    dims = \u03c10.dims\n    \u03c10 = \u03c10.data\n\n    c_ops = c_ops.data\n\n    if isinstance(H, Qarray):\n        Ht_data = lambda t: H.data\n    else:\n        Ht_data = lambda t: H(t).data\n\n    ys = _mesolve_data(Ht_data, \u03c10, tlist, saveat_tlist, c_ops,\n                       solver_options=solver_options)\n\n    return jnp2jqt(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.num","title":"<code>num(N)</code>","text":"<p>Number operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>number operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def num(N) -&gt; Qarray:\n    \"\"\"Number operator\n\n    Args:\n        N: Hilbert Space size\n\n    Returns:\n        number operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.arange(N)))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.qubit_rotation","title":"<code>qubit_rotation(theta, nx, ny, nz)</code>","text":"<p>Single qubit rotation.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>rotation angle.</p> required <code>nx</code> <p>rotation axis x component.</p> required <code>ny</code> <p>rotation axis y component.</p> required <code>nz</code> <p>rotation axis z component.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Single qubit rotation operator.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def qubit_rotation(theta: float, nx, ny, nz) -&gt; Qarray:\n    \"\"\"Single qubit rotation.\n\n    Args:\n        theta: rotation angle.\n        nx: rotation axis x component.\n        ny: rotation axis y component.\n        nz: rotation axis z component.\n\n    Returns:\n        Single qubit rotation operator.\n    \"\"\"\n    return jnp.cos(theta / 2) * identity(2) - 1j * jnp.sin(theta / 2) * (\n        nx * sigmax() + ny * sigmay() + nz * sigmaz()\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.sesolve","title":"<code>sesolve(H, rho0, tlist, saveat_tlist=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[Qarray, Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function or time-independent Qarray.</p> required <code>rho0</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>tlist</code> <code>Array</code> <p>time list</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    rho0: Qarray,\n    tlist: Array,\n    saveat_tlist: Optional[Array] = None,\n    solver_options: Optional[SolverOptions] = None,\n) -&gt; Qarray:\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        H: time dependent Hamiltonian function or time-independent Qarray.\n        rho0: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        tlist: time list\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    saveat_tlist = saveat_tlist if saveat_tlist is not None else tlist\n\n    saveat_tlist = jnp.atleast_1d(saveat_tlist)\n\n    \u03c8 = rho0\n\n    if \u03c8.qtype == Qtypes.oper:\n        raise ValueError(\n            \"Please use `jqt.mesolve` for initial state inputs in density matrix form.\"\n        )\n\n    \u03c8 = \u03c8.to_ket()\n    dims = \u03c8.dims\n    \u03c8 = \u03c8.data\n\n    if isinstance(H, Qarray):\n        Ht_data = lambda t: H.data\n    else:\n        Ht_data = lambda t: H(t).data\n\n    ys = _sesolve_data(Ht_data, \u03c8, tlist, saveat_tlist,\n                       solver_options=solver_options)\n\n    return jnp2jqt(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/index.html#jaxquantum.circuits.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <code>parallel</code> <code>bool</code> <p>if True, use parallel einsum for tensor product true: [A,B] ^ [C,D] = [A^C, B^D] false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n        parallel (bool): if True, use parallel einsum for tensor product\n            true: [A,B] ^ [C,D] = [A^C, B^D]\n            false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n\n    parallel = kwargs.pop(\"parallel\", False)\n\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    dims_0 = dims[0]\n    dims_1 = dims[1]\n    for arg in args[1:]:\n        if parallel:\n            a = data\n            b = arg.data\n\n            if len(a.shape) &gt; len(b.shape):\n                batch_dim = a.shape[:-2]\n            elif len(a.shape) == len(b.shape):\n                if prod(a.shape[:-2]) &gt; prod(b.shape[:-2]):\n                    batch_dim = a.shape[:-2]\n                else:\n                    batch_dim = b.shape[:-2]\n            else:\n                batch_dim = b.shape[:-2]\n\n            data = jnp.einsum(\"...ij,...kl-&gt;...ikjl\", a, b).reshape(\n                *batch_dim, a.shape[-2] * b.shape[-2], -1\n            )\n        else:\n            data = jnp.kron(data, arg.data, **kwargs)\n\n        dims_0 = dims_0 + arg.dims[0]\n        dims_1 = dims_1 + arg.dims[1]\n\n    return Qarray.create(data, dims=(dims_0, dims_1))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/circuits.html","title":"circuits","text":"<p>Circuits.</p> <p>Inspired by a mix of Cirq and Qiskit circuits.</p>"},{"location":"reference/jaxquantum/circuits/constants.html","title":"constants","text":"<p>Constants.</p>"},{"location":"reference/jaxquantum/circuits/gates.html","title":"gates","text":"<p>Gates.</p>"},{"location":"reference/jaxquantum/circuits/gates.html#jaxquantum.circuits.gates.Gate","title":"<code>Gate</code>","text":"Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>@struct.dataclass\nclass Gate:\n    dims: List[int] = struct.field(pytree_node=False)\n    _U: Optional[Array] # Unitary\n    _Ht: Optional[Array] # Hamiltonian\n    _KM: Optional[Qarray] # Kraus map\n    _c_ops: Optional[Qarray]\n    _params: Dict[str, Any]\n    _ts: Array\n    _name: str = struct.field(pytree_node=False)\n    num_modes: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(\n        cls,\n        dims: Union[int, List[int]],\n        name: str = \"Gate\",\n        params: Optional[Dict[str, Any]] = None,\n        ts: Optional[Array] = None,\n        gen_U: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_Ht: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_c_ops: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_KM: Optional[Callable[[Dict[str, Any]], List[Qarray]]] = None,\n        num_modes: int = 1,\n    ):\n        \"\"\"Create a gate.\n\n        Args:\n            dims: Dimensions of the gate.\n            name: Name of the gate.\n            params: Parameters of the gate.\n            ts: Times of the gate.\n            gen_U: Function to generate the unitary of the gate.\n            gen_Ht: Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.\n            gen_KM: Function to generate the Kraus map of the gate.\n            num_modes: Number of modes of the gate.\n        \"\"\"\n\n        # TODO: add params to device?\n\n        if isinstance(dims, int):\n            dims = [dims]\n\n        assert len(dims) == num_modes, (\n            \"Number of dimensions must match number of modes.\"\n        )\n\n        # Unitary\n        _U = gen_U(params) if gen_U is not None else None \n        _Ht = gen_Ht(params) if gen_Ht is not None else None \n        _c_ops = gen_c_ops(params) if gen_c_ops is not None else Qarray.from_list([])\n\n        if gen_KM is not None:\n            _KM = gen_KM(params)\n        elif _U is not None:\n            _KM = Qarray.from_list([_U])\n\n        return Gate(\n            dims = dims,\n            _U = _U,\n            _Ht = _Ht,\n            _KM = _KM,\n            _c_ops = _c_ops,\n            _params = params if params is not None else {},\n            _ts=ts if ts is not None else jnp.array([]),\n            _name=name,\n            num_modes=num_modes,\n        )\n\n    def __str__(self):\n        return self._name\n\n    def __repr__(self):\n        return self._name\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def U(self):\n        return self._U\n\n    @property\n    def Ht(self):\n        return self._Ht\n\n    @property\n    def KM(self):\n        return self._KM\n\n    @property\n    def c_ops(self):\n        return self._c_ops\n\n    @property\n    def params(self):\n        return self._params\n\n    @property\n    def ts(self):\n        return self._ts\n\n    def add_Ht(self, Ht: Callable[[float], Qarray]):\n        \"\"\"Add a Hamiltonian function to the gate.\"\"\"\n        def new_Ht(t):\n            return Ht(t) + self.Ht(t) if self.Ht is not None else Ht(t)\n\n        return Gate(\n            dims = self.dims,\n            _U = self.U,\n            _Ht = new_Ht,\n            _KM = self.KM,\n            _c_ops = self.c_ops,\n            _params = self.params,\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n\n    def add_c_ops(self, c_ops: Qarray):\n        \"\"\"Add a c_ops to the gate.\"\"\"\n        return Gate(\n            dims = self.dims,\n            _U = self.U,\n            _Ht = self.Ht,\n            _KM = self.KM,\n            _c_ops = concatenate([self.c_ops, c_ops]),\n            _params = self.params,\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n\n    def copy(self):\n        \"\"\"Return a copy of the gate.\"\"\"\n        return Gate(\n            dims = deepcopy(self.dims),\n            _U = self.U,\n            _Ht = deepcopy(self.Ht),\n            _KM = self.KM,\n            _c_ops = self.c_ops,\n            _params = deepcopy(self.params),\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/gates.html#jaxquantum.circuits.gates.Gate.add_Ht","title":"<code>add_Ht(Ht)</code>","text":"<p>Add a Hamiltonian function to the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def add_Ht(self, Ht: Callable[[float], Qarray]):\n    \"\"\"Add a Hamiltonian function to the gate.\"\"\"\n    def new_Ht(t):\n        return Ht(t) + self.Ht(t) if self.Ht is not None else Ht(t)\n\n    return Gate(\n        dims = self.dims,\n        _U = self.U,\n        _Ht = new_Ht,\n        _KM = self.KM,\n        _c_ops = self.c_ops,\n        _params = self.params,\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/gates.html#jaxquantum.circuits.gates.Gate.add_c_ops","title":"<code>add_c_ops(c_ops)</code>","text":"<p>Add a c_ops to the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def add_c_ops(self, c_ops: Qarray):\n    \"\"\"Add a c_ops to the gate.\"\"\"\n    return Gate(\n        dims = self.dims,\n        _U = self.U,\n        _Ht = self.Ht,\n        _KM = self.KM,\n        _c_ops = concatenate([self.c_ops, c_ops]),\n        _params = self.params,\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/gates.html#jaxquantum.circuits.gates.Gate.copy","title":"<code>copy()</code>","text":"<p>Return a copy of the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def copy(self):\n    \"\"\"Return a copy of the gate.\"\"\"\n    return Gate(\n        dims = deepcopy(self.dims),\n        _U = self.U,\n        _Ht = deepcopy(self.Ht),\n        _KM = self.KM,\n        _c_ops = self.c_ops,\n        _params = deepcopy(self.params),\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/gates.html#jaxquantum.circuits.gates.Gate.create","title":"<code>create(dims, name='Gate', params=None, ts=None, gen_U=None, gen_Ht=None, gen_c_ops=None, gen_KM=None, num_modes=1)</code>  <code>classmethod</code>","text":"<p>Create a gate.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Union[int, List[int]]</code> <p>Dimensions of the gate.</p> required <code>name</code> <code>str</code> <p>Name of the gate.</p> <code>'Gate'</code> <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>Parameters of the gate.</p> <code>None</code> <code>ts</code> <code>Optional[Array]</code> <p>Times of the gate.</p> <code>None</code> <code>gen_U</code> <code>Optional[Callable[[Dict[str, Any]], Qarray]]</code> <p>Function to generate the unitary of the gate.</p> <code>None</code> <code>gen_Ht</code> <code>Optional[Callable[[Dict[str, Any]], Qarray]]</code> <p>Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.</p> <code>None</code> <code>gen_KM</code> <code>Optional[Callable[[Dict[str, Any]], List[Qarray]]]</code> <p>Function to generate the Kraus map of the gate.</p> <code>None</code> <code>num_modes</code> <code>int</code> <p>Number of modes of the gate.</p> <code>1</code> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    dims: Union[int, List[int]],\n    name: str = \"Gate\",\n    params: Optional[Dict[str, Any]] = None,\n    ts: Optional[Array] = None,\n    gen_U: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_Ht: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_c_ops: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_KM: Optional[Callable[[Dict[str, Any]], List[Qarray]]] = None,\n    num_modes: int = 1,\n):\n    \"\"\"Create a gate.\n\n    Args:\n        dims: Dimensions of the gate.\n        name: Name of the gate.\n        params: Parameters of the gate.\n        ts: Times of the gate.\n        gen_U: Function to generate the unitary of the gate.\n        gen_Ht: Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.\n        gen_KM: Function to generate the Kraus map of the gate.\n        num_modes: Number of modes of the gate.\n    \"\"\"\n\n    # TODO: add params to device?\n\n    if isinstance(dims, int):\n        dims = [dims]\n\n    assert len(dims) == num_modes, (\n        \"Number of dimensions must match number of modes.\"\n    )\n\n    # Unitary\n    _U = gen_U(params) if gen_U is not None else None \n    _Ht = gen_Ht(params) if gen_Ht is not None else None \n    _c_ops = gen_c_ops(params) if gen_c_ops is not None else Qarray.from_list([])\n\n    if gen_KM is not None:\n        _KM = gen_KM(params)\n    elif _U is not None:\n        _KM = Qarray.from_list([_U])\n\n    return Gate(\n        dims = dims,\n        _U = _U,\n        _Ht = _Ht,\n        _KM = _KM,\n        _c_ops = _c_ops,\n        _params = params if params is not None else {},\n        _ts=ts if ts is not None else jnp.array([]),\n        _name=name,\n        num_modes=num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/simulate.html","title":"simulate","text":"<p>Circuit simulation methods.</p>"},{"location":"reference/jaxquantum/circuits/simulate.html#jaxquantum.circuits.simulate.simulate","title":"<code>simulate(circuit, initial_state, mode=SimulateMode.DEFAULT, **kwargs)</code>","text":"<p>Simulates the evolution of a quantum state through a given quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to simulate. The circuit is composed of layers,                each of which can generate unitary or Kraus operators.</p> required <code>initial_state</code> <code>Qarray</code> <p>The initial quantum state to be evolved. This can be a state vector                     or a density matrix.</p> required <code>mode</code> <code>SimulateMode</code> <p>The mode of simulation. It can be either SimulateMode.UNITARY                            for unitary evolution or SimulateMode.KRAUS for Kraus operator                            evolution. Defaults to SimulateMode.UNITARY.</p> <code>DEFAULT</code> <p>Returns:</p> Name Type Description <code>Results</code> <code>Results</code> <p>An object containing the results of the simulation, which includes the quantum states      at each step of the circuit.</p> Source code in <code>jaxquantum/circuits/simulate.py</code> <pre><code>def simulate(\n    circuit: Circuit, initial_state: Qarray, mode: SimulateMode = SimulateMode.DEFAULT, **kwargs\n) -&gt; Results:\n    \"\"\"\n    Simulates the evolution of a quantum state through a given quantum circuit.\n\n    Args:\n        circuit (Circuit): The quantum circuit to simulate. The circuit is composed of layers,\n                           each of which can generate unitary or Kraus operators.\n        initial_state (Qarray): The initial quantum state to be evolved. This can be a state vector\n                                or a density matrix.\n        mode (SimulateMode, optional): The mode of simulation. It can be either SimulateMode.UNITARY\n                                       for unitary evolution or SimulateMode.KRAUS for Kraus operator\n                                       evolution. Defaults to SimulateMode.UNITARY.\n\n    Returns:\n        Results: An object containing the results of the simulation, which includes the quantum states\n                 at each step of the circuit.\n    \"\"\"\n\n    results = Results.create([])\n    state = initial_state\n    results.append(Qarray.from_list([state]))\n\n    start_time = 0\n\n    for layer in circuit.layers:\n        result_dict = _simulate_layer(layer, state, mode=mode, start_time=start_time, **kwargs)\n        result = result_dict[\"result\"]\n        start_time = result_dict[\"start_time\"]\n        results.append(result)\n        state = result[-1]\n\n    return results\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html","title":"library","text":"<p>Library imports</p>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Gate","title":"<code>Gate</code>","text":"Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>@struct.dataclass\nclass Gate:\n    dims: List[int] = struct.field(pytree_node=False)\n    _U: Optional[Array] # Unitary\n    _Ht: Optional[Array] # Hamiltonian\n    _KM: Optional[Qarray] # Kraus map\n    _c_ops: Optional[Qarray]\n    _params: Dict[str, Any]\n    _ts: Array\n    _name: str = struct.field(pytree_node=False)\n    num_modes: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(\n        cls,\n        dims: Union[int, List[int]],\n        name: str = \"Gate\",\n        params: Optional[Dict[str, Any]] = None,\n        ts: Optional[Array] = None,\n        gen_U: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_Ht: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_c_ops: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n        gen_KM: Optional[Callable[[Dict[str, Any]], List[Qarray]]] = None,\n        num_modes: int = 1,\n    ):\n        \"\"\"Create a gate.\n\n        Args:\n            dims: Dimensions of the gate.\n            name: Name of the gate.\n            params: Parameters of the gate.\n            ts: Times of the gate.\n            gen_U: Function to generate the unitary of the gate.\n            gen_Ht: Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.\n            gen_KM: Function to generate the Kraus map of the gate.\n            num_modes: Number of modes of the gate.\n        \"\"\"\n\n        # TODO: add params to device?\n\n        if isinstance(dims, int):\n            dims = [dims]\n\n        assert len(dims) == num_modes, (\n            \"Number of dimensions must match number of modes.\"\n        )\n\n        # Unitary\n        _U = gen_U(params) if gen_U is not None else None \n        _Ht = gen_Ht(params) if gen_Ht is not None else None \n        _c_ops = gen_c_ops(params) if gen_c_ops is not None else Qarray.from_list([])\n\n        if gen_KM is not None:\n            _KM = gen_KM(params)\n        elif _U is not None:\n            _KM = Qarray.from_list([_U])\n\n        return Gate(\n            dims = dims,\n            _U = _U,\n            _Ht = _Ht,\n            _KM = _KM,\n            _c_ops = _c_ops,\n            _params = params if params is not None else {},\n            _ts=ts if ts is not None else jnp.array([]),\n            _name=name,\n            num_modes=num_modes,\n        )\n\n    def __str__(self):\n        return self._name\n\n    def __repr__(self):\n        return self._name\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def U(self):\n        return self._U\n\n    @property\n    def Ht(self):\n        return self._Ht\n\n    @property\n    def KM(self):\n        return self._KM\n\n    @property\n    def c_ops(self):\n        return self._c_ops\n\n    @property\n    def params(self):\n        return self._params\n\n    @property\n    def ts(self):\n        return self._ts\n\n    def add_Ht(self, Ht: Callable[[float], Qarray]):\n        \"\"\"Add a Hamiltonian function to the gate.\"\"\"\n        def new_Ht(t):\n            return Ht(t) + self.Ht(t) if self.Ht is not None else Ht(t)\n\n        return Gate(\n            dims = self.dims,\n            _U = self.U,\n            _Ht = new_Ht,\n            _KM = self.KM,\n            _c_ops = self.c_ops,\n            _params = self.params,\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n\n    def add_c_ops(self, c_ops: Qarray):\n        \"\"\"Add a c_ops to the gate.\"\"\"\n        return Gate(\n            dims = self.dims,\n            _U = self.U,\n            _Ht = self.Ht,\n            _KM = self.KM,\n            _c_ops = concatenate([self.c_ops, c_ops]),\n            _params = self.params,\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n\n    def copy(self):\n        \"\"\"Return a copy of the gate.\"\"\"\n        return Gate(\n            dims = deepcopy(self.dims),\n            _U = self.U,\n            _Ht = deepcopy(self.Ht),\n            _KM = self.KM,\n            _c_ops = self.c_ops,\n            _params = deepcopy(self.params),\n            _ts = self.ts,\n            _name = self.name,\n            num_modes = self.num_modes,\n        )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Gate.add_Ht","title":"<code>add_Ht(Ht)</code>","text":"<p>Add a Hamiltonian function to the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def add_Ht(self, Ht: Callable[[float], Qarray]):\n    \"\"\"Add a Hamiltonian function to the gate.\"\"\"\n    def new_Ht(t):\n        return Ht(t) + self.Ht(t) if self.Ht is not None else Ht(t)\n\n    return Gate(\n        dims = self.dims,\n        _U = self.U,\n        _Ht = new_Ht,\n        _KM = self.KM,\n        _c_ops = self.c_ops,\n        _params = self.params,\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Gate.add_c_ops","title":"<code>add_c_ops(c_ops)</code>","text":"<p>Add a c_ops to the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def add_c_ops(self, c_ops: Qarray):\n    \"\"\"Add a c_ops to the gate.\"\"\"\n    return Gate(\n        dims = self.dims,\n        _U = self.U,\n        _Ht = self.Ht,\n        _KM = self.KM,\n        _c_ops = concatenate([self.c_ops, c_ops]),\n        _params = self.params,\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Gate.copy","title":"<code>copy()</code>","text":"<p>Return a copy of the gate.</p> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>def copy(self):\n    \"\"\"Return a copy of the gate.\"\"\"\n    return Gate(\n        dims = deepcopy(self.dims),\n        _U = self.U,\n        _Ht = deepcopy(self.Ht),\n        _KM = self.KM,\n        _c_ops = self.c_ops,\n        _params = deepcopy(self.params),\n        _ts = self.ts,\n        _name = self.name,\n        num_modes = self.num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Gate.create","title":"<code>create(dims, name='Gate', params=None, ts=None, gen_U=None, gen_Ht=None, gen_c_ops=None, gen_KM=None, num_modes=1)</code>  <code>classmethod</code>","text":"<p>Create a gate.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Union[int, List[int]]</code> <p>Dimensions of the gate.</p> required <code>name</code> <code>str</code> <p>Name of the gate.</p> <code>'Gate'</code> <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>Parameters of the gate.</p> <code>None</code> <code>ts</code> <code>Optional[Array]</code> <p>Times of the gate.</p> <code>None</code> <code>gen_U</code> <code>Optional[Callable[[Dict[str, Any]], Qarray]]</code> <p>Function to generate the unitary of the gate.</p> <code>None</code> <code>gen_Ht</code> <code>Optional[Callable[[Dict[str, Any]], Qarray]]</code> <p>Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.</p> <code>None</code> <code>gen_KM</code> <code>Optional[Callable[[Dict[str, Any]], List[Qarray]]]</code> <p>Function to generate the Kraus map of the gate.</p> <code>None</code> <code>num_modes</code> <code>int</code> <p>Number of modes of the gate.</p> <code>1</code> Source code in <code>jaxquantum/circuits/gates.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    dims: Union[int, List[int]],\n    name: str = \"Gate\",\n    params: Optional[Dict[str, Any]] = None,\n    ts: Optional[Array] = None,\n    gen_U: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_Ht: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_c_ops: Optional[Callable[[Dict[str, Any]], Qarray]] = None,\n    gen_KM: Optional[Callable[[Dict[str, Any]], List[Qarray]]] = None,\n    num_modes: int = 1,\n):\n    \"\"\"Create a gate.\n\n    Args:\n        dims: Dimensions of the gate.\n        name: Name of the gate.\n        params: Parameters of the gate.\n        ts: Times of the gate.\n        gen_U: Function to generate the unitary of the gate.\n        gen_Ht: Function to generate a function Ht(t) that takes in a time t and outputs a Hamiltonian Qarray.\n        gen_KM: Function to generate the Kraus map of the gate.\n        num_modes: Number of modes of the gate.\n    \"\"\"\n\n    # TODO: add params to device?\n\n    if isinstance(dims, int):\n        dims = [dims]\n\n    assert len(dims) == num_modes, (\n        \"Number of dimensions must match number of modes.\"\n    )\n\n    # Unitary\n    _U = gen_U(params) if gen_U is not None else None \n    _Ht = gen_Ht(params) if gen_Ht is not None else None \n    _c_ops = gen_c_ops(params) if gen_c_ops is not None else Qarray.from_list([])\n\n    if gen_KM is not None:\n        _KM = gen_KM(params)\n    elif _U is not None:\n        _KM = Qarray.from_list([_U])\n\n    return Gate(\n        dims = dims,\n        _U = _U,\n        _Ht = _Ht,\n        _KM = _KM,\n        _c_ops = _c_ops,\n        _params = params if params is not None else {},\n        _ts=ts if ts is not None else jnp.array([]),\n        _name=name,\n        num_modes=num_modes,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray","title":"<code>Qarray</code>","text":"Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@struct.dataclass  # this allows us to send in and return Qarray from jitted functions\nclass Qarray:\n    _data: Array\n    _qdims: Qdims = struct.field(pytree_node=False)\n    _bdims: tuple[int] = struct.field(pytree_node=False)\n\n    # Initialization ----\n    @classmethod\n    def create(cls, data, dims=None, bdims=None):\n        # Step 1: Prepare data ----\n        data = jnp.asarray(data)\n\n        if len(data.shape) == 1 and data.shape[0] &gt; 0:\n            data = data.reshape(data.shape[0], 1)\n\n        if len(data.shape) &gt;= 2:\n            if data.shape[-2] != data.shape[-1] and not (\n                data.shape[-2] == 1 or data.shape[-1] == 1\n            ):\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n\n        if bdims is not None:\n            if len(data.shape) - len(bdims) == 1:\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n        # ----\n\n        # Step 2: Prepare dimensions ----\n        if bdims is None:\n            bdims = tuple(data.shape[:-2])\n\n        if dims is None:\n            dims = ((data.shape[-2],), (data.shape[-1],))\n\n        if not isinstance(dims[0], (list, tuple)):\n            # This handles the case where only the hilbert space dimensions are sent in.\n            if data.shape[-1] == 1:\n                dims = (tuple(dims), tuple([1 for _ in dims]))\n            elif data.shape[-2] == 1:\n                dims = (tuple([1 for _ in dims]), tuple(dims))\n            else:\n                dims = (tuple(dims), tuple(dims))\n        else:\n            dims = (tuple(dims[0]), tuple(dims[1]))\n\n        check_dims(dims, bdims, data.shape)\n\n        qdims = Qdims(dims)\n\n        # NOTE: Constantly tidying up on Qarray creation might be a bit overkill.\n        # It increases the compilation time, but only very slightly\n        # increased the runtime of the jit compiled function.\n        # We could instead use this tidy_up where we think we need it.\n        data = tidy_up(data, SETTINGS[\"auto_tidyup_atol\"])\n\n        return cls(data, qdims, bdims)\n\n    # ----\n\n    @classmethod\n    def from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n        \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n        data = jnp.array([qarr.data for qarr in qarr_list])\n\n        if len(qarr_list) == 0:\n            dims = ((), ())\n            bdims = ()\n        else:\n            dims = qarr_list[0].dims\n            bdims = qarr_list[0].bdims\n\n        if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n            raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n        bdims = (len(qarr_list),) + bdims\n\n        return cls.create(data, dims=dims, bdims=bdims)\n\n    @classmethod\n    def from_array(cls, qarr_arr) -&gt; Qarray:\n        \"\"\"Create a Qarray from a nested list of Qarrays.\n\n        Args:\n            qarr_arr (list): nested list of Qarrays\n\n        Returns:\n            Qarray: Qarray object\n        \"\"\"\n        if isinstance(qarr_arr, Qarray):\n            return qarr_arr\n\n        bdims = ()\n        lvl = qarr_arr\n        while not isinstance(lvl, Qarray):\n            bdims = bdims + (len(lvl),)\n            if len(lvl) &gt; 0:\n                lvl = lvl[0]\n            else:\n                break\n\n        def flat(lis):\n            flatList = []\n            for element in lis:\n                if type(element) is list:\n                    flatList += flat(element)\n                else:\n                    flatList.append(element)\n            return flatList\n\n        qarr_list = flat(qarr_arr)\n        qarr = cls.from_list(qarr_list)\n        qarr = qarr.reshape_bdims(*bdims)\n        return qarr\n\n    # Properties ----\n    @property\n    def qtype(self):\n        return self._qdims.qtype\n\n    @property\n    def dtype(self):\n        return self._data.dtype\n\n    @property\n    def dims(self):\n        return self._qdims.dims\n\n    @property\n    def bdims(self):\n        return self._bdims\n\n    @property\n    def qdims(self):\n        return self._qdims\n\n    @property\n    def space_dims(self):\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return self.dims[0]\n        elif self.qtype == Qtypes.bra:\n            return self.dims[1]\n        else:\n            # TODO: not reached for some reason\n            raise ValueError(\"Unsupported qtype.\")\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def shaped_data(self):\n        return self._data.reshape(self.bdims + self.dims[0] + self.dims[1])\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def is_batched(self):\n        return len(self.bdims) &gt; 0\n\n    def __getitem__(self, index):\n        if len(self.bdims) &gt; 0:\n            return Qarray.create(\n                self.data[index],\n                dims=self.dims,\n            )\n        else:\n            raise ValueError(\"Cannot index a non-batched Qarray.\")\n\n    def reshape_bdims(self, *args):\n        \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n        new_bdims = tuple(args)\n\n        if prod(new_bdims) == 0:\n            new_shape = new_bdims\n        else:\n            new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n        return Qarray.create(\n            self.data.reshape(new_shape),\n            dims=self.dims,\n            bdims=new_bdims,\n        )\n\n    def space_to_qdims(self, space_dims: List[int]):\n        if isinstance(space_dims[0], (list, tuple)):\n            return space_dims\n\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return (tuple(space_dims), tuple([1 for _ in range(len(space_dims))]))\n        elif self.qtype == Qtypes.bra:\n            return (tuple([1 for _ in range(len(space_dims))]), tuple(space_dims))\n        else:\n            raise ValueError(\"Unsupported qtype for space_to_qdims conversion.\")\n\n    def reshape_qdims(self, *args):\n        \"\"\"Reshape the quantum dimensions of the Qarray.\n\n        Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n        Args:\n            *args: new Hilbert dimensions for the Qarray.\n\n        Returns:\n            Qarray: reshaped Qarray.\n        \"\"\"\n\n        new_space_dims = tuple(args)\n        current_space_dims = self.space_dims\n        assert prod(new_space_dims) == prod(current_space_dims)\n\n        new_qdims = self.space_to_qdims(new_space_dims)\n        new_bdims = self.bdims\n\n        return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n\n    def resize(self, new_shape):\n        \"\"\"Resize the Qarray to a new shape.\n\n        TODO: review and maybe deprecate this method.\n        \"\"\"\n        dims = self.dims\n        data = jnp.resize(self.data, new_shape)\n        return Qarray.create(\n            data,\n            dims=dims,\n        )\n\n    def __len__(self):\n        \"\"\"Length of the Qarray.\"\"\"\n        if len(self.bdims) &gt; 0:\n            return self.data.shape[0]\n        else:\n            raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Qarray):\n            raise ValueError(\"Cannot calculate equality of a Qarray with a non-Qarray.\")\n\n        if self.dims != other.dims:\n            return False\n\n        if self.bdims != other.bdims:\n            return False\n\n        return jnp.all(self.data == other.data)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # ----\n\n    # Elementary Math ----\n    def __matmul__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        _qdims_new = self._qdims @ other._qdims\n        return Qarray.create(\n            self.data @ other.data,\n            dims=_qdims_new.dims,\n        )\n\n    # NOTE: not possible to reach this.\n    # def __rmatmul__(self, other):\n    #     if not isinstance(other, Qarray):\n    #         return NotImplemented\n\n    #     _qdims_new = other._qdims @ self._qdims\n    #     return Qarray.create(\n    #         other.data @ self.data,\n    #         dims=_qdims_new.dims,\n    #     )\n\n    def __mul__(self, other):\n        if isinstance(other, Qarray):\n            return self.__matmul__(other)\n\n        other = other + 0.0j\n        if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n            other = other.reshape(other.shape + (1, 1))\n\n        return Qarray.create(\n            other * self.data,\n            dims=self._qdims.dims,\n        )\n\n    def __rmul__(self, other):\n        # NOTE: not possible to reach this.\n        # if isinstance(other, Qarray):\n        #     return self.__rmatmul__(other)\n\n        return self.__mul__(other)\n\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    def __truediv__(self, other):\n        \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n        if isinstance(other, Qarray):\n            raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n        return self.__mul__(1 / other)\n\n    def __add__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data + other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__add__(other)\n\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data - other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__sub__(other)\n\n        return NotImplemented\n\n    def __rsub__(self, other):\n        return self.__neg__().__add__(other)\n\n    def __xor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(self, other)\n\n    def __rxor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(other, self)\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n\n        return powm(self, other)\n\n    # ----\n\n    # String Representation ----\n    def _str_header(self):\n        out = \", \".join(\n            [\n                \"Quantum array: dims = \" + str(self.dims),\n                \"bdims = \" + str(self.bdims),\n                \"shape = \" + str(self._data.shape),\n                \"type = \" + str(self.qtype),\n            ]\n        )\n        return out\n\n    def __str__(self):\n        return self._str_header() + \"\\nQarray data =\\n\" + str(self.data)\n\n    @property\n    def header(self):\n        \"\"\"Print the header of the Qarray.\"\"\"\n        return self._str_header()\n\n    def __repr__(self):\n        return self.__str__()\n\n    # ----\n\n    # Utilities ----\n    def copy(self, memo=None):\n        # return Qarray.create(deepcopy(self.data), dims=self.dims)\n        return self.__deepcopy__(memo)\n\n    def __deepcopy__(self, memo):\n        \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n        return Qarray(\n            _data=deepcopy(self._data, memo=memo),\n            _qdims=deepcopy(self._qdims, memo=memo),\n            _bdims=deepcopy(self._bdims, memo=memo),\n        )\n\n    def __getattr__(self, method_name):\n        if \"__\" == method_name[:2]:\n            # NOTE: we return NotImplemented for binary special methods logic in python, plus things like __jax_array__\n            return lambda *args, **kwargs: NotImplemented\n\n        modules = [jnp, jnp.linalg, jsp, jsp.linalg]\n\n        method_f = None\n        for mod in modules:\n            method_f = getattr(mod, method_name, None)\n            if method_f is not None:\n                break\n\n        if method_f is None:\n            raise NotImplementedError(\n                f\"Method {method_name} does not exist. No backup method found in {modules}.\"\n            )\n\n        def func(*args, **kwargs):\n            res = method_f(self.data, *args, **kwargs)\n\n            if getattr(res, \"shape\", None) is None or res.shape != self.data.shape:\n                return res\n            else:\n                return Qarray.create(res, dims=self._qdims.dims)\n\n        return func\n\n    # ----\n\n    # Conversions / Reshaping ----\n    def dag(self):\n        return dag(self)\n\n    def to_dm(self):\n        return ket2dm(self)\n\n    def is_dm(self):\n        return self.qtype == Qtypes.oper\n\n    def is_vec(self):\n        return self.qtype == Qtypes.ket or self.qtype == Qtypes.bra\n\n    def to_ket(self):\n        return to_ket(self)\n\n    def transpose(self, *args):\n        return transpose(self, *args)\n\n    def keep_only_diag_elements(self):\n        return keep_only_diag_elements(self)\n\n    # ----\n\n    # Math Functions ----\n    def unit(self):\n        return unit(self)\n\n    def norm(self):\n        return norm(self)\n\n    def expm(self):\n        return expm(self)\n\n    def powm(self, n):\n        return powm(self, n)\n\n    def cosm(self):\n        return cosm(self)\n\n    def sinm(self):\n        return sinm(self)\n\n    def tr(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def trace(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def ptrace(self, indx):\n        return ptrace(self, indx)\n\n    def eigenstates(self):\n        return eigenstates(self)\n\n    def eigenenergies(self):\n        return eigenenergies(self)\n\n    def collapse(self, mode=\"sum\"):\n        return collapse(self, mode=mode)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.header","title":"<code>header</code>  <code>property</code>","text":"<p>Print the header of the Qarray.</p>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Need to override this when defininig getattr.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n    return Qarray(\n        _data=deepcopy(self._data, memo=memo),\n        _qdims=deepcopy(self._qdims, memo=memo),\n        _bdims=deepcopy(self._bdims, memo=memo),\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.__len__","title":"<code>__len__()</code>","text":"<p>Length of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __len__(self):\n    \"\"\"Length of the Qarray.\"\"\"\n    if len(self.bdims) &gt; 0:\n        return self.data.shape[0]\n    else:\n        raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>For Qarray's, this only really makes sense in the context of division by a scalar.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n    if isinstance(other, Qarray):\n        raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n    return self.__mul__(1 / other)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.from_array","title":"<code>from_array(qarr_arr)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a nested list of Qarrays.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_arr</code> <code>list</code> <p>nested list of Qarrays</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Qarray object</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_array(cls, qarr_arr) -&gt; Qarray:\n    \"\"\"Create a Qarray from a nested list of Qarrays.\n\n    Args:\n        qarr_arr (list): nested list of Qarrays\n\n    Returns:\n        Qarray: Qarray object\n    \"\"\"\n    if isinstance(qarr_arr, Qarray):\n        return qarr_arr\n\n    bdims = ()\n    lvl = qarr_arr\n    while not isinstance(lvl, Qarray):\n        bdims = bdims + (len(lvl),)\n        if len(lvl) &gt; 0:\n            lvl = lvl[0]\n        else:\n            break\n\n    def flat(lis):\n        flatList = []\n        for element in lis:\n            if type(element) is list:\n                flatList += flat(element)\n            else:\n                flatList.append(element)\n        return flatList\n\n    qarr_list = flat(qarr_arr)\n    qarr = cls.from_list(qarr_list)\n    qarr = qarr.reshape_bdims(*bdims)\n    return qarr\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.from_list","title":"<code>from_list(qarr_list)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a list of Qarrays.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n    \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n    data = jnp.array([qarr.data for qarr in qarr_list])\n\n    if len(qarr_list) == 0:\n        dims = ((), ())\n        bdims = ()\n    else:\n        dims = qarr_list[0].dims\n        bdims = qarr_list[0].bdims\n\n    if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n        raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n    bdims = (len(qarr_list),) + bdims\n\n    return cls.create(data, dims=dims, bdims=bdims)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.reshape_bdims","title":"<code>reshape_bdims(*args)</code>","text":"<p>Reshape the batch dimensions of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_bdims(self, *args):\n    \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n    new_bdims = tuple(args)\n\n    if prod(new_bdims) == 0:\n        new_shape = new_bdims\n    else:\n        new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n    return Qarray.create(\n        self.data.reshape(new_shape),\n        dims=self.dims,\n        bdims=new_bdims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.reshape_qdims","title":"<code>reshape_qdims(*args)</code>","text":"<p>Reshape the quantum dimensions of the Qarray.</p> <p>Note that this does not take in qdims but rather the new Hilbert space dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>new Hilbert dimensions for the Qarray.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>reshaped Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_qdims(self, *args):\n    \"\"\"Reshape the quantum dimensions of the Qarray.\n\n    Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n    Args:\n        *args: new Hilbert dimensions for the Qarray.\n\n    Returns:\n        Qarray: reshaped Qarray.\n    \"\"\"\n\n    new_space_dims = tuple(args)\n    current_space_dims = self.space_dims\n    assert prod(new_space_dims) == prod(current_space_dims)\n\n    new_qdims = self.space_to_qdims(new_space_dims)\n    new_bdims = self.bdims\n\n    return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.Qarray.resize","title":"<code>resize(new_shape)</code>","text":"<p>Resize the Qarray to a new shape.</p> <p>TODO: review and maybe deprecate this method.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def resize(self, new_shape):\n    \"\"\"Resize the Qarray to a new shape.\n\n    TODO: review and maybe deprecate this method.\n    \"\"\"\n    dims = self.dims\n    data = jnp.resize(self.data, new_shape)\n    return Qarray.create(\n        data,\n        dims=dims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.CD","title":"<code>CD(N, beta, ts=None)</code>","text":"<p>Conditional displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>beta</code> <p>Conditional displacement amplitude.</p> required <code>ts</code> <p>Optional time sequence for hamiltonian simulation.</p> <code>None</code> <p>Returns:</p> Type Description <p>Conditional displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def CD(N, beta, ts=None):\n    \"\"\"Conditional displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        beta: Conditional displacement amplitude.\n        ts: Optional time sequence for hamiltonian simulation.\n\n    Returns:\n        Conditional displacement gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    gg = g @ g.dag()\n    ee = e @ e.dag()\n\n    gen_Ht = None\n    if ts is not None:\n        delta_t = ts[-1] - ts[0]\n        amp = 1j * beta / delta_t / 2\n        a = destroy(N)\n        gen_Ht = lambda params: lambda t: (\n            gg\n            ^ (jnp.conj(amp) * a + amp * a.dag()) + ee\n            ^ (jnp.conj(-amp) * a + (-amp) * a.dag())\n        )\n\n    return Gate.create(\n        [2, N],\n        name=\"CD\",\n        params={\"beta\": beta},\n        gen_U=lambda params: (gg ^ displace(N, params[\"beta\"] / 2))\n        + (ee ^ displace(N, -params[\"beta\"] / 2)),\n        gen_Ht=gen_Ht,\n        ts=ts,\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.CR","title":"<code>CR(N, theta)</code>","text":"<p>Conditional rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>theta</code> <p>Conditional rotation angle.</p> required <p>Returns:</p> Type Description <p>Conditional rotation gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def CR(N, theta):\n    \"\"\"Conditional rotation gate.\n\n    Args:\n        N: Hilbert space dimension.\n        theta: Conditional rotation angle.\n\n    Returns:\n        Conditional rotation gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    gg = g @ g.dag()\n    ee = e @ e.dag()\n\n\n    return Gate.create(\n        [2, N],\n        name=\"CR\",\n        params={\"theta\": theta},\n        gen_U=lambda params: (gg ^ (-1.j*theta/2*create(N)@destroy(N)).expm())\n        + (ee ^ (1.j*theta/2*create(N)@destroy(N)).expm()),\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.D","title":"<code>D(N, alpha, ts=None, c_ops=None)</code>","text":"<p>Displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>alpha</code> <p>Displacement amplitude.</p> required <code>ts</code> <p>Optional time array for hamiltonian simulation.</p> <code>None</code> <code>c_ops</code> <p>Optional collapse operators.</p> <code>None</code> <p>Returns:</p> Type Description <p>Displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def D(N, alpha, ts=None, c_ops=None):\n    \"\"\"Displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        alpha: Displacement amplitude.\n        ts: Optional time array for hamiltonian simulation.\n        c_ops: Optional collapse operators.\n\n    Returns:\n        Displacement gate.\n    \"\"\"\n    gen_Ht = None\n    if ts is not None:\n        delta_t = ts[-1] - ts[0]\n        amp = 1j * alpha / delta_t\n        a = destroy(N)\n        gen_Ht = lambda params: (lambda t: jnp.conj(amp) * a + amp * a.dag())\n\n    return Gate.create(\n        N,\n        name=\"D\",\n        params={\"alpha\": alpha},\n        gen_U=lambda params: displace(N, params[\"alpha\"]),\n        gen_Ht=gen_Ht,\n        ts=ts,\n        gen_c_ops=lambda params: Qarray.from_list([]) if c_ops is None else c_ops,\n        num_modes=1,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.ECD","title":"<code>ECD(N, beta, ts=None)</code>","text":"<p>Echoed conditional displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>beta</code> <p>Conditional displacement amplitude.</p> required <code>ts</code> <p>Optional time sequence for hamiltonian simulation.</p> <code>None</code> <p>Returns:</p> Type Description <p>Echoed conditional displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def ECD(N, beta, ts=None):\n    \"\"\"Echoed conditional displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        beta: Conditional displacement amplitude.\n        ts: Optional time sequence for hamiltonian simulation.\n\n    Returns:\n        Echoed conditional displacement gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    eg = e @ g.dag()\n    ge = g @ e.dag()\n\n    # gen_Ht = None\n    # if ts is not None:\n    #     delta_t = ts[-1] - ts[0]\n    #     amp = 1j * beta / delta_t / 2\n    #     a = destroy(N)\n    #     gen_Ht = lambda params: lambda t: (\n    #         eg\n    #         ^ (jnp.conj(amp) * a + amp * a.dag()) + ge\n    #         ^ (jnp.conj(-amp) * a + (-amp) * a.dag())\n    #     )\n\n    return Gate.create(\n        [2, N],\n        name=\"ECD\",\n        params={\"beta\": beta},\n        gen_U=lambda params: (eg ^ displace(N, params[\"beta\"] / 2))\n        + (ge ^ displace(N, -params[\"beta\"] / 2)),\n        gen_Ht=None,\n        ts=ts,\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.basis","title":"<code>basis(N, k)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert space dimension</p> required <code>k</code> <code>int</code> <p>fock number</p> required <p>Returns:</p> Type Description <p>Fock State |k&gt;</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis(N: int, k: int):\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.\n\n    Args:\n        N: Hilbert space dimension\n        k: fock number\n\n    Returns:\n        Fock State |k&gt;\n    \"\"\"\n    return Qarray.create(one_hot(k, N).reshape(N, 1))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.diag_expm","title":"<code>diag_expm(diag_matrix)</code>","text":"<p>Computes expm of a diagonal matrix efficiently (O(N) instead of O(N^3)).</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def diag_expm(diag_matrix):\n    \"\"\"Computes expm of a diagonal matrix efficiently (O(N) instead of O(N^3)).\"\"\"\n    # Extract diagonal, exponentiate elements, put back on diagonal\n    return jnp.diag(jnp.exp(jnp.diagonal(diag_matrix)))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.displace","title":"<code>displace(N, \u03b1)</code>","text":"<p>Displacement operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>\u03b1</code> <p>Phase space displacement</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Displace operator D(\u03b1)</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def displace(N, \u03b1) -&gt; Qarray:\n    \"\"\"Displacement operator\n\n    Args:\n        N: Hilbert Space Size\n        \u03b1: Phase space displacement\n\n    Returns:\n        Displace operator D(\u03b1)\n    \"\"\"\n    a = destroy(N)\n    return (\u03b1 * a.dag() - jnp.conj(\u03b1) * a).expm()\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.hadamard","title":"<code>hadamard()</code>","text":"<p>H</p> <p>Returns:</p> Name Type Description <code>H</code> <code>Qarray</code> <p>Hadamard gate</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def hadamard() -&gt; Qarray:\n    \"\"\"H\n\n    Returns:\n        H: Hadamard gate\n    \"\"\"\n    return Qarray.create(jnp.array([[1, 1], [1, -1]]) / jnp.sqrt(2))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.num","title":"<code>num(N)</code>","text":"<p>Number operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>number operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def num(N) -&gt; Qarray:\n    \"\"\"Number operator\n\n    Args:\n        N: Hilbert Space size\n\n    Returns:\n        number operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.arange(N)))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.qubit_rotation","title":"<code>qubit_rotation(theta, nx, ny, nz)</code>","text":"<p>Single qubit rotation.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>rotation angle.</p> required <code>nx</code> <p>rotation axis x component.</p> required <code>ny</code> <p>rotation axis y component.</p> required <code>nz</code> <p>rotation axis z component.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Single qubit rotation operator.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def qubit_rotation(theta: float, nx, ny, nz) -&gt; Qarray:\n    \"\"\"Single qubit rotation.\n\n    Args:\n        theta: rotation angle.\n        nx: rotation axis x component.\n        ny: rotation axis y component.\n        nz: rotation axis z component.\n\n    Returns:\n        Single qubit rotation operator.\n    \"\"\"\n    return jnp.cos(theta / 2) * identity(2) - 1j * jnp.sin(theta / 2) * (\n        nx * sigmax() + ny * sigmay() + nz * sigmaz()\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/index.html#jaxquantum.circuits.library.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <code>parallel</code> <code>bool</code> <p>if True, use parallel einsum for tensor product true: [A,B] ^ [C,D] = [A^C, B^D] false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n        parallel (bool): if True, use parallel einsum for tensor product\n            true: [A,B] ^ [C,D] = [A^C, B^D]\n            false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n\n    parallel = kwargs.pop(\"parallel\", False)\n\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    dims_0 = dims[0]\n    dims_1 = dims[1]\n    for arg in args[1:]:\n        if parallel:\n            a = data\n            b = arg.data\n\n            if len(a.shape) &gt; len(b.shape):\n                batch_dim = a.shape[:-2]\n            elif len(a.shape) == len(b.shape):\n                if prod(a.shape[:-2]) &gt; prod(b.shape[:-2]):\n                    batch_dim = a.shape[:-2]\n                else:\n                    batch_dim = b.shape[:-2]\n            else:\n                batch_dim = b.shape[:-2]\n\n            data = jnp.einsum(\"...ij,...kl-&gt;...ikjl\", a, b).reshape(\n                *batch_dim, a.shape[-2] * b.shape[-2], -1\n            )\n        else:\n            data = jnp.kron(data, arg.data, **kwargs)\n\n        dims_0 = dims_0 + arg.dims[0]\n        dims_1 = dims_1 + arg.dims[1]\n\n    return Qarray.create(data, dims=(dims_0, dims_1))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/generic.html","title":"generic","text":"<p>Generic gates.</p>"},{"location":"reference/jaxquantum/circuits/library/oscillator.html","title":"oscillator","text":"<p>Oscillator gates.</p>"},{"location":"reference/jaxquantum/circuits/library/oscillator.html#jaxquantum.circuits.library.oscillator.CD","title":"<code>CD(N, beta, ts=None)</code>","text":"<p>Conditional displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>beta</code> <p>Conditional displacement amplitude.</p> required <code>ts</code> <p>Optional time sequence for hamiltonian simulation.</p> <code>None</code> <p>Returns:</p> Type Description <p>Conditional displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def CD(N, beta, ts=None):\n    \"\"\"Conditional displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        beta: Conditional displacement amplitude.\n        ts: Optional time sequence for hamiltonian simulation.\n\n    Returns:\n        Conditional displacement gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    gg = g @ g.dag()\n    ee = e @ e.dag()\n\n    gen_Ht = None\n    if ts is not None:\n        delta_t = ts[-1] - ts[0]\n        amp = 1j * beta / delta_t / 2\n        a = destroy(N)\n        gen_Ht = lambda params: lambda t: (\n            gg\n            ^ (jnp.conj(amp) * a + amp * a.dag()) + ee\n            ^ (jnp.conj(-amp) * a + (-amp) * a.dag())\n        )\n\n    return Gate.create(\n        [2, N],\n        name=\"CD\",\n        params={\"beta\": beta},\n        gen_U=lambda params: (gg ^ displace(N, params[\"beta\"] / 2))\n        + (ee ^ displace(N, -params[\"beta\"] / 2)),\n        gen_Ht=gen_Ht,\n        ts=ts,\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/oscillator.html#jaxquantum.circuits.library.oscillator.CR","title":"<code>CR(N, theta)</code>","text":"<p>Conditional rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>theta</code> <p>Conditional rotation angle.</p> required <p>Returns:</p> Type Description <p>Conditional rotation gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def CR(N, theta):\n    \"\"\"Conditional rotation gate.\n\n    Args:\n        N: Hilbert space dimension.\n        theta: Conditional rotation angle.\n\n    Returns:\n        Conditional rotation gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    gg = g @ g.dag()\n    ee = e @ e.dag()\n\n\n    return Gate.create(\n        [2, N],\n        name=\"CR\",\n        params={\"theta\": theta},\n        gen_U=lambda params: (gg ^ (-1.j*theta/2*create(N)@destroy(N)).expm())\n        + (ee ^ (1.j*theta/2*create(N)@destroy(N)).expm()),\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/oscillator.html#jaxquantum.circuits.library.oscillator.D","title":"<code>D(N, alpha, ts=None, c_ops=None)</code>","text":"<p>Displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>alpha</code> <p>Displacement amplitude.</p> required <code>ts</code> <p>Optional time array for hamiltonian simulation.</p> <code>None</code> <code>c_ops</code> <p>Optional collapse operators.</p> <code>None</code> <p>Returns:</p> Type Description <p>Displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def D(N, alpha, ts=None, c_ops=None):\n    \"\"\"Displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        alpha: Displacement amplitude.\n        ts: Optional time array for hamiltonian simulation.\n        c_ops: Optional collapse operators.\n\n    Returns:\n        Displacement gate.\n    \"\"\"\n    gen_Ht = None\n    if ts is not None:\n        delta_t = ts[-1] - ts[0]\n        amp = 1j * alpha / delta_t\n        a = destroy(N)\n        gen_Ht = lambda params: (lambda t: jnp.conj(amp) * a + amp * a.dag())\n\n    return Gate.create(\n        N,\n        name=\"D\",\n        params={\"alpha\": alpha},\n        gen_U=lambda params: displace(N, params[\"alpha\"]),\n        gen_Ht=gen_Ht,\n        ts=ts,\n        gen_c_ops=lambda params: Qarray.from_list([]) if c_ops is None else c_ops,\n        num_modes=1,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/oscillator.html#jaxquantum.circuits.library.oscillator.ECD","title":"<code>ECD(N, beta, ts=None)</code>","text":"<p>Echoed conditional displacement gate.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space dimension.</p> required <code>beta</code> <p>Conditional displacement amplitude.</p> required <code>ts</code> <p>Optional time sequence for hamiltonian simulation.</p> <code>None</code> <p>Returns:</p> Type Description <p>Echoed conditional displacement gate.</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def ECD(N, beta, ts=None):\n    \"\"\"Echoed conditional displacement gate.\n\n    Args:\n        N: Hilbert space dimension.\n        beta: Conditional displacement amplitude.\n        ts: Optional time sequence for hamiltonian simulation.\n\n    Returns:\n        Echoed conditional displacement gate.\n    \"\"\"\n    g = basis(2, 0)\n    e = basis(2, 1)\n\n    eg = e @ g.dag()\n    ge = g @ e.dag()\n\n    # gen_Ht = None\n    # if ts is not None:\n    #     delta_t = ts[-1] - ts[0]\n    #     amp = 1j * beta / delta_t / 2\n    #     a = destroy(N)\n    #     gen_Ht = lambda params: lambda t: (\n    #         eg\n    #         ^ (jnp.conj(amp) * a + amp * a.dag()) + ge\n    #         ^ (jnp.conj(-amp) * a + (-amp) * a.dag())\n    #     )\n\n    return Gate.create(\n        [2, N],\n        name=\"ECD\",\n        params={\"beta\": beta},\n        gen_U=lambda params: (eg ^ displace(N, params[\"beta\"] / 2))\n        + (ge ^ displace(N, -params[\"beta\"] / 2)),\n        gen_Ht=None,\n        ts=ts,\n        num_modes=2,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/oscillator.html#jaxquantum.circuits.library.oscillator.diag_expm","title":"<code>diag_expm(diag_matrix)</code>","text":"<p>Computes expm of a diagonal matrix efficiently (O(N) instead of O(N^3)).</p> Source code in <code>jaxquantum/circuits/library/oscillator.py</code> <pre><code>def diag_expm(diag_matrix):\n    \"\"\"Computes expm of a diagonal matrix efficiently (O(N) instead of O(N^3)).\"\"\"\n    # Extract diagonal, exponentiate elements, put back on diagonal\n    return jnp.diag(jnp.exp(jnp.diagonal(diag_matrix)))\n</code></pre>"},{"location":"reference/jaxquantum/circuits/library/qubit.html","title":"qubit","text":"<p>qubit gates.</p>"},{"location":"reference/jaxquantum/codes/index.html","title":"codes","text":"<p>Bosonic Code Qubits</p>"},{"location":"reference/jaxquantum/codes/base.html","title":"base","text":"<p>Base Bosonic Qubit Class</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit","title":"<code>BosonicQubit</code>","text":"<p>Base class for Bosonic Qubits.</p> Source code in <code>jaxquantum/codes/base.py</code> <pre><code>class BosonicQubit(metaclass=ABCMeta):\n    \"\"\"\n    Base class for Bosonic Qubits.\n    \"\"\"\n\n    name = \"bqubit\"\n\n    @property\n    def _non_device_params(self):\n        \"\"\"\n        Can be overriden in child classes.\n        \"\"\"\n        return [\"N\"]\n\n    def __init__(self, params: Optional[Dict[str, float]] = None, name: str = None):\n        if name is not None:\n            self.name = name\n\n        self.params = params if params else {}\n        self._params_validation()\n\n        self.params = device_put_params(self.params, self._non_device_params)\n\n        self.common_gates: Dict[str, jqt.Qarray] = {}\n        self._gen_common_gates()\n\n        self.wigner_pts = jnp.linspace(-4.5, 4.5, 61)\n\n        self.basis = self._get_basis_states()\n\n        for basis_state in [\"+x\", \"-x\", \"+y\", \"-y\", \"+z\", \"-z\"]:\n            assert basis_state in self.basis, (\n                f\"Please set the {basis_state} basis state.\"\n            )\n\n    def _params_validation(self):\n        \"\"\"\n        Override this method to add additional validation to params.\n\n        E.g.\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n        \"\"\"\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n\n    def _gen_common_gates(self):\n        \"\"\"\n        Override this method to add additional common gates.\n\n        E.g.\n        if \"N\" not in self.params:\n            self.params[\"N\"] = 50\n        \"\"\"\n        N = self.params[\"N\"]\n        self.common_gates[\"a_dag\"] = jqt.create(N)\n        self.common_gates[\"a\"] = jqt.destroy(N)\n\n    @abstractmethod\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Returns:\n            plus_z (jqt.Qarray), minus_z (jqt.Qarray): z basis states\n        \"\"\"\n\n    def _get_basis_states(self) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        plus_z, minus_z = self._get_basis_z()\n        return self._gen_basis_states_from_z(plus_z, minus_z)\n\n    def _gen_basis_states_from_z(\n        self, plus_z: jqt.Qarray, minus_z: jqt.Qarray\n    ) -&gt; Dict[str, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt; from |+-z&gt;\n        \"\"\"\n        basis: Dict[str, jqt.Qarray] = {}\n\n        # import to make sure that each basis state is a column vec\n        # otherwise, transposing a 1D vector will do nothing\n\n        basis[\"+z\"] = plus_z\n        basis[\"-z\"] = minus_z\n\n        basis[\"+x\"] = jqt.unit(basis[\"+z\"] + basis[\"-z\"])\n        basis[\"-x\"] = jqt.unit(basis[\"+z\"] - basis[\"-z\"])\n        basis[\"+y\"] = jqt.unit(basis[\"+z\"] + 1j * basis[\"-z\"])\n        basis[\"-y\"] = jqt.unit(basis[\"+z\"] - 1j * basis[\"-z\"])\n        return basis\n\n    def jqt2qt(self, state):\n        return jqt.jqt2qt(state)\n\n    # gates\n    # ======================================================\n    # @abstractmethod\n    # def stabilize(self) -&gt; None:\n    #     \"\"\"\n    #     Stabilizing/measuring syndromes.\n    #     \"\"\"\n\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical X unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"x\")\n\n    @property\n    def x_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical X hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Y unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"y\")\n\n    @property\n    def y_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Y hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Z unitary gate.\n        \"\"\"\n        return self._gen_pauli_U(\"z\")\n\n    @property\n    def z_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Z hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def h_H(self) -&gt; Optional[jqt.Qarray]:\n        \"\"\"\n        Logical Hadamard hamiltonian.\n        \"\"\"\n        return None\n\n    @property\n    def h_U(self) -&gt; jqt.Qarray:\n        \"\"\"\n        Logical Hadamard unitary gate.\n        \"\"\"\n        return (\n            self.basis[\"+x\"] @ self.basis[\"+z\"].dag()\n            + self.basis[\"-x\"] @ self.basis[\"-z\"].dag()\n        )\n\n    def _gen_pauli_U(self, basis_state: str) -&gt; jqt.Qarray:\n        \"\"\"\n        Generates unitary for Pauli X, Y, Z.\n\n        Args:\n            basis_state (str): \"x\", \"y\", \"z\"\n\n        Returns:\n            U (jqt.Qarray): Pauli unitary\n        \"\"\"\n        H = getattr(self, basis_state + \"_H\")\n        if H is not None:\n            return jqt.expm(1.0j * H)\n\n        gate = (\n            self.basis[\"+\" + basis_state] @ self.basis[\"+\" + basis_state].dag()\n            - self.basis[\"-\" + basis_state] @ self.basis[\"-\" + basis_state].dag()\n        )\n\n        return gate\n\n    @property\n    def projector(self):\n        return (\n            self.basis[\"+z\"] @ self.basis[\"+z\"].dag()\n            + self.basis[\"-z\"] @ self.basis[\"-z\"].dag()\n        )\n\n    @property\n    def maximally_mixed_state(self):\n        return (1 / 2.0) * self.projector\n\n    # Plotting\n    # ======================================================\n    def _prepare_state_plot(self, state):\n        \"\"\"\n        Can be overriden.\n\n        E.g. in the case of cavity x transmon system\n        return qt.ptrace(state, 0)\n        \"\"\"\n        return state\n\n    def plot(self, state, ax=None, qp_type=jqt.WIGNER, **kwargs) -&gt; None:\n        if ax is None:\n            fig, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n        fig = ax.get_figure()\n\n        if qp_type == jqt.WIGNER:\n            vmin = -1\n            vmax = 1\n        elif qp_type == jqt.QFUNC:\n            vmin = 0\n            vmax = 1\n\n        w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n\n        ax.set_title(qp_type.capitalize() + \" Quasi-Probability Dist.\")\n        ticks = np.linspace(vmin, vmax, 5)\n        fig.colorbar(w_plt, ax=ax, ticks=ticks)\n        ax.set_xlabel(r\"Re$(\\alpha)$\")\n        ax.set_ylabel(r\"Im$(\\alpha)$\")\n        fig.tight_layout()\n\n        plt.show()\n\n    def _plot_single(self, state, ax=None, contour=True, qp_type=jqt.WIGNER):\n        \"\"\"\n        Assumes state has same dims as initial_state.\n        \"\"\"\n\n        if ax is None:\n            _, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n\n        return jqt.plot_qp(\n            state, self.wigner_pts, axs=ax, contour=contour, qp_type=qp_type\n        )\n\n    def plot_code_states(self, qp_type: str = jqt.WIGNER, **kwargs):\n        \"\"\"\n        Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.\n\n        Args:\n            qp_type (str):\n                WIGNER or QFUNC\n\n        Return:\n            axs: Axes\n        \"\"\"\n        fig, axs = plt.subplots(2, 3, figsize=(12, 6), dpi=200)\n\n        for i, label in enumerate([\"+z\", \"+x\", \"+y\", \"-z\", \"-x\", \"-y\"]):\n            state = self._prepare_state_plot(self.basis[label])\n            pos = (i // 3, i % 3)\n            ax = axs[pos]\n            _, w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n            ax.set_title(f\"|{label}\" + r\"$\\rangle$\")\n            ax.set_xlabel(r\"Re[$\\alpha$]\")\n            ax.set_ylabel(r\"Im[$\\alpha$]\")\n\n        fig.suptitle(self.name)\n        fig.tight_layout()\n        fig.align_xlabels(axs)\n        fig.align_ylabels(axs)\n\n        fig.tight_layout()\n        plt.show()\n</code></pre>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.h_H","title":"<code>h_H</code>  <code>property</code>","text":"<p>Logical Hadamard hamiltonian.</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.h_U","title":"<code>h_U</code>  <code>property</code>","text":"<p>Logical Hadamard unitary gate.</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.x_H","title":"<code>x_H</code>  <code>property</code>","text":"<p>Logical X hamiltonian.</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.x_U","title":"<code>x_U</code>  <code>property</code>","text":"<p>Logical X unitary gate.</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.y_H","title":"<code>y_H</code>  <code>property</code>","text":"<p>Logical Y hamiltonian.</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.y_U","title":"<code>y_U</code>  <code>property</code>","text":"<p>Logical Y unitary gate.</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.z_H","title":"<code>z_H</code>  <code>property</code>","text":"<p>Logical Z hamiltonian.</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.z_U","title":"<code>z_U</code>  <code>property</code>","text":"<p>Logical Z unitary gate.</p>"},{"location":"reference/jaxquantum/codes/base.html#jaxquantum.codes.base.BosonicQubit.plot_code_states","title":"<code>plot_code_states(qp_type=jqt.WIGNER, **kwargs)</code>","text":"<p>Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.</p> <p>Parameters:</p> Name Type Description Default <code>qp_type</code> <code>str</code> <p>WIGNER or QFUNC</p> <code>WIGNER</code> Return <p>axs: Axes</p> Source code in <code>jaxquantum/codes/base.py</code> <pre><code>def plot_code_states(self, qp_type: str = jqt.WIGNER, **kwargs):\n    \"\"\"\n    Plot |\u00b1x\u27e9, |\u00b1y\u27e9, |\u00b1z\u27e9 code states.\n\n    Args:\n        qp_type (str):\n            WIGNER or QFUNC\n\n    Return:\n        axs: Axes\n    \"\"\"\n    fig, axs = plt.subplots(2, 3, figsize=(12, 6), dpi=200)\n\n    for i, label in enumerate([\"+z\", \"+x\", \"+y\", \"-z\", \"-x\", \"-y\"]):\n        state = self._prepare_state_plot(self.basis[label])\n        pos = (i // 3, i % 3)\n        ax = axs[pos]\n        _, w_plt = self._plot_single(state, ax=ax, qp_type=qp_type, **kwargs)\n        ax.set_title(f\"|{label}\" + r\"$\\rangle$\")\n        ax.set_xlabel(r\"Re[$\\alpha$]\")\n        ax.set_ylabel(r\"Im[$\\alpha$]\")\n\n    fig.suptitle(self.name)\n    fig.tight_layout()\n    fig.align_xlabels(axs)\n    fig.align_ylabels(axs)\n\n    fig.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"reference/jaxquantum/codes/binomial.html","title":"binomial","text":"<p>Cat Code Qubit</p>"},{"location":"reference/jaxquantum/codes/binomial.html#jaxquantum.codes.binomial.BinomialQubit","title":"<code>BinomialQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>Cat Qubit Class.</p> Source code in <code>jaxquantum/codes/binomial.py</code> <pre><code>class BinomialQubit(BosonicQubit):\n    \"\"\"\n    Cat Qubit Class.\n    \"\"\"\n\n    name = \"binomial\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n        # notation https://arxiv.org/pdf/2010.08699.pdf\n        if \"L\" not in self.params:\n            self.params[\"L\"] = 1\n        if \"G\" not in self.params:\n            self.params[\"G\"] = 0\n        if \"D\" not in self.params:\n            self.params[\"D\"] = 0\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = self.params[\"N\"]\n\n        L = self.params[\"L\"]\n        G = self.params[\"G\"]\n        D = self.params[\"D\"]\n\n        S = L + G\n\n        M = jnp.max(jnp.array([L, G, 2 * D]))\n\n        def plus_z_gen(p):\n            C = comb(M + 1, p)\n            return jnp.sqrt(C) * jqt.basis(N, p * (S + 1)).data\n\n        plus_z = jnp.sum(vmap(plus_z_gen)(jnp.arange(0, M + 2, 2)), axis=0)\n        plus_z = jqt.unit(jqt.Qarray.create(plus_z))\n\n        def minus_z_gen(p):\n            C = comb(M + 1, p)\n            return jnp.sqrt(C) * jqt.basis(N, p * (S + 1)).data\n\n        minus_z = jnp.sum(vmap(minus_z_gen)(jnp.arange(1, M + 2, 2)), axis=0)\n        minus_z = jqt.unit(jqt.Qarray.create(minus_z))\n\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/jaxquantum/codes/cat.html","title":"cat","text":"<p>Cat Code Qubit</p>"},{"location":"reference/jaxquantum/codes/cat.html#jaxquantum.codes.cat.CatQubit","title":"<code>CatQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>Cat Qubit Class.</p> Source code in <code>jaxquantum/codes/cat.py</code> <pre><code>class CatQubit(BosonicQubit):\n    \"\"\"\n    Cat Qubit Class.\n    \"\"\"\n\n    name = \"cat\"\n\n    @property\n    def _non_device_params(self):\n        param_list = super()._non_device_params\n        param_list.append(\"alpha\")\n        return param_list\n\n    def _params_validation(self):\n        super()._params_validation()\n        if \"alpha\" not in self.params:\n            self.params[\"alpha\"] = 2\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = self.params[\"N\"]\n        a = self.params[\"alpha\"]\n        plus_z = jqt.unit(jqt.coherent(N, a) + jqt.coherent(N, -1.0 * a))\n        minus_z = jqt.unit(jqt.coherent(N, 1.0j * a) + jqt.coherent(N, -1.0j * a))\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/jaxquantum/codes/gkp.html","title":"gkp","text":"<p>Cat Code Qubit</p>"},{"location":"reference/jaxquantum/codes/gkp.html#jaxquantum.codes.gkp.GKPQubit","title":"<code>GKPQubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>GKP Qubit Class.</p> Source code in <code>jaxquantum/codes/gkp.py</code> <pre><code>class GKPQubit(BosonicQubit):\n    \"\"\"\n    GKP Qubit Class.\n    \"\"\"\n\n    name = \"gkp\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n        if \"delta\" not in self.params:\n            self.params[\"delta\"] = 0.25\n        self.params[\"l\"] = 2.0 * jnp.sqrt(jnp.pi)\n        s_delta = jnp.sinh(self.params[\"delta\"] ** 2)\n        self.params[\"epsilon\"] = s_delta * self.params[\"l\"]\n        self.params[\"squeezing\"] = jnp.log(self.params[\"delta\"])\n        self.params[\"squeezing_dB\"] = 20*jnp.log10(jnp.exp(jnp.abs(self.params[\"squeezing\"])))\n\n    def _gen_common_gates(self) -&gt; None:\n        \"\"\"\n        Overriding this method to add additional common gates.\n        \"\"\"\n        super()._gen_common_gates()\n\n        # phase space\n        self.common_gates[\"x\"] = (\n            self.common_gates[\"a_dag\"] + self.common_gates[\"a\"]\n        ) / jnp.sqrt(2.0)\n        self.common_gates[\"p\"] = (\n            1.0j * (self.common_gates[\"a_dag\"] - self.common_gates[\"a\"]) / jnp.sqrt(2.0)\n        )\n\n        # finite energy\n        self.common_gates[\"E\"] = jqt.expm(\n            -(self.params[\"delta\"] ** 2)\n            * self.common_gates[\"a_dag\"]\n            @ self.common_gates[\"a\"]\n        )\n        self.common_gates[\"E_inv\"] = jqt.expm(\n            self.params[\"delta\"] ** 2\n            * self.common_gates[\"a_dag\"]\n            @ self.common_gates[\"a\"]\n        )\n\n        # axis\n        x_axis, z_axis = self._get_axis()\n        y_axis = x_axis + z_axis\n\n        # gates\n        X_0 = jqt.expm(1.0j * self.params[\"l\"] / 2.0 * z_axis)\n        Z_0 = jqt.expm(1.0j * self.params[\"l\"] / 2.0 * x_axis)\n        Y_0 = 1.0j * X_0 @ Z_0\n        self.common_gates[\"X_0\"] = X_0\n        self.common_gates[\"Z_0\"] = Z_0\n        self.common_gates[\"Y_0\"] = Y_0\n        self.common_gates[\"X\"] = self._make_op_finite_energy(X_0)\n        self.common_gates[\"Z\"] = self._make_op_finite_energy(Z_0)\n        self.common_gates[\"Y\"] = self._make_op_finite_energy(Y_0)\n\n        # symmetric stabilizers and gates\n        self.common_gates[\"Z_s_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] / 2.0 * x_axis\n        )\n        self.common_gates[\"S_x_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * z_axis\n        )\n        self.common_gates[\"S_z_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * x_axis\n        )\n        self.common_gates[\"S_y_0\"] = self._symmetrized_expm(\n            1.0j * self.params[\"l\"] * y_axis\n        )\n\n    @staticmethod\n    def _q_quadrature(q_points, n):\n        q_points = q_points.T\n\n        F_0_init = jnp.ones_like(q_points)\n        F_1_init = jnp.sqrt(2) * q_points\n\n        def scan_body(n, carry):\n            F_0, F_1 = carry\n            F_n = (jnp.sqrt(2 / n) * lax.mul(q_points, F_1) - jnp.sqrt(\n                (n - 1) / n) * F_0)\n\n            new_carry = (F_1, F_n)\n\n            return new_carry\n\n        initial_carry = (F_0_init, F_1_init)\n        final_carry = lax.fori_loop(2, jnp.max(jnp.array([n + 1, 2])),\n                                    scan_body, initial_carry)\n\n        q_quad = lax.select(n == 0, F_0_init,\n                            lax.select(n == 1, F_1_init,\n                                       final_carry[1]))\n\n        q_quad = jnp.pi ** (-0.25) * lax.mul(\n            jnp.exp(-lax.pow(q_points, 2) / 2), q_quad)\n\n        return q_quad\n\n    @staticmethod\n    def _compute_gkp_basis_z(delta, dim, mu, series_trunc=100):\n        \"\"\"\n        Args:\n            mu: state index (0 or 1)\n\n        Returns:\n            GKP basis state\n\n        Adapted from code by Lev-Arcady Sellem &lt;lev-arcady.sellem@inria.fr&gt;\n        \"\"\"\n\n        # We choose the truncation of our series summation such that we\n        # capture 6 sigmas of the envelope for a value of delta of 0.02.\n        # delta * (truncat_series*2*sqrt(pi)) = 6\n\n\n        q_points = jnp.sqrt(jnp.pi) * (2 * jnp.arange(series_trunc) + mu)\n\n        def compute_pop(n):\n            quadvals = GKPQubit._q_quadrature(q_points, n)\n            return jnp.exp(-(delta ** 2) * n) * (\n                    2 * jnp.sum(quadvals) - (1 - mu) * quadvals[0])\n\n        psi_even = vmap(compute_pop)(jnp.arange(0, dim, 2))\n\n        psi = jnp.zeros(2 * psi_even.size, dtype=psi_even.dtype)\n\n        psi = psi.at[::2].set(psi_even)\n\n        psi = jqt.Qarray.create(jnp.array(psi)[:dim])\n\n        return psi.unit()\n\n\n    @staticmethod\n    def _check_delta_warning(d):\n        if d &lt; 0.02:\n            warnings.warn(\"State preparation with delta values lower than 0.02 might lead to loss of accuracy.\")\n\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-z&gt;.\n        \"\"\"\n\n        delta = self.params[\"delta\"]\n        dim = self.params[\"N\"]\n\n        debug.callback(GKPQubit._check_delta_warning, delta)\n\n        jitted_compute_gkp_basis_z = jit(self._compute_gkp_basis_z, \n                                         static_argnames=(\"dim\",))\n\n        plus_z = jitted_compute_gkp_basis_z(delta, dim, 0)\n        minus_z = jitted_compute_gkp_basis_z(delta, dim, 1)\n\n        return plus_z, minus_z\n\n    # utils\n    # ======================================================\n    def _get_axis(self):\n        x_axis = self.common_gates[\"x\"]\n        z_axis = -self.common_gates[\"p\"]\n        return x_axis, z_axis\n\n    def _make_op_finite_energy(self, op):\n        return self.common_gates[\"E\"] @ op @ self.common_gates[\"E_inv\"]\n\n    def _symmetrized_expm(self, op):\n        return (jqt.expm(op) + jqt.expm(-1.0 * op)) / 2.0\n\n    # gates\n    # ======================================================\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"X\"]\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"Y\"]\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        return self.common_gates[\"Z\"]\n</code></pre>"},{"location":"reference/jaxquantum/codes/mode.html","title":"mode","text":"<p>Generic Bosonic Mode Class</p>"},{"location":"reference/jaxquantum/codes/mode.html#jaxquantum.codes.mode.BosonicMode","title":"<code>BosonicMode</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>FockQubit</p> Source code in <code>jaxquantum/codes/mode.py</code> <pre><code>class BosonicMode(BosonicQubit):\n    \"\"\"\n    FockQubit\n    \"\"\"\n\n    def _params_validation(self):\n        super()._params_validation()\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = int(self.params[\"N\"])\n        plus_z = jqt.basis(N, 0)\n        minus_z = jqt.basis(N, 1)\n        return plus_z, minus_z\n</code></pre>"},{"location":"reference/jaxquantum/codes/qubit.html","title":"qubit","text":"<p>Qubit</p>"},{"location":"reference/jaxquantum/codes/qubit.html#jaxquantum.codes.qubit.Qubit","title":"<code>Qubit</code>","text":"<p>               Bases: <code>BosonicQubit</code></p> <p>FockQubit</p> Source code in <code>jaxquantum/codes/qubit.py</code> <pre><code>class Qubit(BosonicQubit):\n    \"\"\"\n    FockQubit\n    \"\"\"\n\n    def _params_validation(self):\n        super()._params_validation()\n        self.params[\"N\"] = 2\n\n    def _get_basis_z(self) -&gt; Tuple[jqt.Qarray, jqt.Qarray]:\n        \"\"\"\n        Construct basis states |+-x&gt;, |+-y&gt;, |+-z&gt;\n        \"\"\"\n        N = int(self.params[\"N\"])\n        plus_z = jqt.basis(N, 0)\n        minus_z = jqt.basis(N, 1)\n        return plus_z, minus_z\n\n    @property\n    def x_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmax()\n\n    @property\n    def y_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmay()\n\n    @property\n    def z_U(self) -&gt; jqt.Qarray:\n        return jqt.sigmaz()\n\n    def plot(self, state, ax=None, qp_type=\"\", **kwargs) -&gt; None:\n        state = self.jqt2qt(state)\n        with warnings.catch_warnings():\n            # TODO: suppressing deprecation warnings, deal with this\n            warnings.simplefilter(\"ignore\")\n            b = qt.Bloch()\n            b.add_states(state)\n            b.render()\n            b.show()\n            plt.tight_layout()\n            plt.show()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html","title":"core","text":"<p>Quantum Tooling</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray","title":"<code>Qarray</code>","text":"Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@struct.dataclass  # this allows us to send in and return Qarray from jitted functions\nclass Qarray:\n    _data: Array\n    _qdims: Qdims = struct.field(pytree_node=False)\n    _bdims: tuple[int] = struct.field(pytree_node=False)\n\n    # Initialization ----\n    @classmethod\n    def create(cls, data, dims=None, bdims=None):\n        # Step 1: Prepare data ----\n        data = jnp.asarray(data)\n\n        if len(data.shape) == 1 and data.shape[0] &gt; 0:\n            data = data.reshape(data.shape[0], 1)\n\n        if len(data.shape) &gt;= 2:\n            if data.shape[-2] != data.shape[-1] and not (\n                data.shape[-2] == 1 or data.shape[-1] == 1\n            ):\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n\n        if bdims is not None:\n            if len(data.shape) - len(bdims) == 1:\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n        # ----\n\n        # Step 2: Prepare dimensions ----\n        if bdims is None:\n            bdims = tuple(data.shape[:-2])\n\n        if dims is None:\n            dims = ((data.shape[-2],), (data.shape[-1],))\n\n        if not isinstance(dims[0], (list, tuple)):\n            # This handles the case where only the hilbert space dimensions are sent in.\n            if data.shape[-1] == 1:\n                dims = (tuple(dims), tuple([1 for _ in dims]))\n            elif data.shape[-2] == 1:\n                dims = (tuple([1 for _ in dims]), tuple(dims))\n            else:\n                dims = (tuple(dims), tuple(dims))\n        else:\n            dims = (tuple(dims[0]), tuple(dims[1]))\n\n        check_dims(dims, bdims, data.shape)\n\n        qdims = Qdims(dims)\n\n        # NOTE: Constantly tidying up on Qarray creation might be a bit overkill.\n        # It increases the compilation time, but only very slightly\n        # increased the runtime of the jit compiled function.\n        # We could instead use this tidy_up where we think we need it.\n        data = tidy_up(data, SETTINGS[\"auto_tidyup_atol\"])\n\n        return cls(data, qdims, bdims)\n\n    # ----\n\n    @classmethod\n    def from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n        \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n        data = jnp.array([qarr.data for qarr in qarr_list])\n\n        if len(qarr_list) == 0:\n            dims = ((), ())\n            bdims = ()\n        else:\n            dims = qarr_list[0].dims\n            bdims = qarr_list[0].bdims\n\n        if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n            raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n        bdims = (len(qarr_list),) + bdims\n\n        return cls.create(data, dims=dims, bdims=bdims)\n\n    @classmethod\n    def from_array(cls, qarr_arr) -&gt; Qarray:\n        \"\"\"Create a Qarray from a nested list of Qarrays.\n\n        Args:\n            qarr_arr (list): nested list of Qarrays\n\n        Returns:\n            Qarray: Qarray object\n        \"\"\"\n        if isinstance(qarr_arr, Qarray):\n            return qarr_arr\n\n        bdims = ()\n        lvl = qarr_arr\n        while not isinstance(lvl, Qarray):\n            bdims = bdims + (len(lvl),)\n            if len(lvl) &gt; 0:\n                lvl = lvl[0]\n            else:\n                break\n\n        def flat(lis):\n            flatList = []\n            for element in lis:\n                if type(element) is list:\n                    flatList += flat(element)\n                else:\n                    flatList.append(element)\n            return flatList\n\n        qarr_list = flat(qarr_arr)\n        qarr = cls.from_list(qarr_list)\n        qarr = qarr.reshape_bdims(*bdims)\n        return qarr\n\n    # Properties ----\n    @property\n    def qtype(self):\n        return self._qdims.qtype\n\n    @property\n    def dtype(self):\n        return self._data.dtype\n\n    @property\n    def dims(self):\n        return self._qdims.dims\n\n    @property\n    def bdims(self):\n        return self._bdims\n\n    @property\n    def qdims(self):\n        return self._qdims\n\n    @property\n    def space_dims(self):\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return self.dims[0]\n        elif self.qtype == Qtypes.bra:\n            return self.dims[1]\n        else:\n            # TODO: not reached for some reason\n            raise ValueError(\"Unsupported qtype.\")\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def shaped_data(self):\n        return self._data.reshape(self.bdims + self.dims[0] + self.dims[1])\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def is_batched(self):\n        return len(self.bdims) &gt; 0\n\n    def __getitem__(self, index):\n        if len(self.bdims) &gt; 0:\n            return Qarray.create(\n                self.data[index],\n                dims=self.dims,\n            )\n        else:\n            raise ValueError(\"Cannot index a non-batched Qarray.\")\n\n    def reshape_bdims(self, *args):\n        \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n        new_bdims = tuple(args)\n\n        if prod(new_bdims) == 0:\n            new_shape = new_bdims\n        else:\n            new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n        return Qarray.create(\n            self.data.reshape(new_shape),\n            dims=self.dims,\n            bdims=new_bdims,\n        )\n\n    def space_to_qdims(self, space_dims: List[int]):\n        if isinstance(space_dims[0], (list, tuple)):\n            return space_dims\n\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return (tuple(space_dims), tuple([1 for _ in range(len(space_dims))]))\n        elif self.qtype == Qtypes.bra:\n            return (tuple([1 for _ in range(len(space_dims))]), tuple(space_dims))\n        else:\n            raise ValueError(\"Unsupported qtype for space_to_qdims conversion.\")\n\n    def reshape_qdims(self, *args):\n        \"\"\"Reshape the quantum dimensions of the Qarray.\n\n        Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n        Args:\n            *args: new Hilbert dimensions for the Qarray.\n\n        Returns:\n            Qarray: reshaped Qarray.\n        \"\"\"\n\n        new_space_dims = tuple(args)\n        current_space_dims = self.space_dims\n        assert prod(new_space_dims) == prod(current_space_dims)\n\n        new_qdims = self.space_to_qdims(new_space_dims)\n        new_bdims = self.bdims\n\n        return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n\n    def resize(self, new_shape):\n        \"\"\"Resize the Qarray to a new shape.\n\n        TODO: review and maybe deprecate this method.\n        \"\"\"\n        dims = self.dims\n        data = jnp.resize(self.data, new_shape)\n        return Qarray.create(\n            data,\n            dims=dims,\n        )\n\n    def __len__(self):\n        \"\"\"Length of the Qarray.\"\"\"\n        if len(self.bdims) &gt; 0:\n            return self.data.shape[0]\n        else:\n            raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Qarray):\n            raise ValueError(\"Cannot calculate equality of a Qarray with a non-Qarray.\")\n\n        if self.dims != other.dims:\n            return False\n\n        if self.bdims != other.bdims:\n            return False\n\n        return jnp.all(self.data == other.data)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # ----\n\n    # Elementary Math ----\n    def __matmul__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        _qdims_new = self._qdims @ other._qdims\n        return Qarray.create(\n            self.data @ other.data,\n            dims=_qdims_new.dims,\n        )\n\n    # NOTE: not possible to reach this.\n    # def __rmatmul__(self, other):\n    #     if not isinstance(other, Qarray):\n    #         return NotImplemented\n\n    #     _qdims_new = other._qdims @ self._qdims\n    #     return Qarray.create(\n    #         other.data @ self.data,\n    #         dims=_qdims_new.dims,\n    #     )\n\n    def __mul__(self, other):\n        if isinstance(other, Qarray):\n            return self.__matmul__(other)\n\n        other = other + 0.0j\n        if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n            other = other.reshape(other.shape + (1, 1))\n\n        return Qarray.create(\n            other * self.data,\n            dims=self._qdims.dims,\n        )\n\n    def __rmul__(self, other):\n        # NOTE: not possible to reach this.\n        # if isinstance(other, Qarray):\n        #     return self.__rmatmul__(other)\n\n        return self.__mul__(other)\n\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    def __truediv__(self, other):\n        \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n        if isinstance(other, Qarray):\n            raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n        return self.__mul__(1 / other)\n\n    def __add__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data + other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__add__(other)\n\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data - other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__sub__(other)\n\n        return NotImplemented\n\n    def __rsub__(self, other):\n        return self.__neg__().__add__(other)\n\n    def __xor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(self, other)\n\n    def __rxor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(other, self)\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n\n        return powm(self, other)\n\n    # ----\n\n    # String Representation ----\n    def _str_header(self):\n        out = \", \".join(\n            [\n                \"Quantum array: dims = \" + str(self.dims),\n                \"bdims = \" + str(self.bdims),\n                \"shape = \" + str(self._data.shape),\n                \"type = \" + str(self.qtype),\n            ]\n        )\n        return out\n\n    def __str__(self):\n        return self._str_header() + \"\\nQarray data =\\n\" + str(self.data)\n\n    @property\n    def header(self):\n        \"\"\"Print the header of the Qarray.\"\"\"\n        return self._str_header()\n\n    def __repr__(self):\n        return self.__str__()\n\n    # ----\n\n    # Utilities ----\n    def copy(self, memo=None):\n        # return Qarray.create(deepcopy(self.data), dims=self.dims)\n        return self.__deepcopy__(memo)\n\n    def __deepcopy__(self, memo):\n        \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n        return Qarray(\n            _data=deepcopy(self._data, memo=memo),\n            _qdims=deepcopy(self._qdims, memo=memo),\n            _bdims=deepcopy(self._bdims, memo=memo),\n        )\n\n    def __getattr__(self, method_name):\n        if \"__\" == method_name[:2]:\n            # NOTE: we return NotImplemented for binary special methods logic in python, plus things like __jax_array__\n            return lambda *args, **kwargs: NotImplemented\n\n        modules = [jnp, jnp.linalg, jsp, jsp.linalg]\n\n        method_f = None\n        for mod in modules:\n            method_f = getattr(mod, method_name, None)\n            if method_f is not None:\n                break\n\n        if method_f is None:\n            raise NotImplementedError(\n                f\"Method {method_name} does not exist. No backup method found in {modules}.\"\n            )\n\n        def func(*args, **kwargs):\n            res = method_f(self.data, *args, **kwargs)\n\n            if getattr(res, \"shape\", None) is None or res.shape != self.data.shape:\n                return res\n            else:\n                return Qarray.create(res, dims=self._qdims.dims)\n\n        return func\n\n    # ----\n\n    # Conversions / Reshaping ----\n    def dag(self):\n        return dag(self)\n\n    def to_dm(self):\n        return ket2dm(self)\n\n    def is_dm(self):\n        return self.qtype == Qtypes.oper\n\n    def is_vec(self):\n        return self.qtype == Qtypes.ket or self.qtype == Qtypes.bra\n\n    def to_ket(self):\n        return to_ket(self)\n\n    def transpose(self, *args):\n        return transpose(self, *args)\n\n    def keep_only_diag_elements(self):\n        return keep_only_diag_elements(self)\n\n    # ----\n\n    # Math Functions ----\n    def unit(self):\n        return unit(self)\n\n    def norm(self):\n        return norm(self)\n\n    def expm(self):\n        return expm(self)\n\n    def powm(self, n):\n        return powm(self, n)\n\n    def cosm(self):\n        return cosm(self)\n\n    def sinm(self):\n        return sinm(self)\n\n    def tr(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def trace(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def ptrace(self, indx):\n        return ptrace(self, indx)\n\n    def eigenstates(self):\n        return eigenstates(self)\n\n    def eigenenergies(self):\n        return eigenenergies(self)\n\n    def collapse(self, mode=\"sum\"):\n        return collapse(self, mode=mode)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.header","title":"<code>header</code>  <code>property</code>","text":"<p>Print the header of the Qarray.</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Need to override this when defininig getattr.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n    return Qarray(\n        _data=deepcopy(self._data, memo=memo),\n        _qdims=deepcopy(self._qdims, memo=memo),\n        _bdims=deepcopy(self._bdims, memo=memo),\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.__len__","title":"<code>__len__()</code>","text":"<p>Length of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __len__(self):\n    \"\"\"Length of the Qarray.\"\"\"\n    if len(self.bdims) &gt; 0:\n        return self.data.shape[0]\n    else:\n        raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>For Qarray's, this only really makes sense in the context of division by a scalar.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n    if isinstance(other, Qarray):\n        raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n    return self.__mul__(1 / other)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.from_array","title":"<code>from_array(qarr_arr)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a nested list of Qarrays.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_arr</code> <code>list</code> <p>nested list of Qarrays</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Qarray object</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_array(cls, qarr_arr) -&gt; Qarray:\n    \"\"\"Create a Qarray from a nested list of Qarrays.\n\n    Args:\n        qarr_arr (list): nested list of Qarrays\n\n    Returns:\n        Qarray: Qarray object\n    \"\"\"\n    if isinstance(qarr_arr, Qarray):\n        return qarr_arr\n\n    bdims = ()\n    lvl = qarr_arr\n    while not isinstance(lvl, Qarray):\n        bdims = bdims + (len(lvl),)\n        if len(lvl) &gt; 0:\n            lvl = lvl[0]\n        else:\n            break\n\n    def flat(lis):\n        flatList = []\n        for element in lis:\n            if type(element) is list:\n                flatList += flat(element)\n            else:\n                flatList.append(element)\n        return flatList\n\n    qarr_list = flat(qarr_arr)\n    qarr = cls.from_list(qarr_list)\n    qarr = qarr.reshape_bdims(*bdims)\n    return qarr\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.from_list","title":"<code>from_list(qarr_list)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a list of Qarrays.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n    \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n    data = jnp.array([qarr.data for qarr in qarr_list])\n\n    if len(qarr_list) == 0:\n        dims = ((), ())\n        bdims = ()\n    else:\n        dims = qarr_list[0].dims\n        bdims = qarr_list[0].bdims\n\n    if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n        raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n    bdims = (len(qarr_list),) + bdims\n\n    return cls.create(data, dims=dims, bdims=bdims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.reshape_bdims","title":"<code>reshape_bdims(*args)</code>","text":"<p>Reshape the batch dimensions of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_bdims(self, *args):\n    \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n    new_bdims = tuple(args)\n\n    if prod(new_bdims) == 0:\n        new_shape = new_bdims\n    else:\n        new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n    return Qarray.create(\n        self.data.reshape(new_shape),\n        dims=self.dims,\n        bdims=new_bdims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.reshape_qdims","title":"<code>reshape_qdims(*args)</code>","text":"<p>Reshape the quantum dimensions of the Qarray.</p> <p>Note that this does not take in qdims but rather the new Hilbert space dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>new Hilbert dimensions for the Qarray.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>reshaped Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_qdims(self, *args):\n    \"\"\"Reshape the quantum dimensions of the Qarray.\n\n    Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n    Args:\n        *args: new Hilbert dimensions for the Qarray.\n\n    Returns:\n        Qarray: reshaped Qarray.\n    \"\"\"\n\n    new_space_dims = tuple(args)\n    current_space_dims = self.space_dims\n    assert prod(new_space_dims) == prod(current_space_dims)\n\n    new_qdims = self.space_to_qdims(new_space_dims)\n    new_bdims = self.bdims\n\n    return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.Qarray.resize","title":"<code>resize(new_shape)</code>","text":"<p>Resize the Qarray to a new shape.</p> <p>TODO: review and maybe deprecate this method.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def resize(self, new_shape):\n    \"\"\"Resize the Qarray to a new shape.\n\n    TODO: review and maybe deprecate this method.\n    \"\"\"\n    dims = self.dims\n    data = jnp.resize(self.data, new_shape)\n    return Qarray.create(\n        data,\n        dims=dims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.QuantumStateTomography","title":"<code>QuantumStateTomography</code>","text":"Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>class QuantumStateTomography:\n    def __init__(\n        self,\n        rho_guess: Qarray,\n        measurement_basis: Qarray,\n        measurement_results: jnp.ndarray,\n        complete_basis: Optional[Qarray] = None,\n        true_rho: Optional[Qarray] = None,\n    ):\n        \"\"\"\n        Reconstruct a quantum state from measurement results using quantum state tomography.\n        The tomography can be performed either by direct inversion or by maximum likelihood estimation.\n\n        Args:\n            rho_guess (Qarray): The initial guess for the quantum state.\n            measurement_basis (Qarray): The basis in which measurements are performed.\n            measurement_results (jnp.ndarray): The results of the measurements.\n            complete_basis (Optional[Qarray]): The complete basis for state \n            reconstruction used when using direct inversion. \n            Defaults to the measurement basis if not provided.\n            true_rho (Optional[Qarray]): The true quantum state, if known.\n\n        \"\"\"\n        self.rho_guess = rho_guess.data\n        self.measurement_basis = measurement_basis.data\n        self.measurement_results = measurement_results\n        self.complete_basis = (\n            complete_basis.data\n            if (complete_basis is not None)\n            else measurement_basis.data\n        )\n        self.true_rho = true_rho\n        self._result = None\n\n    @property\n    def result(self) -&gt; Optional[MLETomographyResult]:\n        return self._result\n\n\n    def quantum_state_tomography_mle(\n        self, L1_reg_strength: float = 0.0, epochs: int = 10000, lr: float = 5e-3\n    ) -&gt; MLETomographyResult:\n        \"\"\"Perform quantum state tomography using maximum likelihood \n        estimation (MLE).\n\n        This method reconstructs the quantum state from measurement results \n        by optimizing\n        a likelihood function using gradient descent. The optimization \n        ensures the \n        resulting density matrix is positive semi-definite with trace 1.\n\n        Args:\n            L1_reg_strength (float, optional): Strength of L1 \n            regularization. Defaults to 0.0.\n            epochs (int, optional): Number of optimization iterations. \n            Defaults to 10000.\n            lr (float, optional): Learning rate for the Adam optimizer. \n            Defaults to 5e-3.\n\n        Returns:\n            MLETomographyResult: Named tuple containing:\n                - rho: Reconstructed quantum state as Qarray\n                - params_history: List of parameter values during optimization\n                - loss_history: List of loss values during optimization\n                - grads_history: List of gradient values during optimization\n                - infidelity_history: List of infidelities if true_rho was \n                provided, None otherwise\n        \"\"\"\n\n        dim = self.rho_guess.shape[0]\n        optimizer = optax.adam(lr)\n\n        # Initialize parameters from the initial guess for the density matrix\n        params = _parametrize_density_matrix(self.rho_guess, dim)\n        opt_state = optimizer.init(params)\n\n        compute_infidelity_flag = self.true_rho is not None\n\n        # Provide a dummy array if no true_rho is available. It won't be used.\n        true_rho_data_or_dummy = (\n            self.true_rho.data\n            if compute_infidelity_flag\n            else jnp.empty((dim, dim), dtype=jnp.complex64)\n        )\n\n        final_carry, history = _run_tomography_scan(\n            initial_params=params,\n            initial_opt_state=opt_state,\n            true_rho_data=true_rho_data_or_dummy,\n            measurement_basis=self.measurement_basis,\n            measurement_results=self.measurement_results,\n            dim=dim,\n            epochs=epochs,\n            optimizer=optimizer,\n            compute_infidelity=compute_infidelity_flag,\n            L1_reg_strength=L1_reg_strength,\n        )\n\n        final_params, _ = final_carry\n\n        rho = Qarray.create(_reconstruct_density_matrix(final_params, dim))\n\n        self._result = MLETomographyResult(\n            rho=rho,\n            params_history=history[\"params\"],\n            loss_history=history[\"loss\"],\n            grads_history=history[\"grads\"],\n            infidelity_history=history[\"infidelity\"]\n            if compute_infidelity_flag\n            else None,\n        )\n        return self._result\n\n    def quantum_state_tomography_direct(\n        self,\n    ) -&gt; Qarray:\n\n        \"\"\"Perform quantum state tomography using direct inversion.\n\n        This method reconstructs the quantum state from measurement results by \n        directly solving a system of linear equations. The method assumes that\n        the measurement basis is complete and the measurement results are \n        noise-free.\n\n        Returns:\n            Qarray: Reconstructed quantum state.\n        \"\"\"\n\n    # Compute overlaps of measurement and complete operator bases\n        A = jnp.einsum(\"ijk,ljk-&gt;il\", self.complete_basis, self.measurement_basis)\n        # Solve the linear system to find the coefficients\n        coefficients = jnp.linalg.solve(A, self.measurement_results)\n        # Reconstruct the density matrix\n        rho = jnp.einsum(\"i, ijk-&gt;jk\", coefficients, self.complete_basis)\n\n        return Qarray.create(rho)\n\n    def plot_results(self):\n        if self._result is None:\n            raise ValueError(\n                \"No results to plot. Run quantum_state_tomography_mle first.\"\n            )\n\n        fig, ax = plt.subplots(1, figsize=(5, 4))\n        if self._result.infidelity_history is not None:\n            ax2 = ax.twinx()\n\n        ax.plot(self._result.loss_history, color=\"C0\")\n        ax.set_xlabel(\"Epoch\")\n        ax.set_ylabel(\"$\\\\mathcal{L}$\", color=\"C0\")\n        ax.set_yscale(\"log\")\n\n        if self._result.infidelity_history is not None:\n            ax2.plot(self._result.infidelity_history, color=\"C1\")\n            ax2.set_yscale(\"log\")\n            ax2.set_ylabel(\"$1-\\\\mathcal{F}$\", color=\"C1\")\n            plt.grid(False)\n\n        plt.show()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.QuantumStateTomography.__init__","title":"<code>__init__(rho_guess, measurement_basis, measurement_results, complete_basis=None, true_rho=None)</code>","text":"<p>Reconstruct a quantum state from measurement results using quantum state tomography. The tomography can be performed either by direct inversion or by maximum likelihood estimation.</p> <p>Parameters:</p> Name Type Description Default <code>rho_guess</code> <code>Qarray</code> <p>The initial guess for the quantum state.</p> required <code>measurement_basis</code> <code>Qarray</code> <p>The basis in which measurements are performed.</p> required <code>measurement_results</code> <code>ndarray</code> <p>The results of the measurements.</p> required <code>complete_basis</code> <code>Optional[Qarray]</code> <p>The complete basis for state </p> <code>None</code> <code>true_rho</code> <code>Optional[Qarray]</code> <p>The true quantum state, if known.</p> <code>None</code> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def __init__(\n    self,\n    rho_guess: Qarray,\n    measurement_basis: Qarray,\n    measurement_results: jnp.ndarray,\n    complete_basis: Optional[Qarray] = None,\n    true_rho: Optional[Qarray] = None,\n):\n    \"\"\"\n    Reconstruct a quantum state from measurement results using quantum state tomography.\n    The tomography can be performed either by direct inversion or by maximum likelihood estimation.\n\n    Args:\n        rho_guess (Qarray): The initial guess for the quantum state.\n        measurement_basis (Qarray): The basis in which measurements are performed.\n        measurement_results (jnp.ndarray): The results of the measurements.\n        complete_basis (Optional[Qarray]): The complete basis for state \n        reconstruction used when using direct inversion. \n        Defaults to the measurement basis if not provided.\n        true_rho (Optional[Qarray]): The true quantum state, if known.\n\n    \"\"\"\n    self.rho_guess = rho_guess.data\n    self.measurement_basis = measurement_basis.data\n    self.measurement_results = measurement_results\n    self.complete_basis = (\n        complete_basis.data\n        if (complete_basis is not None)\n        else measurement_basis.data\n    )\n    self.true_rho = true_rho\n    self._result = None\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.QuantumStateTomography.quantum_state_tomography_direct","title":"<code>quantum_state_tomography_direct()</code>","text":"<p>Perform quantum state tomography using direct inversion.</p> <p>This method reconstructs the quantum state from measurement results by  directly solving a system of linear equations. The method assumes that the measurement basis is complete and the measurement results are  noise-free.</p> <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Reconstructed quantum state.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def quantum_state_tomography_direct(\n    self,\n) -&gt; Qarray:\n\n    \"\"\"Perform quantum state tomography using direct inversion.\n\n    This method reconstructs the quantum state from measurement results by \n    directly solving a system of linear equations. The method assumes that\n    the measurement basis is complete and the measurement results are \n    noise-free.\n\n    Returns:\n        Qarray: Reconstructed quantum state.\n    \"\"\"\n\n# Compute overlaps of measurement and complete operator bases\n    A = jnp.einsum(\"ijk,ljk-&gt;il\", self.complete_basis, self.measurement_basis)\n    # Solve the linear system to find the coefficients\n    coefficients = jnp.linalg.solve(A, self.measurement_results)\n    # Reconstruct the density matrix\n    rho = jnp.einsum(\"i, ijk-&gt;jk\", coefficients, self.complete_basis)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.QuantumStateTomography.quantum_state_tomography_mle","title":"<code>quantum_state_tomography_mle(L1_reg_strength=0.0, epochs=10000, lr=0.005)</code>","text":"<p>Perform quantum state tomography using maximum likelihood  estimation (MLE).</p> <p>This method reconstructs the quantum state from measurement results  by optimizing a likelihood function using gradient descent. The optimization  ensures the  resulting density matrix is positive semi-definite with trace 1.</p> <p>Parameters:</p> Name Type Description Default <code>L1_reg_strength</code> <code>float</code> <p>Strength of L1 </p> <code>0.0</code> <code>epochs</code> <code>int</code> <p>Number of optimization iterations. </p> <code>10000</code> <code>lr</code> <code>float</code> <p>Learning rate for the Adam optimizer. </p> <code>0.005</code> <p>Returns:</p> Name Type Description <code>MLETomographyResult</code> <code>MLETomographyResult</code> <p>Named tuple containing: - rho: Reconstructed quantum state as Qarray - params_history: List of parameter values during optimization - loss_history: List of loss values during optimization - grads_history: List of gradient values during optimization - infidelity_history: List of infidelities if true_rho was  provided, None otherwise</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def quantum_state_tomography_mle(\n    self, L1_reg_strength: float = 0.0, epochs: int = 10000, lr: float = 5e-3\n) -&gt; MLETomographyResult:\n    \"\"\"Perform quantum state tomography using maximum likelihood \n    estimation (MLE).\n\n    This method reconstructs the quantum state from measurement results \n    by optimizing\n    a likelihood function using gradient descent. The optimization \n    ensures the \n    resulting density matrix is positive semi-definite with trace 1.\n\n    Args:\n        L1_reg_strength (float, optional): Strength of L1 \n        regularization. Defaults to 0.0.\n        epochs (int, optional): Number of optimization iterations. \n        Defaults to 10000.\n        lr (float, optional): Learning rate for the Adam optimizer. \n        Defaults to 5e-3.\n\n    Returns:\n        MLETomographyResult: Named tuple containing:\n            - rho: Reconstructed quantum state as Qarray\n            - params_history: List of parameter values during optimization\n            - loss_history: List of loss values during optimization\n            - grads_history: List of gradient values during optimization\n            - infidelity_history: List of infidelities if true_rho was \n            provided, None otherwise\n    \"\"\"\n\n    dim = self.rho_guess.shape[0]\n    optimizer = optax.adam(lr)\n\n    # Initialize parameters from the initial guess for the density matrix\n    params = _parametrize_density_matrix(self.rho_guess, dim)\n    opt_state = optimizer.init(params)\n\n    compute_infidelity_flag = self.true_rho is not None\n\n    # Provide a dummy array if no true_rho is available. It won't be used.\n    true_rho_data_or_dummy = (\n        self.true_rho.data\n        if compute_infidelity_flag\n        else jnp.empty((dim, dim), dtype=jnp.complex64)\n    )\n\n    final_carry, history = _run_tomography_scan(\n        initial_params=params,\n        initial_opt_state=opt_state,\n        true_rho_data=true_rho_data_or_dummy,\n        measurement_basis=self.measurement_basis,\n        measurement_results=self.measurement_results,\n        dim=dim,\n        epochs=epochs,\n        optimizer=optimizer,\n        compute_infidelity=compute_infidelity_flag,\n        L1_reg_strength=L1_reg_strength,\n    )\n\n    final_params, _ = final_carry\n\n    rho = Qarray.create(_reconstruct_density_matrix(final_params, dim))\n\n    self._result = MLETomographyResult(\n        rho=rho,\n        params_history=history[\"params\"],\n        loss_history=history[\"loss\"],\n        grads_history=history[\"grads\"],\n        infidelity_history=history[\"infidelity\"]\n        if compute_infidelity_flag\n        else None,\n    )\n    return self._result\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.basis","title":"<code>basis(N, k)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert space dimension</p> required <code>k</code> <code>int</code> <p>fock number</p> required <p>Returns:</p> Type Description <p>Fock State |k&gt;</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis(N: int, k: int):\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.\n\n    Args:\n        N: Hilbert space dimension\n        k: fock number\n\n    Returns:\n        Fock State |k&gt;\n    \"\"\"\n    return Qarray.create(one_hot(k, N).reshape(N, 1))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.basis_like","title":"<code>basis_like(A, ks)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Qarray</code> <p>state or operator.</p> required <code>k</code> <p>fock number.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Fock State |k&gt; with the same space dims as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis_like(A: Qarray, ks: List[int]) -&gt; Qarray:\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.\n\n    Args:\n        A: state or operator.\n        k: fock number.\n\n    Returns:\n        Fock State |k&gt; with the same space dims as A.\n    \"\"\"\n    space_dims = A.space_dims\n    assert len(space_dims) == len(ks), \"len(ks) must be equal to len(space_dims)\"\n\n    kets = []\n    for j, k in enumerate(ks):\n        kets.append(basis(space_dims[j], k))\n    return tensor(*kets)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.cf_wigner","title":"<code>cf_wigner(psi, xvec, yvec)</code>","text":"<p>Wigner function for a state vector or density matrix at points <code>xvec + i * yvec</code>.</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.cf_wigner--parameters","title":"Parameters","text":"Qarray <p>A state vector or density matrix.</p> array_like <p>x-coordinates at which to calculate the Wigner function.</p> array_like <p>y-coordinates at which to calculate the Wigner function.</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.cf_wigner--returns","title":"Returns","text":"array <p>Values representing the Wigner function calculated over the specified range [xvec,yvec].</p> Source code in <code>jaxquantum/core/cfunctions.py</code> <pre><code>def cf_wigner(psi, xvec, yvec):\n    \"\"\"Wigner function for a state vector or density matrix at points\n    `xvec + i * yvec`.\n\n    Parameters\n    ----------\n\n    state : Qarray\n        A state vector or density matrix.\n\n    xvec : array_like\n        x-coordinates at which to calculate the Wigner function.\n\n    yvec : array_like\n        y-coordinates at which to calculate the Wigner function.\n\n\n    Returns\n    -------\n\n    W : array\n        Values representing the Wigner function calculated over the specified\n        range [xvec,yvec].\n\n\n    \"\"\"\n    N = psi.dims[0][0]\n    x, y = jnp.meshgrid(xvec, yvec)\n    alpha = x + 1.0j * y\n    displacement = jqt.displace(N, alpha)\n\n    vmapped_overlap = [vmap(vmap(jqt.overlap, in_axes=(None, 0)), in_axes=(\n        None, 0))]\n    for _ in psi.bdims:\n        vmapped_overlap.append(vmap(vmapped_overlap[-1], in_axes=(0, None)))\n\n    cf = vmapped_overlap[-1](psi, displacement)\n    return cf\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.coherent","title":"<code>coherent(N, \u03b1)</code>","text":"<p>Coherent state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>\u03b1</code> <code>complex</code> <p>coherent state amplitude.</p> required Return <p>Coherent state |\u03b1\u27e9.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def coherent(N: int, \u03b1: complex) -&gt; Qarray:\n    \"\"\"Coherent state.\n\n    Args:\n        N: Hilbert Space Size.\n        \u03b1: coherent state amplitude.\n\n    Return:\n        Coherent state |\u03b1\u27e9.\n    \"\"\"\n    return displace(N, \u03b1) @ basis(N, 0)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.collapse","title":"<code>collapse(qarr, mode='sum')</code>","text":"<p>Collapse the Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Collapsed quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def collapse(qarr: Qarray, mode=\"sum\") -&gt; Qarray:\n    \"\"\"Collapse the Qarray.\n\n    Args:\n        qarr (Qarray): quantum array array\n\n    Returns:\n        Collapsed quantum array\n    \"\"\"\n    if mode == \"sum\":\n        if len(qarr.bdims) == 0:\n            return qarr\n\n        batch_axes = list(range(len(qarr.bdims)))\n        return Qarray.create(jnp.sum(qarr.data, axis=batch_axes), dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.concatenate","title":"<code>concatenate(qarr_list, axis=0)</code>","text":"<p>Concatenate a list of Qarrays along a specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_list</code> <code>List[Qarray]</code> <p>List of Qarrays to concatenate.</p> required <code>axis</code> <code>int</code> <p>Axis along which to concatenate. Default is 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Concatenated Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def concatenate(qarr_list: List[Qarray], axis: int = 0) -&gt; Qarray:\n    \"\"\"Concatenate a list of Qarrays along a specified axis.\n\n    Args:\n        qarr_list (List[Qarray]): List of Qarrays to concatenate.\n        axis (int): Axis along which to concatenate. Default is 0.\n\n    Returns:\n        Qarray: Concatenated Qarray.\n    \"\"\"\n\n    non_empty_qarr_list = [qarr for qarr in qarr_list if len(qarr.data) != 0]\n\n    if len(non_empty_qarr_list) == 0:\n        return Qarray.from_list([])\n\n    concatenated_data = jnp.concatenate(\n        [qarr.data for qarr in non_empty_qarr_list], axis=axis\n    )\n\n    dims = non_empty_qarr_list[0].dims\n    return Qarray.create(concatenated_data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.cosm","title":"<code>cosm(qarr)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Matrix cosine wrapper.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    dims = qarr.dims\n    data = cosm_data(qarr.data)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.cosm_data","title":"<code>cosm_data(data, **kwargs)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix cosine wrapper.\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    return (expm_data(1j * data) + expm_data(-1j * data)) / 2\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.dag","title":"<code>dag(qarr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>conjugate transpose of qarr</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        conjugate transpose of qarr\n    \"\"\"\n    dims = qarr.dims[::-1]\n\n    data = dag_data(qarr.data)\n\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.dag_data","title":"<code>dag_data(arr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag_data(arr: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        arr: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    # TODO: revisit this case...\n    if len(arr.shape) == 1:\n        return jnp.conj(arr)\n\n    return jnp.moveaxis(\n        jnp.conj(arr), -1, -2\n    )  # transposes last two axes, good for batching\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.displace","title":"<code>displace(N, \u03b1)</code>","text":"<p>Displacement operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>\u03b1</code> <p>Phase space displacement</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Displace operator D(\u03b1)</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def displace(N, \u03b1) -&gt; Qarray:\n    \"\"\"Displacement operator\n\n    Args:\n        N: Hilbert Space Size\n        \u03b1: Phase space displacement\n\n    Returns:\n        Displace operator D(\u03b1)\n    \"\"\"\n    a = destroy(N)\n    return (\u03b1 * a.dag() - jnp.conj(\u03b1) * a).expm()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.eigenenergies","title":"<code>eigenenergies(qarr)</code>","text":"<p>Eigenvalues of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>eigenvalues</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenenergies(qarr: Qarray) -&gt; Array:\n    \"\"\"Eigenvalues of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues\n    \"\"\"\n\n    evals = jnp.linalg.eigvalsh(qarr.data)\n    return evals\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.eigenstates","title":"<code>eigenstates(qarr)</code>","text":"<p>Eigenstates of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>eigenvalues and eigenstates</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenstates(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Eigenstates of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues and eigenstates\n    \"\"\"\n\n    evals, evecs = jnp.linalg.eigh(qarr.data)\n    idxs_sorted = jnp.argsort(evals, axis=-1)\n\n    dims = ket_from_op_dims(qarr.dims)\n\n    evals = jnp.take_along_axis(evals, idxs_sorted, axis=-1)\n    evecs = jnp.take_along_axis(evecs, idxs_sorted[..., None, :], axis=-1)\n\n    # numpy returns [batch, :, i] as the i-th eigenvector\n    # we want [batch, i, :] as the i-th eigenvector\n    evecs = jnp.swapaxes(evecs, -2, -1)\n\n    evecs = Qarray.create(\n        evecs,\n        dims=dims,\n        bdims=evecs.shape[:-1],\n    )\n\n    return evals, evecs\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.expm","title":"<code>expm(qarr, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm(qarr: Qarray, **kwargs) -&gt; Qarray:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    dims = qarr.dims\n    data = expm_data(qarr.data, **kwargs)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.expm_data","title":"<code>expm_data(data, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    return jsp.linalg.expm(data, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.extract_dims","title":"<code>extract_dims(arr, dims=None)</code>","text":"<p>Extract dims from a JAX array or Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>JAX array or Qarray.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray dims.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def extract_dims(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"Extract dims from a JAX array or Qarray.\n\n    Args:\n        arr: JAX array or Qarray.\n        dims: Qarray dims.\n\n    Returns:\n        Qarray dims.\n    \"\"\"\n    if isinstance(dims[0], Number):\n        is_op = arr.shape[-2] == arr.shape[-1]\n        if is_op:\n            dims = [dims, dims]\n        else:\n            dims = [dims, [1] * len(dims)]  # defaults to ket\n    return dims\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.fidelity","title":"<code>fidelity(rho, sigma, force_positivity=False)</code>","text":"<p>Fidelity between two states.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>Qarray</code> <p>state.</p> required <code>sigma</code> <code>Qarray</code> <p>state.</p> required <code>force_positivity</code> <code>bool</code> <p>force the states to be positive semidefinite</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Fidelity between rho and sigma.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def fidelity(rho: Qarray, sigma: Qarray, force_positivity: bool=False) -&gt; (\n        jnp.ndarray):\n    \"\"\"Fidelity between two states.\n\n    Args:\n        rho: state.\n        sigma: state.\n        force_positivity: force the states to be positive semidefinite\n\n    Returns:\n        Fidelity between rho and sigma.\n    \"\"\"\n    rho = rho.to_dm()\n    sigma = sigma.to_dm()\n\n    sqrt_rho = powm(rho, 0.5, clip_eigvals=force_positivity)\n\n    return jnp.real(((powm(sqrt_rho @ sigma @ sqrt_rho, 0.5,\n                           clip_eigvals=force_positivity)).tr())\n                    ** 2)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.hadamard","title":"<code>hadamard()</code>","text":"<p>H</p> <p>Returns:</p> Name Type Description <code>H</code> <code>Qarray</code> <p>Hadamard gate</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def hadamard() -&gt; Qarray:\n    \"\"\"H\n\n    Returns:\n        H: Hadamard gate\n    \"\"\"\n    return Qarray.create(jnp.array([[1, 1], [1, -1]]) / jnp.sqrt(2))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.identity_like","title":"<code>identity_like(A)</code>","text":"<p>Identity matrix with the same shape as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <p>Matrix.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix with the same shape as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity_like(A) -&gt; Qarray:\n    \"\"\"Identity matrix with the same shape as A.\n\n    Args:\n        A: Matrix.\n\n    Returns:\n        Identity matrix with the same shape as A.\n    \"\"\"\n    space_dims = A.space_dims\n    total_dim = prod(space_dims)\n    return Qarray.create(jnp.eye(total_dim, total_dim), dims=[space_dims, space_dims])\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.is_dm_data","title":"<code>is_dm_data(data)</code>","text":"<p>Check if data is a density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:     True if data is a density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def is_dm_data(data: Array) -&gt; bool:\n    \"\"\"Check if data is a density matrix.\n\n    Args:\n        data: matrix\n    Returns:\n        True if data is a density matrix\n    \"\"\"\n    return data.shape[-2] == data.shape[-1]\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.jnp2jqt","title":"<code>jnp2jqt(arr, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnp2jqt(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n        dims: Qarray dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    dims = extract_dims(arr, dims) if dims is not None else None\n    return Qarray.create(arr, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.jqt2qt","title":"<code>jqt2qt(jqt_obj)</code>","text":"<p>Qarray -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jqt_obj</code> <p>Qarray.</p> required <code>dims</code> <p>QuTiP dims.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqt2qt(jqt_obj):\n    \"\"\"Qarray -&gt; QuTiP state.\n\n    Args:\n        jqt_obj: Qarray.\n        dims: QuTiP dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    if isinstance(jqt_obj, Qobj) or jqt_obj is None:\n        return jqt_obj\n\n    if jqt_obj.is_batched:\n        res = []\n        for i in range(len(jqt_obj)):\n            res.append(jqt2qt(jqt_obj[i]))\n        return res\n\n    dims = [list(jqt_obj.dims[0]), list(jqt_obj.dims[1])]\n    return Qobj(np.array(jqt_obj.data), dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.ket2dm","title":"<code>ket2dm(qarr)</code>","text":"<p>Turns ket into density matrix. Does nothing if already operator.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>qarr</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ket2dm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Turns ket into density matrix.\n    Does nothing if already operator.\n\n    Args:\n        qarr (Qarray): qarr\n\n    Returns:\n        Density matrix\n    \"\"\"\n\n    if qarr.qtype == Qtypes.oper:\n        return qarr\n\n    if qarr.qtype == Qtypes.bra:\n        qarr = qarr.dag()\n\n    return qarr @ qarr.dag()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.mesolve","title":"<code>mesolve(H, rho0, tlist, saveat_tlist=None, c_ops=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[Qarray, Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function or time-independent Qarray.</p> required <code>rho0</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>tlist</code> <code>Array</code> <p>time list</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <code>c_ops</code> <code>Optional[Qarray]</code> <p>qarray list of collapse operators</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    rho0: Qarray,\n    tlist: Array,\n    saveat_tlist: Optional[Array] = None,\n    c_ops: Optional[Qarray] = None,\n    solver_options: Optional[SolverOptions] = None,\n) -&gt; Qarray:\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        H: time dependent Hamiltonian function or time-independent Qarray.\n        rho0: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        tlist: time list\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n        c_ops: qarray list of collapse operators\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    saveat_tlist = saveat_tlist if saveat_tlist is not None else tlist\n\n    saveat_tlist = jnp.atleast_1d(saveat_tlist)\n\n    c_ops = c_ops if c_ops is not None else Qarray.from_list([])\n\n    # if isinstance(H, Qarray):\n\n    if len(c_ops) == 0 and rho0.qtype != Qtypes.oper:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = rho0.to_dm()\n    dims = \u03c10.dims\n    \u03c10 = \u03c10.data\n\n    c_ops = c_ops.data\n\n    if isinstance(H, Qarray):\n        Ht_data = lambda t: H.data\n    else:\n        Ht_data = lambda t: H(t).data\n\n    ys = _mesolve_data(Ht_data, \u03c10, tlist, saveat_tlist, c_ops,\n                       solver_options=solver_options)\n\n    return jnp2jqt(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.multi_mode_basis_set","title":"<code>multi_mode_basis_set(Ns)</code>","text":"<p>Creates a multi-mode basis set.</p> <p>Parameters:</p> Name Type Description Default <code>Ns</code> <code>List[int]</code> <p>List of Hilbert space dimensions for each mode.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Multi-mode basis set.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def multi_mode_basis_set(Ns: List[int]) -&gt; Qarray:\n    \"\"\"Creates a multi-mode basis set.\n\n    Args:\n        Ns: List of Hilbert space dimensions for each mode.\n\n    Returns:\n        Multi-mode basis set.\n    \"\"\"\n    data = jnp.eye(prod(Ns))\n    dims = (tuple(Ns), tuple([1 for _ in Ns]))\n    return Qarray.create(data, dims=dims, bdims=(prod(Ns),))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.num","title":"<code>num(N)</code>","text":"<p>Number operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>number operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def num(N) -&gt; Qarray:\n    \"\"\"Number operator\n\n    Args:\n        N: Hilbert Space size\n\n    Returns:\n        number operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.arange(N)))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.overlap","title":"<code>overlap(rho, sigma)</code>","text":"<p>Overlap between two states or operators.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>Qarray</code> <p>state/operator.</p> required <code>sigma</code> <code>Qarray</code> <p>state/operator.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Overlap between rho and sigma.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def overlap(rho: Qarray, sigma: Qarray) -&gt; Array:\n    \"\"\"Overlap between two states or operators.\n\n    Args:\n        rho: state/operator.\n        sigma: state/operator.\n\n    Returns:\n        Overlap between rho and sigma.\n    \"\"\"\n\n    if rho.is_vec() and sigma.is_vec():\n        return jnp.abs(((rho.to_ket().dag() @ sigma.to_ket()).trace())) ** 2\n    elif rho.is_vec():\n        rho = rho.to_ket()\n        res = (rho.dag() @ sigma @ rho).data\n        return res.squeeze(-1).squeeze(-1)\n    elif sigma.is_vec():\n        sigma = sigma.to_ket()\n        res = (sigma.dag() @ rho @ sigma).data\n        return res.squeeze(-1).squeeze(-1)\n    else:\n        return (rho.dag() @ sigma).trace()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.plot_cf","title":"<code>plot_cf(state, pts_x, pts_y=None, axs=None, contour=True, qp_type=WIGNER, cbar_label='', axis_scale_factor=1, plot_cbar=True, plot_grid=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot characteristic function.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\")</p> <code>WIGNER</code> <code>cbar_label</code> <p>labels for the real and imaginary cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_cf(\n        state,\n        pts_x,\n        pts_y=None,\n        axs=None,\n        contour=True,\n        qp_type=WIGNER,\n        cbar_label=\"\",\n        axis_scale_factor=1,\n        plot_cbar=True,\n        plot_grid=True,\n        x_ticks=None,\n        y_ticks=None,\n        z_ticks=None,\n        subtitles=None,\n        figtitle=None,\n):\n    \"\"\"Plot characteristic function.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\")\n        cbar_label: labels for the real and imaginary cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    if pts_y is None:\n        pts_y = pts_x\n    pts_x = jnp.array(pts_x)\n    pts_y = jnp.array(pts_y)\n\n    bdims = state.bdims\n    added_baxes = 0\n\n    if subtitles is not None:\n        if subtitles.shape != bdims:\n            raise ValueError(\n                f\"labels must have same shape as bdims, \"\n                f\"got shapes {subtitles.shape} and {bdims}\"\n            )\n\n    if len(bdims) == 0:\n        bdims = (1,)\n        added_baxes += 1\n    if len(bdims) == 1:\n        bdims = (1, bdims[0])\n        added_baxes += 1\n\n    extra_dims = bdims[2:]\n    if extra_dims != ():\n        state = state.reshape_bdims(\n            bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n        )\n        if subtitles is not None:\n            subtitles = subtitles.reshape(\n                bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n            )\n        bdims = state.bdims\n\n    if axs is None:\n        _, axs = plt.subplots(\n            bdims[0],\n            bdims[1]*2,\n            figsize=(4 * bdims[1]*2, 3 * bdims[0]),\n            dpi=200,\n        )\n\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = 1\n        cmap = \"seismic\"\n        cbar_label = [r\"$\\mathcal{Re}(\\chi_W(\\alpha))$\", r\"$\\mathcal{\"\n                                                         r\"Im}(\\chi_W(\"\n                                                         r\"\\alpha))$\"]\n        QP = scale * cf_wigner(state, pts_x, pts_y)\n\n    for _ in range(added_baxes):\n        QP = jnp.array([QP])\n        axs = np.array([axs])\n        if subtitles is not None:\n            subtitles = np.array([subtitles])\n\n    if added_baxes==2:\n        axs = axs[0] # When the input state is zero-dimensional, remove an\n                     # axis that is automatically added due to the subcolumns\n\n\n    pts_x = pts_x * axis_scale_factor\n    pts_y = pts_y * axis_scale_factor\n\n    x_ticks = (\n        jnp.linspace(jnp.min(pts_x), jnp.max(pts_x),\n                     5) if x_ticks is None else x_ticks\n    )\n    y_ticks = (\n        jnp.linspace(jnp.min(pts_y), jnp.max(pts_y),\n                     5) if y_ticks is None else y_ticks\n    )\n    z_ticks = jnp.linspace(vmin, vmax, 11) if z_ticks is None else z_ticks\n    print(axs.shape)\n    for row in range(bdims[0]):\n        for col in range(bdims[1]):\n            for subcol in range(2):\n                ax = axs[row, 2 * col + subcol]\n                if contour:\n                    im = ax.contourf(\n                        pts_x,\n                        pts_y,\n                        jnp.real(QP[row, col]) if subcol==0 else jnp.imag(QP[\n                                                                           row, col]),\n                        cmap=cmap,\n                        vmin=vmin,\n                        vmax=vmax,\n                        levels=np.linspace(vmin, vmax, 101),\n                    )\n                else:\n                    im = ax.pcolormesh(\n                        pts_x,\n                        pts_y,\n                        jnp.real(QP[row, col]) if subcol == 0 else jnp.imag(QP[\n                                                                                row, col]),\n                        cmap=cmap,\n                        vmin=vmin,\n                        vmax=vmax,\n                    )\n                ax.set_xticks(x_ticks)\n                ax.set_yticks(y_ticks)\n                # ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n                # ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n\n                if plot_grid:\n                    ax.grid()\n\n                ax.set_aspect(\"equal\", adjustable=\"box\")\n\n                if plot_cbar:\n                    cbar = plt.colorbar(\n                        im, ax=ax, orientation=\"vertical\",\n                        ticks=np.linspace(-1, 1, 11)\n                    )\n                    cbar.ax.set_title(cbar_label[subcol])\n                    cbar.set_ticks(z_ticks)\n\n                ax.set_xlabel(r\"Re[$\\alpha$]\")\n                ax.set_ylabel(r\"Im[$\\alpha$]\")\n                if subtitles is not None:\n                    ax.set_title(subtitles[row, col])\n\n    fig = ax.get_figure()\n    fig.tight_layout()\n    if figtitle is not None:\n        fig.suptitle(figtitle, y=1.04)\n    return axs, im\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.plot_cf_wigner","title":"<code>plot_cf_wigner(state, pts_x, pts_y=None, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, plot_grid=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the Wigner characteristic function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_cf_wigner(\n    state,\n    pts_x,\n    pts_y=None,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    plot_grid=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the Wigner characteristic function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_cf(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        axs=axs,\n        contour=contour,\n        qp_type=WIGNER,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        plot_grid=plot_grid,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.plot_qfunc","title":"<code>plot_qfunc(state, pts_x, pts_y=None, g=2, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the husimi function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qfunc(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the husimi function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_qp(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        g=g,\n        axs=axs,\n        contour=contour,\n        qp_type=HUSIMI,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.plot_qp","title":"<code>plot_qp(state, pts_x, pts_y=None, g=2, axs=None, contour=True, qp_type=WIGNER, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot quasi-probability distribution.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\", \"qfunc\")</p> <code>WIGNER</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qp(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    qp_type=WIGNER,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot quasi-probability distribution.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\", \"qfunc\")\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    if pts_y is None:\n        pts_y = pts_x\n    pts_x = jnp.array(pts_x)\n    pts_y = jnp.array(pts_y)\n\n    if len(state.bdims)==1 and state.bdims[0]==1:\n        state = state[0]\n\n\n    bdims = state.bdims\n    added_baxes = 0\n\n    if subtitles is not None:\n        if subtitles.shape != bdims:\n            raise ValueError(\n                f\"labels must have same shape as bdims, \"\n                f\"got shapes {subtitles.shape} and {bdims}\"\n            )\n\n    if len(bdims) == 0:\n        bdims = (1,)\n        added_baxes += 1\n    if len(bdims) == 1:\n        bdims = (1, bdims[0])\n        added_baxes += 1\n\n    extra_dims = bdims[2:]\n    if extra_dims != ():\n        state = state.reshape_bdims(\n            bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n        )\n        if subtitles is not None:\n            subtitles = subtitles.reshape(\n                bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n            )\n        bdims = state.bdims\n\n    if axs is None:\n        _, axs = plt.subplots(\n            bdims[0],\n            bdims[1],\n            figsize=(4 * bdims[1], 3 * bdims[0]),\n            dpi=200,\n        )\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = np.pi / 2\n        cmap = \"seismic\"\n        cbar_label = r\"$\\mathcal{W}(\\alpha)$\"\n        QP = scale * wigner(state, pts_x, pts_y, g=g)\n\n    elif qp_type == HUSIMI:\n        vmin = 0\n        vmax = 1\n        scale = np.pi\n        cmap = \"jet\"\n        cbar_label = r\"$\\mathcal{Q}(\\alpha)$\"\n        QP = scale * qfunc(state, pts_x, pts_y, g=g)\n\n\n\n    for _ in range(added_baxes):\n        QP = jnp.array([QP])\n        axs = np.array([axs])\n        if subtitles is not None:\n            subtitles = np.array([subtitles])\n\n\n\n\n    pts_x = pts_x * axis_scale_factor\n    pts_y = pts_y * axis_scale_factor\n\n    x_ticks = (\n        jnp.linspace(jnp.min(pts_x), jnp.max(pts_x), 5) if x_ticks is None else x_ticks\n    )\n    y_ticks = (\n        jnp.linspace(jnp.min(pts_y), jnp.max(pts_y), 5) if y_ticks is None else y_ticks\n    )\n    z_ticks = jnp.linspace(vmin, vmax, 3) if z_ticks is None else z_ticks\n\n    for row in range(bdims[0]):\n        for col in range(bdims[1]):\n            ax = axs[row, col]\n            if contour:\n                im = ax.contourf(\n                    pts_x,\n                    pts_y,\n                    QP[row, col],\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    levels=np.linspace(vmin, vmax, 101),\n                )\n            else:\n                im = ax.pcolormesh(\n                    pts_x,\n                    pts_y,\n                    QP[row, col],\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                )\n            ax.set_xticks(x_ticks)\n            ax.set_yticks(y_ticks)\n            ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n            ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n            ax.grid()\n            ax.set_aspect(\"equal\", adjustable=\"box\")\n\n            if plot_cbar:\n                cbar = plt.colorbar(\n                    im, ax=ax, orientation=\"vertical\", ticks=np.linspace(-1, 1, 11)\n                )\n                cbar.ax.set_title(cbar_label)\n                cbar.set_ticks(z_ticks)\n\n            ax.set_xlabel(r\"Re[$\\alpha$]\")\n            ax.set_ylabel(r\"Im[$\\alpha$]\")\n            if subtitles is not None:\n                ax.set_title(subtitles[row, col])\n\n    fig = ax.get_figure()\n    fig.tight_layout()\n    if figtitle is not None:\n        fig.suptitle(figtitle, y=1.04)\n    return axs, im\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.plot_wigner","title":"<code>plot_wigner(state, pts_x, pts_y=None, g=2, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the wigner function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_wigner(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the wigner function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_qp(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        g=g,\n        axs=axs,\n        contour=contour,\n        qp_type=WIGNER,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.powm","title":"<code>powm(qarr, n, clip_eigvals=False)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>n</code> <code>int</code> <p>power</p> required <code>clip_eigvals</code> <code>bool</code> <p>clip eigenvalues to always be able to compute</p> <code>False</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm(qarr: Qarray, n: Union[int, float], clip_eigvals=False) -&gt; Qarray:\n    \"\"\"Matrix power.\n\n    Args:\n        qarr (Qarray): quantum array\n        n (int): power\n        clip_eigvals (bool): clip eigenvalues to always be able to compute\n        non-integer powers\n\n    Returns:\n        matrix power\n    \"\"\"\n    if isinstance(n, int):\n        data_res = jnp.linalg.matrix_power(qarr.data, n)\n    else:\n        evalues, evectors = jnp.linalg.eig(qarr.data)\n        if clip_eigvals:\n            evalues = jnp.maximum(evalues, 0)\n        else:\n            if not (evalues &gt;= 0).all():\n                raise ValueError(\n                    \"Non-integer power of a matrix can only be \"\n                    \"computed if the matrix is positive semi-definite.\"\n                    \"Got a matrix with a negative eigenvalue.\"\n                )\n        data_res = evectors * jnp.pow(evalues, n) @ jnp.linalg.inv(evectors)\n    return Qarray.create(data_res, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.powm_data","title":"<code>powm_data(data, n)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <code>n</code> <code>int</code> <p>power</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm_data(data: Array, n: int) -&gt; Array:\n    \"\"\"Matrix power.\n\n    Args:\n        data: matrix\n        n: power\n\n    Returns:\n        matrix power\n    \"\"\"\n    return jnp.linalg.matrix_power(data, n)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.propagator","title":"<code>propagator(H, ts, saveat_tlist=None, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Qarray or callable</code> <p>A Qarray static Hamiltonian OR a function that takes a time argument and returns a Hamiltonian.</p> required <code>ts</code> <code>float or Array</code> <p>A single time point or an Array of time points.</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray or List[Qarray]: The propagator for the Hamiltonian at time t. OR a list of propagators for the Hamiltonian at each time in t.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    ts: Union[float, Array],\n    saveat_tlist: Optional[Array] = None,\n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian.\n\n    Args:\n        H (Qarray or callable):\n            A Qarray static Hamiltonian OR\n            a function that takes a time argument and returns a Hamiltonian.\n        ts (float or Array):\n            A single time point or\n            an Array of time points.\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n\n    Returns:\n        Qarray or List[Qarray]:\n            The propagator for the Hamiltonian at time t.\n            OR a list of propagators for the Hamiltonian at each time in t.\n\n    \"\"\"\n\n\n    ts_is_scalar = robust_isscalar(ts)\n    H_is_qarray = isinstance(H, Qarray)\n\n    if H_is_qarray:\n        return (-1j * H * ts).expm()\n    else:\n\n        if ts_is_scalar:\n            H_first = H(0.0)\n            if ts == 0:\n                return identity_like(H_first)\n            ts = jnp.array([0.0, ts])\n        else:\n            H_first = H(ts[0])\n\n        basis_states = multi_mode_basis_set(H_first.space_dims)\n        results = sesolve(H, basis_states, ts, saveat_tlist=saveat_tlist)\n        propagators_data = results.data.squeeze(-1).mT\n        propagators = Qarray.create(propagators_data, dims=H_first.space_dims)\n\n        return propagators\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.ptrace","title":"<code>ptrace(qarr, indx)</code>","text":"<p>Partial Trace.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <p>density matrix</p> required <code>indx</code> <p>index of quantum object to keep, rest will be partial traced out</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>partial traced out density matrix</p> <p>TODO: Fix weird tracing errors that arise with reshape</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ptrace(qarr: Qarray, indx) -&gt; Qarray:\n    \"\"\"Partial Trace.\n\n    Args:\n        rho: density matrix\n        indx: index of quantum object to keep, rest will be partial traced out\n\n    Returns:\n        partial traced out density matrix\n\n    TODO: Fix weird tracing errors that arise with reshape\n    \"\"\"\n\n    qarr = ket2dm(qarr)\n    rho = qarr.shaped_data\n    dims = qarr.dims\n\n    Nq = len(dims[0])\n\n    indxs = [indx, indx + Nq]\n    for j in range(Nq):\n        if j == indx:\n            continue\n        indxs.append(j)\n        indxs.append(j + Nq)\n\n    bdims = qarr.bdims\n    len_bdims = len(bdims)\n    bdims_indxs = list(range(len_bdims))\n    indxs = bdims_indxs + [j + len_bdims for j in indxs]\n    rho = rho.transpose(indxs)\n\n    for j in range(Nq - 1):\n        rho = jnp.trace(rho, axis1=2 + len_bdims, axis2=3 + len_bdims)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.qfunc","title":"<code>qfunc(psi, xvec, yvec, g=2)</code>","text":"<p>Husimi-Q function of a given state vector or density matrix at phase-space points <code>0.5 * g * (xvec + i*yvec)</code>.</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.qfunc--parameters","title":"Parameters","text":"<p>state : Qarray     A state vector or density matrix. This cannot have tensor-product     structure.</p> <p>xvec, yvec : array_like     x- and y-coordinates at which to calculate the Husimi-Q function.</p> float, default: 2 <p>Scaling factor for <code>a = 0.5 * g * (x + iy)</code>.  The value of <code>g</code> is related to the value of :math:<code>\\hbar</code> in the commutation relation :math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.qfunc--returns","title":"Returns","text":"<p>jnp.ndarray     Values representing the Husimi-Q function calculated over the specified     range <code>[xvec, yvec]</code>.</p> Source code in <code>jaxquantum/core/qp_distributions.py</code> <pre><code>def qfunc(psi, xvec, yvec, g=2):\n    r\"\"\"\n    Husimi-Q function of a given state vector or density matrix at phase-space\n    points ``0.5 * g * (xvec + i*yvec)``.\n\n    Parameters\n    ----------\n    state : Qarray\n        A state vector or density matrix. This cannot have tensor-product\n        structure.\n\n    xvec, yvec : array_like\n        x- and y-coordinates at which to calculate the Husimi-Q function.\n\n    g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\hbar` via :math:`\\hbar=2/g^2`.\n\n    Returns\n    -------\n    jnp.ndarray\n        Values representing the Husimi-Q function calculated over the specified\n        range ``[xvec, yvec]``.\n\n    \"\"\"\n\n    alpha_grid, prefactor = _qfunc_coherent_grid(xvec, yvec, g)\n\n    if psi.is_vec():\n        psi = psi.to_ket()\n\n        def _compute_qfunc(psi, alpha_grid, prefactor, g):\n            out = _qfunc_iterative_single(psi, alpha_grid, prefactor, g)\n            out /= jnp.pi\n            return out\n    else:\n\n        def _compute_qfunc(psi, alpha_grid, prefactor, g):\n            values, vectors = jnp.linalg.eigh(psi)\n            vectors = vectors.T\n            out = values[0] * _qfunc_iterative_single(\n                vectors[0], alpha_grid, prefactor, g\n            )\n            for value, vector in zip(values[1:], vectors[1:]):\n                out += value * _qfunc_iterative_single(vector, alpha_grid, prefactor, g)\n            out /= jnp.pi\n\n            return out\n\n    psi = psi.data\n\n    vmapped_compute_qfunc = [_compute_qfunc]\n\n    for _ in psi.shape[:-2]:\n        vmapped_compute_qfunc.append(\n            vmap(\n                vmapped_compute_qfunc[-1],\n                in_axes=(0, None, None, None),\n                out_axes=0,\n            )\n        )\n    return vmapped_compute_qfunc[-1](psi, alpha_grid, prefactor, g)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.qt2jqt","title":"<code>qt2jqt(qt_obj, dtype=jnp.complex128)</code>","text":"<p>QuTiP state -&gt; Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <code>dtype</code> <p>JAX dtype.</p> <code>complex128</code> <p>Returns:</p> Type Description <p>Qarray.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def qt2jqt(qt_obj, dtype=jnp.complex128):\n    \"\"\"QuTiP state -&gt; Qarray.\n\n    Args:\n        qt_obj: QuTiP state.\n        dtype: JAX dtype.\n\n    Returns:\n        Qarray.\n    \"\"\"\n    if isinstance(qt_obj, Qarray) or qt_obj is None:\n        return qt_obj\n    return Qarray.create(jnp.array(qt_obj.full(), dtype=dtype), dims=qt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.qubit_rotation","title":"<code>qubit_rotation(theta, nx, ny, nz)</code>","text":"<p>Single qubit rotation.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>rotation angle.</p> required <code>nx</code> <p>rotation axis x component.</p> required <code>ny</code> <p>rotation axis y component.</p> required <code>nz</code> <p>rotation axis z component.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Single qubit rotation operator.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def qubit_rotation(theta: float, nx, ny, nz) -&gt; Qarray:\n    \"\"\"Single qubit rotation.\n\n    Args:\n        theta: rotation angle.\n        nx: rotation axis x component.\n        ny: rotation axis y component.\n        nz: rotation axis z component.\n\n    Returns:\n        Single qubit rotation operator.\n    \"\"\"\n    return jnp.cos(theta / 2) * identity(2) - 1j * jnp.sin(theta / 2) * (\n        nx * sigmax() + ny * sigmay() + nz * sigmaz()\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sesolve","title":"<code>sesolve(H, rho0, tlist, saveat_tlist=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[Qarray, Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function or time-independent Qarray.</p> required <code>rho0</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>tlist</code> <code>Array</code> <p>time list</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    rho0: Qarray,\n    tlist: Array,\n    saveat_tlist: Optional[Array] = None,\n    solver_options: Optional[SolverOptions] = None,\n) -&gt; Qarray:\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        H: time dependent Hamiltonian function or time-independent Qarray.\n        rho0: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        tlist: time list\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    saveat_tlist = saveat_tlist if saveat_tlist is not None else tlist\n\n    saveat_tlist = jnp.atleast_1d(saveat_tlist)\n\n    \u03c8 = rho0\n\n    if \u03c8.qtype == Qtypes.oper:\n        raise ValueError(\n            \"Please use `jqt.mesolve` for initial state inputs in density matrix form.\"\n        )\n\n    \u03c8 = \u03c8.to_ket()\n    dims = \u03c8.dims\n    \u03c8 = \u03c8.data\n\n    if isinstance(H, Qarray):\n        Ht_data = lambda t: H.data\n    else:\n        Ht_data = lambda t: H(t).data\n\n    ys = _sesolve_data(Ht_data, \u03c8, tlist, saveat_tlist,\n                       solver_options=solver_options)\n\n    return jnp2jqt(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmam","title":"<code>sigmam()</code>","text":"<p>\u03c3-</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3- Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmam() -&gt; Qarray:\n    \"\"\"\u03c3-\n\n    Returns:\n        \u03c3- Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 0.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmap","title":"<code>sigmap()</code>","text":"<p>\u03c3+</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3+ Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmap() -&gt; Qarray:\n    \"\"\"\u03c3+\n\n    Returns:\n        \u03c3+ Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [0.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sinm_data","title":"<code>sinm_data(data, **kwargs)</code>","text":"<p>Matrix sine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix sine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def sinm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix sine wrapper.\n\n    Args:\n        data: matrix\n\n    Returns:\n        matrix sine\n    \"\"\"\n    return (expm_data(1j * data) - expm_data(-1j * data)) / (2j)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.solve","title":"<code>solve(f, \u03c10, tlist, saveat_tlist, args, solver_options=None)</code>","text":"<p>Gets teh desired solver from diffrax.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>function defining the ODE</p> required <code>\u03c10</code> <p>initial state</p> required <code>tlist</code> <p>time list</p> required <code>saveat_tlist</code> <p>list of times at which to save the state pass in [-1] to save only at final time</p> required <code>args</code> <p>additional arguments to f</p> required <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>dictionary with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>solution</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def solve(f, \u03c10, tlist, saveat_tlist, args, solver_options: Optional[\n    SolverOptions] = None):\n    \"\"\"Gets teh desired solver from diffrax.\n\n    Args:\n        f: function defining the ODE\n        \u03c10: initial state\n        tlist: time list\n        saveat_tlist: list of times at which to save the state\n            pass in [-1] to save only at final time\n        args: additional arguments to f\n        solver_options: dictionary with solver options\n\n    Returns:\n        solution\n    \"\"\"\n\n    # f and ts\n    term = ODETerm(f)\n\n    if saveat_tlist.shape[0] == 1 and saveat_tlist == -1:\n        saveat = SaveAt(t1=True)\n    else:\n        saveat = SaveAt(ts=saveat_tlist)\n\n    # solver\n    solver_options = solver_options or SolverOptions.create()\n\n    solver_name = solver_options.solver\n    solver = getattr(diffrax, solver_name)()\n    stepsize_controller = PIDController(rtol=solver_options.rtol, atol=solver_options.atol)\n\n    # solve!\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\",\n                                message=\"Complex dtype support in Diffrax\",\n                                category=UserWarning)  # NOTE: suppresses complex dtype warning in diffrax\n        sol = diffeqsolve(\n            term,\n            solver,\n            t0=tlist[0],\n            t1=tlist[-1],\n            dt0=tlist[1] - tlist[0],\n            y0=\u03c10,\n            saveat=saveat,\n            stepsize_controller=stepsize_controller,\n            args=args,\n            max_steps=solver_options.max_steps,\n            progress_meter=CustomProgressMeter()\n            if solver_options.progress_meter\n            else NoProgressMeter(),\n        )\n\n    return sol\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.squeeze","title":"<code>squeeze(N, z)</code>","text":"<p>Single-mode Squeezing operator.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>z</code> <p>squeezing parameter</p> required <p>Returns:</p> Type Description <p>Sqeezing operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def squeeze(N, z):\n    \"\"\"Single-mode Squeezing operator.\n\n\n    Args:\n        N: Hilbert Space Size\n        z: squeezing parameter\n\n    Returns:\n        Sqeezing operator\n    \"\"\"\n\n    a = destroy(N)\n    op = (1 / 2.0) * jnp.conj(z) * (a @ a) - (1 / 2.0) * z * (a.dag() @ a.dag())\n    return op.expm()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <code>parallel</code> <code>bool</code> <p>if True, use parallel einsum for tensor product true: [A,B] ^ [C,D] = [A^C, B^D] false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n        parallel (bool): if True, use parallel einsum for tensor product\n            true: [A,B] ^ [C,D] = [A^C, B^D]\n            false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n\n    parallel = kwargs.pop(\"parallel\", False)\n\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    dims_0 = dims[0]\n    dims_1 = dims[1]\n    for arg in args[1:]:\n        if parallel:\n            a = data\n            b = arg.data\n\n            if len(a.shape) &gt; len(b.shape):\n                batch_dim = a.shape[:-2]\n            elif len(a.shape) == len(b.shape):\n                if prod(a.shape[:-2]) &gt; prod(b.shape[:-2]):\n                    batch_dim = a.shape[:-2]\n                else:\n                    batch_dim = b.shape[:-2]\n            else:\n                batch_dim = b.shape[:-2]\n\n            data = jnp.einsum(\"...ij,...kl-&gt;...ikjl\", a, b).reshape(\n                *batch_dim, a.shape[-2] * b.shape[-2], -1\n            )\n        else:\n            data = jnp.kron(data, arg.data, **kwargs)\n\n        dims_0 = dims_0 + arg.dims[0]\n        dims_1 = dims_1 + arg.dims[1]\n\n    return Qarray.create(data, dims=(dims_0, dims_1))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.tensor_basis","title":"<code>tensor_basis(single_basis, n)</code>","text":"<p>Construct n-fold tensor product basis from a single-system basis.</p> <p>Parameters:</p> Name Type Description Default <code>single_basis</code> <code>Qarray</code> <p>The single-system operator basis as a Qarray.</p> required <code>n</code> <code>int</code> <p>Number of tensor copies to construct.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Qarray containing the n-fold tensor product basis operators.</p> <code>Qarray</code> <p>The resulting basis has b^n elements where b is the number</p> <code>Qarray</code> <p>of operators in the single-system basis.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def tensor_basis(single_basis: Qarray, n: int) -&gt; Qarray:\n    \"\"\"Construct n-fold tensor product basis from a single-system basis.\n\n    Args:\n        single_basis: The single-system operator basis as a Qarray.\n        n: Number of tensor copies to construct.\n\n    Returns:\n        Qarray containing the n-fold tensor product basis operators.\n        The resulting basis has b^n elements where b is the number\n        of operators in the single-system basis.\n    \"\"\"\n\n    dims = single_basis.dims\n\n    single_basis = single_basis.data\n    b, d, _ = single_basis.shape\n    indices = jnp.stack(jnp.meshgrid(*[jnp.arange(b)] * n, indexing=\"ij\"),\n                        axis=-1).reshape(-1, n)  # shape (b^n, n)\n\n    # Select the operators based on indices: shape (b^n, n, d, d)\n    selected = single_basis[indices]  # shape: (b^n, n, d, d)\n\n    # Vectorized Kronecker products\n    full_basis = vmap(lambda ops: reduce(jnp.kron, ops))(selected)\n\n    new_dims = tuple(tuple(x**n for x in row) for row in dims)\n\n    return Qarray.create(full_basis, dims=new_dims, bdims=(b**n,))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.thermal_dm","title":"<code>thermal_dm(N, n)</code>","text":"<p>Thermal state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>n</code> <code>float</code> <p>average photon number.</p> required Return <p>Thermal state.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def thermal_dm(N: int, n: float) -&gt; Qarray:\n    \"\"\"Thermal state.\n\n    Args:\n        N: Hilbert Space Size.\n        n: average photon number.\n\n    Return:\n        Thermal state.\n    \"\"\"\n\n    beta = jnp.log(1 + 1 / n)\n\n    return Qarray.create(\n        jnp.where(\n            jnp.isposinf(beta),\n            basis(N, 0).to_dm().data,\n            jnp.diag(jnp.exp(-beta * jnp.linspace(0, N - 1, N))),\n        )\n    ).unit()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.tr","title":"<code>tr(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tr(qarr: Qarray, **kwargs) -&gt; Array:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Full trace.\n    \"\"\"\n    axis1 = kwargs.get(\"axis1\", -2)\n    axis2 = kwargs.get(\"axis2\", -1)\n    return jnp.trace(qarr.data, axis1=axis1, axis2=axis2, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.trace","title":"<code>trace(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def trace(qarr: Qarray, **kwargs) -&gt; Array:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Full trace.\n    \"\"\"\n    return tr(qarr, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.transpose","title":"<code>transpose(qarr, indices)</code>","text":"<p>Transpose the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>*args</code> <p>axes to transpose</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>tranposed Qarray</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def transpose(qarr: Qarray, indices: List[int]) -&gt; Qarray:\n    \"\"\"Transpose the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n        *args: axes to transpose\n\n    Returns:\n        tranposed Qarray\n    \"\"\"\n\n    indices = list(indices)\n\n    shaped_data = qarr.shaped_data\n    dims = qarr.dims\n    bdims_indxs = list(range(len(qarr.bdims)))\n\n    reshape_indices = indices + [j + len(dims[0]) for j in indices]\n\n    reshape_indices = bdims_indxs + [j + len(bdims_indxs) for j in reshape_indices]\n\n    shaped_data = shaped_data.transpose(reshape_indices)\n    new_dims = (\n        tuple([dims[0][j] for j in indices]),\n        tuple([dims[1][j] for j in indices]),\n    )\n\n    full_dims = prod(dims[0])\n    full_data = shaped_data.reshape(*qarr.bdims, full_dims, -1)\n    return Qarray.create(full_data, dims=new_dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.unit","title":"<code>unit(qarr)</code>","text":"<p>Normalize the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Normalized quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def unit(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Normalize the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Normalized quantum array\n    \"\"\"\n    return qarr / qarr.norm()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.wigner","title":"<code>wigner(psi, xvec, yvec, method='clenshaw', g=2)</code>","text":"<p>Wigner function for a state vector or density matrix at points <code>xvec + i * yvec</code>.</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.wigner--parameters","title":"Parameters","text":"Qarray <p>A state vector or density matrix.</p> array_like <p>x-coordinates at which to calculate the Wigner function.</p> array_like <p>y-coordinates at which to calculate the Wigner function.</p> float, default: 2 <p>Scaling factor for <code>a = 0.5 * g * (x + iy)</code>, default <code>g = 2</code>. The value of <code>g</code> is related to the value of <code>hbar</code> in the commutation relation <code>[x, y] = i * hbar</code> via <code>hbar=2/g^2</code>.</p> string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw' <p>Only 'clenshaw' is currently supported. Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' and 'iterative' use an iterative method to evaluate the Wigner functions for density matrices :math:<code>|m&gt;&lt;n|</code>, while 'laguerre' uses the Laguerre polynomials in scipy for the same task. The 'fft' method evaluates the Fourier transform of the density matrix. The 'iterative' method is default, and in general recommended, but the 'laguerre' method is more efficient for very sparse density matrices (e.g., superpositions of Fock states in a large Hilbert space). The 'clenshaw' method is the preferred method for dealing with density matrices that have a large number of excitations (&gt;~50). 'clenshaw' is a fast and numerically stable method.</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.wigner--returns","title":"Returns","text":"array <p>Values representing the Wigner function calculated over the specified range [xvec,yvec].</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.wigner--references","title":"References","text":"<p>Ulf Leonhardt, Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p> Source code in <code>jaxquantum/core/qp_distributions.py</code> <pre><code>def wigner(psi, xvec, yvec, method=\"clenshaw\", g=2):\n    \"\"\"Wigner function for a state vector or density matrix at points\n    `xvec + i * yvec`.\n\n    Parameters\n    ----------\n\n    state : Qarray\n        A state vector or density matrix.\n\n    xvec : array_like\n        x-coordinates at which to calculate the Wigner function.\n\n    yvec : array_like\n        y-coordinates at which to calculate the Wigner function.\n\n    g : float, default: 2\n        Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = 2`.\n        The value of `g` is related to the value of `hbar` in the commutation\n        relation `[x, y] = i * hbar` via `hbar=2/g^2`.\n\n    method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw'\n        Only 'clenshaw' is currently supported.\n        Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'\n        and 'iterative' use an iterative method to evaluate the Wigner functions for density\n        matrices :math:`|m&gt;&lt;n|`, while 'laguerre' uses the Laguerre polynomials\n        in scipy for the same task. The 'fft' method evaluates the Fourier\n        transform of the density matrix. The 'iterative' method is default, and\n        in general recommended, but the 'laguerre' method is more efficient for\n        very sparse density matrices (e.g., superpositions of Fock states in a\n        large Hilbert space). The 'clenshaw' method is the preferred method for\n        dealing with density matrices that have a large number of excitations\n        (&gt;~50). 'clenshaw' is a fast and numerically stable method.\n\n    Returns\n    -------\n\n    W : array\n        Values representing the Wigner function calculated over the specified\n        range [xvec,yvec].\n\n\n    References\n    ----------\n\n    Ulf Leonhardt,\n    Measuring the Quantum State of Light, (Cambridge University Press, 1997)\n\n    \"\"\"\n\n    if not (psi.is_vec() or psi.is_dm()):\n        raise TypeError(\"Input state is not a valid operator.\")\n\n    if method == \"fft\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    if method == \"iterative\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    elif method == \"laguerre\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    elif method == \"clenshaw\":\n        rho = psi.to_dm()\n        rho = rho.data\n\n        vmapped_wigner_clenshaw = [_wigner_clenshaw]\n\n        for _ in rho.shape[:-2]:\n            vmapped_wigner_clenshaw.append(\n                vmap(\n                    vmapped_wigner_clenshaw[-1],\n                    in_axes=(0, None, None, None),\n                    out_axes=0,\n                )\n            )\n        return vmapped_wigner_clenshaw[-1](rho, xvec, yvec, g)\n\n    else:\n        raise TypeError(\"method must be either 'iterative', 'laguerre', or 'fft'.\")\n</code></pre>"},{"location":"reference/jaxquantum/core/cfunctions.html","title":"cfunctions","text":""},{"location":"reference/jaxquantum/core/cfunctions.html#jaxquantum.core.cfunctions.cf_wigner","title":"<code>cf_wigner(psi, xvec, yvec)</code>","text":"<p>Wigner function for a state vector or density matrix at points <code>xvec + i * yvec</code>.</p>"},{"location":"reference/jaxquantum/core/cfunctions.html#jaxquantum.core.cfunctions.cf_wigner--parameters","title":"Parameters","text":"Qarray <p>A state vector or density matrix.</p> array_like <p>x-coordinates at which to calculate the Wigner function.</p> array_like <p>y-coordinates at which to calculate the Wigner function.</p>"},{"location":"reference/jaxquantum/core/cfunctions.html#jaxquantum.core.cfunctions.cf_wigner--returns","title":"Returns","text":"array <p>Values representing the Wigner function calculated over the specified range [xvec,yvec].</p> Source code in <code>jaxquantum/core/cfunctions.py</code> <pre><code>def cf_wigner(psi, xvec, yvec):\n    \"\"\"Wigner function for a state vector or density matrix at points\n    `xvec + i * yvec`.\n\n    Parameters\n    ----------\n\n    state : Qarray\n        A state vector or density matrix.\n\n    xvec : array_like\n        x-coordinates at which to calculate the Wigner function.\n\n    yvec : array_like\n        y-coordinates at which to calculate the Wigner function.\n\n\n    Returns\n    -------\n\n    W : array\n        Values representing the Wigner function calculated over the specified\n        range [xvec,yvec].\n\n\n    \"\"\"\n    N = psi.dims[0][0]\n    x, y = jnp.meshgrid(xvec, yvec)\n    alpha = x + 1.0j * y\n    displacement = jqt.displace(N, alpha)\n\n    vmapped_overlap = [vmap(vmap(jqt.overlap, in_axes=(None, 0)), in_axes=(\n        None, 0))]\n    for _ in psi.bdims:\n        vmapped_overlap.append(vmap(vmapped_overlap[-1], in_axes=(0, None)))\n\n    cf = vmapped_overlap[-1](psi, displacement)\n    return cf\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html","title":"conversions","text":"<p>Converting between different object types.</p>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.extract_dims","title":"<code>extract_dims(arr, dims=None)</code>","text":"<p>Extract dims from a JAX array or Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>JAX array or Qarray.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray dims.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def extract_dims(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"Extract dims from a JAX array or Qarray.\n\n    Args:\n        arr: JAX array or Qarray.\n        dims: Qarray dims.\n\n    Returns:\n        Qarray dims.\n    \"\"\"\n    if isinstance(dims[0], Number):\n        is_op = arr.shape[-2] == arr.shape[-1]\n        if is_op:\n            dims = [dims, dims]\n        else:\n            dims = [dims, [1] * len(dims)]  # defaults to ket\n    return dims\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.jnp2jqt","title":"<code>jnp2jqt(arr, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnp2jqt(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n        dims: Qarray dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    dims = extract_dims(arr, dims) if dims is not None else None\n    return Qarray.create(arr, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.jqt2qt","title":"<code>jqt2qt(jqt_obj)</code>","text":"<p>Qarray -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jqt_obj</code> <p>Qarray.</p> required <code>dims</code> <p>QuTiP dims.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqt2qt(jqt_obj):\n    \"\"\"Qarray -&gt; QuTiP state.\n\n    Args:\n        jqt_obj: Qarray.\n        dims: QuTiP dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    if isinstance(jqt_obj, Qobj) or jqt_obj is None:\n        return jqt_obj\n\n    if jqt_obj.is_batched:\n        res = []\n        for i in range(len(jqt_obj)):\n            res.append(jqt2qt(jqt_obj[i]))\n        return res\n\n    dims = [list(jqt_obj.dims[0]), list(jqt_obj.dims[1])]\n    return Qobj(np.array(jqt_obj.data), dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.qt2jqt","title":"<code>qt2jqt(qt_obj, dtype=jnp.complex128)</code>","text":"<p>QuTiP state -&gt; Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <code>dtype</code> <p>JAX dtype.</p> <code>complex128</code> <p>Returns:</p> Type Description <p>Qarray.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def qt2jqt(qt_obj, dtype=jnp.complex128):\n    \"\"\"QuTiP state -&gt; Qarray.\n\n    Args:\n        qt_obj: QuTiP state.\n        dtype: JAX dtype.\n\n    Returns:\n        Qarray.\n    \"\"\"\n    if isinstance(qt_obj, Qarray) or qt_obj is None:\n        return qt_obj\n    return Qarray.create(jnp.array(qt_obj.full(), dtype=dtype), dims=qt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/dims.html","title":"dims","text":"<p>dims.</p>"},{"location":"reference/jaxquantum/core/measurements.html","title":"measurements","text":"<p>Measurements.</p>"},{"location":"reference/jaxquantum/core/measurements.html#jaxquantum.core.measurements.QuantumStateTomography","title":"<code>QuantumStateTomography</code>","text":"Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>class QuantumStateTomography:\n    def __init__(\n        self,\n        rho_guess: Qarray,\n        measurement_basis: Qarray,\n        measurement_results: jnp.ndarray,\n        complete_basis: Optional[Qarray] = None,\n        true_rho: Optional[Qarray] = None,\n    ):\n        \"\"\"\n        Reconstruct a quantum state from measurement results using quantum state tomography.\n        The tomography can be performed either by direct inversion or by maximum likelihood estimation.\n\n        Args:\n            rho_guess (Qarray): The initial guess for the quantum state.\n            measurement_basis (Qarray): The basis in which measurements are performed.\n            measurement_results (jnp.ndarray): The results of the measurements.\n            complete_basis (Optional[Qarray]): The complete basis for state \n            reconstruction used when using direct inversion. \n            Defaults to the measurement basis if not provided.\n            true_rho (Optional[Qarray]): The true quantum state, if known.\n\n        \"\"\"\n        self.rho_guess = rho_guess.data\n        self.measurement_basis = measurement_basis.data\n        self.measurement_results = measurement_results\n        self.complete_basis = (\n            complete_basis.data\n            if (complete_basis is not None)\n            else measurement_basis.data\n        )\n        self.true_rho = true_rho\n        self._result = None\n\n    @property\n    def result(self) -&gt; Optional[MLETomographyResult]:\n        return self._result\n\n\n    def quantum_state_tomography_mle(\n        self, L1_reg_strength: float = 0.0, epochs: int = 10000, lr: float = 5e-3\n    ) -&gt; MLETomographyResult:\n        \"\"\"Perform quantum state tomography using maximum likelihood \n        estimation (MLE).\n\n        This method reconstructs the quantum state from measurement results \n        by optimizing\n        a likelihood function using gradient descent. The optimization \n        ensures the \n        resulting density matrix is positive semi-definite with trace 1.\n\n        Args:\n            L1_reg_strength (float, optional): Strength of L1 \n            regularization. Defaults to 0.0.\n            epochs (int, optional): Number of optimization iterations. \n            Defaults to 10000.\n            lr (float, optional): Learning rate for the Adam optimizer. \n            Defaults to 5e-3.\n\n        Returns:\n            MLETomographyResult: Named tuple containing:\n                - rho: Reconstructed quantum state as Qarray\n                - params_history: List of parameter values during optimization\n                - loss_history: List of loss values during optimization\n                - grads_history: List of gradient values during optimization\n                - infidelity_history: List of infidelities if true_rho was \n                provided, None otherwise\n        \"\"\"\n\n        dim = self.rho_guess.shape[0]\n        optimizer = optax.adam(lr)\n\n        # Initialize parameters from the initial guess for the density matrix\n        params = _parametrize_density_matrix(self.rho_guess, dim)\n        opt_state = optimizer.init(params)\n\n        compute_infidelity_flag = self.true_rho is not None\n\n        # Provide a dummy array if no true_rho is available. It won't be used.\n        true_rho_data_or_dummy = (\n            self.true_rho.data\n            if compute_infidelity_flag\n            else jnp.empty((dim, dim), dtype=jnp.complex64)\n        )\n\n        final_carry, history = _run_tomography_scan(\n            initial_params=params,\n            initial_opt_state=opt_state,\n            true_rho_data=true_rho_data_or_dummy,\n            measurement_basis=self.measurement_basis,\n            measurement_results=self.measurement_results,\n            dim=dim,\n            epochs=epochs,\n            optimizer=optimizer,\n            compute_infidelity=compute_infidelity_flag,\n            L1_reg_strength=L1_reg_strength,\n        )\n\n        final_params, _ = final_carry\n\n        rho = Qarray.create(_reconstruct_density_matrix(final_params, dim))\n\n        self._result = MLETomographyResult(\n            rho=rho,\n            params_history=history[\"params\"],\n            loss_history=history[\"loss\"],\n            grads_history=history[\"grads\"],\n            infidelity_history=history[\"infidelity\"]\n            if compute_infidelity_flag\n            else None,\n        )\n        return self._result\n\n    def quantum_state_tomography_direct(\n        self,\n    ) -&gt; Qarray:\n\n        \"\"\"Perform quantum state tomography using direct inversion.\n\n        This method reconstructs the quantum state from measurement results by \n        directly solving a system of linear equations. The method assumes that\n        the measurement basis is complete and the measurement results are \n        noise-free.\n\n        Returns:\n            Qarray: Reconstructed quantum state.\n        \"\"\"\n\n    # Compute overlaps of measurement and complete operator bases\n        A = jnp.einsum(\"ijk,ljk-&gt;il\", self.complete_basis, self.measurement_basis)\n        # Solve the linear system to find the coefficients\n        coefficients = jnp.linalg.solve(A, self.measurement_results)\n        # Reconstruct the density matrix\n        rho = jnp.einsum(\"i, ijk-&gt;jk\", coefficients, self.complete_basis)\n\n        return Qarray.create(rho)\n\n    def plot_results(self):\n        if self._result is None:\n            raise ValueError(\n                \"No results to plot. Run quantum_state_tomography_mle first.\"\n            )\n\n        fig, ax = plt.subplots(1, figsize=(5, 4))\n        if self._result.infidelity_history is not None:\n            ax2 = ax.twinx()\n\n        ax.plot(self._result.loss_history, color=\"C0\")\n        ax.set_xlabel(\"Epoch\")\n        ax.set_ylabel(\"$\\\\mathcal{L}$\", color=\"C0\")\n        ax.set_yscale(\"log\")\n\n        if self._result.infidelity_history is not None:\n            ax2.plot(self._result.infidelity_history, color=\"C1\")\n            ax2.set_yscale(\"log\")\n            ax2.set_ylabel(\"$1-\\\\mathcal{F}$\", color=\"C1\")\n            plt.grid(False)\n\n        plt.show()\n</code></pre>"},{"location":"reference/jaxquantum/core/measurements.html#jaxquantum.core.measurements.QuantumStateTomography.__init__","title":"<code>__init__(rho_guess, measurement_basis, measurement_results, complete_basis=None, true_rho=None)</code>","text":"<p>Reconstruct a quantum state from measurement results using quantum state tomography. The tomography can be performed either by direct inversion or by maximum likelihood estimation.</p> <p>Parameters:</p> Name Type Description Default <code>rho_guess</code> <code>Qarray</code> <p>The initial guess for the quantum state.</p> required <code>measurement_basis</code> <code>Qarray</code> <p>The basis in which measurements are performed.</p> required <code>measurement_results</code> <code>ndarray</code> <p>The results of the measurements.</p> required <code>complete_basis</code> <code>Optional[Qarray]</code> <p>The complete basis for state </p> <code>None</code> <code>true_rho</code> <code>Optional[Qarray]</code> <p>The true quantum state, if known.</p> <code>None</code> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def __init__(\n    self,\n    rho_guess: Qarray,\n    measurement_basis: Qarray,\n    measurement_results: jnp.ndarray,\n    complete_basis: Optional[Qarray] = None,\n    true_rho: Optional[Qarray] = None,\n):\n    \"\"\"\n    Reconstruct a quantum state from measurement results using quantum state tomography.\n    The tomography can be performed either by direct inversion or by maximum likelihood estimation.\n\n    Args:\n        rho_guess (Qarray): The initial guess for the quantum state.\n        measurement_basis (Qarray): The basis in which measurements are performed.\n        measurement_results (jnp.ndarray): The results of the measurements.\n        complete_basis (Optional[Qarray]): The complete basis for state \n        reconstruction used when using direct inversion. \n        Defaults to the measurement basis if not provided.\n        true_rho (Optional[Qarray]): The true quantum state, if known.\n\n    \"\"\"\n    self.rho_guess = rho_guess.data\n    self.measurement_basis = measurement_basis.data\n    self.measurement_results = measurement_results\n    self.complete_basis = (\n        complete_basis.data\n        if (complete_basis is not None)\n        else measurement_basis.data\n    )\n    self.true_rho = true_rho\n    self._result = None\n</code></pre>"},{"location":"reference/jaxquantum/core/measurements.html#jaxquantum.core.measurements.QuantumStateTomography.quantum_state_tomography_direct","title":"<code>quantum_state_tomography_direct()</code>","text":"<p>Perform quantum state tomography using direct inversion.</p> <p>This method reconstructs the quantum state from measurement results by  directly solving a system of linear equations. The method assumes that the measurement basis is complete and the measurement results are  noise-free.</p> <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Reconstructed quantum state.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def quantum_state_tomography_direct(\n    self,\n) -&gt; Qarray:\n\n    \"\"\"Perform quantum state tomography using direct inversion.\n\n    This method reconstructs the quantum state from measurement results by \n    directly solving a system of linear equations. The method assumes that\n    the measurement basis is complete and the measurement results are \n    noise-free.\n\n    Returns:\n        Qarray: Reconstructed quantum state.\n    \"\"\"\n\n# Compute overlaps of measurement and complete operator bases\n    A = jnp.einsum(\"ijk,ljk-&gt;il\", self.complete_basis, self.measurement_basis)\n    # Solve the linear system to find the coefficients\n    coefficients = jnp.linalg.solve(A, self.measurement_results)\n    # Reconstruct the density matrix\n    rho = jnp.einsum(\"i, ijk-&gt;jk\", coefficients, self.complete_basis)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/core/measurements.html#jaxquantum.core.measurements.QuantumStateTomography.quantum_state_tomography_mle","title":"<code>quantum_state_tomography_mle(L1_reg_strength=0.0, epochs=10000, lr=0.005)</code>","text":"<p>Perform quantum state tomography using maximum likelihood  estimation (MLE).</p> <p>This method reconstructs the quantum state from measurement results  by optimizing a likelihood function using gradient descent. The optimization  ensures the  resulting density matrix is positive semi-definite with trace 1.</p> <p>Parameters:</p> Name Type Description Default <code>L1_reg_strength</code> <code>float</code> <p>Strength of L1 </p> <code>0.0</code> <code>epochs</code> <code>int</code> <p>Number of optimization iterations. </p> <code>10000</code> <code>lr</code> <code>float</code> <p>Learning rate for the Adam optimizer. </p> <code>0.005</code> <p>Returns:</p> Name Type Description <code>MLETomographyResult</code> <code>MLETomographyResult</code> <p>Named tuple containing: - rho: Reconstructed quantum state as Qarray - params_history: List of parameter values during optimization - loss_history: List of loss values during optimization - grads_history: List of gradient values during optimization - infidelity_history: List of infidelities if true_rho was  provided, None otherwise</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def quantum_state_tomography_mle(\n    self, L1_reg_strength: float = 0.0, epochs: int = 10000, lr: float = 5e-3\n) -&gt; MLETomographyResult:\n    \"\"\"Perform quantum state tomography using maximum likelihood \n    estimation (MLE).\n\n    This method reconstructs the quantum state from measurement results \n    by optimizing\n    a likelihood function using gradient descent. The optimization \n    ensures the \n    resulting density matrix is positive semi-definite with trace 1.\n\n    Args:\n        L1_reg_strength (float, optional): Strength of L1 \n        regularization. Defaults to 0.0.\n        epochs (int, optional): Number of optimization iterations. \n        Defaults to 10000.\n        lr (float, optional): Learning rate for the Adam optimizer. \n        Defaults to 5e-3.\n\n    Returns:\n        MLETomographyResult: Named tuple containing:\n            - rho: Reconstructed quantum state as Qarray\n            - params_history: List of parameter values during optimization\n            - loss_history: List of loss values during optimization\n            - grads_history: List of gradient values during optimization\n            - infidelity_history: List of infidelities if true_rho was \n            provided, None otherwise\n    \"\"\"\n\n    dim = self.rho_guess.shape[0]\n    optimizer = optax.adam(lr)\n\n    # Initialize parameters from the initial guess for the density matrix\n    params = _parametrize_density_matrix(self.rho_guess, dim)\n    opt_state = optimizer.init(params)\n\n    compute_infidelity_flag = self.true_rho is not None\n\n    # Provide a dummy array if no true_rho is available. It won't be used.\n    true_rho_data_or_dummy = (\n        self.true_rho.data\n        if compute_infidelity_flag\n        else jnp.empty((dim, dim), dtype=jnp.complex64)\n    )\n\n    final_carry, history = _run_tomography_scan(\n        initial_params=params,\n        initial_opt_state=opt_state,\n        true_rho_data=true_rho_data_or_dummy,\n        measurement_basis=self.measurement_basis,\n        measurement_results=self.measurement_results,\n        dim=dim,\n        epochs=epochs,\n        optimizer=optimizer,\n        compute_infidelity=compute_infidelity_flag,\n        L1_reg_strength=L1_reg_strength,\n    )\n\n    final_params, _ = final_carry\n\n    rho = Qarray.create(_reconstruct_density_matrix(final_params, dim))\n\n    self._result = MLETomographyResult(\n        rho=rho,\n        params_history=history[\"params\"],\n        loss_history=history[\"loss\"],\n        grads_history=history[\"grads\"],\n        infidelity_history=history[\"infidelity\"]\n        if compute_infidelity_flag\n        else None,\n    )\n    return self._result\n</code></pre>"},{"location":"reference/jaxquantum/core/measurements.html#jaxquantum.core.measurements.fidelity","title":"<code>fidelity(rho, sigma, force_positivity=False)</code>","text":"<p>Fidelity between two states.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>Qarray</code> <p>state.</p> required <code>sigma</code> <code>Qarray</code> <p>state.</p> required <code>force_positivity</code> <code>bool</code> <p>force the states to be positive semidefinite</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Fidelity between rho and sigma.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def fidelity(rho: Qarray, sigma: Qarray, force_positivity: bool=False) -&gt; (\n        jnp.ndarray):\n    \"\"\"Fidelity between two states.\n\n    Args:\n        rho: state.\n        sigma: state.\n        force_positivity: force the states to be positive semidefinite\n\n    Returns:\n        Fidelity between rho and sigma.\n    \"\"\"\n    rho = rho.to_dm()\n    sigma = sigma.to_dm()\n\n    sqrt_rho = powm(rho, 0.5, clip_eigvals=force_positivity)\n\n    return jnp.real(((powm(sqrt_rho @ sigma @ sqrt_rho, 0.5,\n                           clip_eigvals=force_positivity)).tr())\n                    ** 2)\n</code></pre>"},{"location":"reference/jaxquantum/core/measurements.html#jaxquantum.core.measurements.overlap","title":"<code>overlap(rho, sigma)</code>","text":"<p>Overlap between two states or operators.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>Qarray</code> <p>state/operator.</p> required <code>sigma</code> <code>Qarray</code> <p>state/operator.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Overlap between rho and sigma.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def overlap(rho: Qarray, sigma: Qarray) -&gt; Array:\n    \"\"\"Overlap between two states or operators.\n\n    Args:\n        rho: state/operator.\n        sigma: state/operator.\n\n    Returns:\n        Overlap between rho and sigma.\n    \"\"\"\n\n    if rho.is_vec() and sigma.is_vec():\n        return jnp.abs(((rho.to_ket().dag() @ sigma.to_ket()).trace())) ** 2\n    elif rho.is_vec():\n        rho = rho.to_ket()\n        res = (rho.dag() @ sigma @ rho).data\n        return res.squeeze(-1).squeeze(-1)\n    elif sigma.is_vec():\n        sigma = sigma.to_ket()\n        res = (sigma.dag() @ rho @ sigma).data\n        return res.squeeze(-1).squeeze(-1)\n    else:\n        return (rho.dag() @ sigma).trace()\n</code></pre>"},{"location":"reference/jaxquantum/core/measurements.html#jaxquantum.core.measurements.tensor_basis","title":"<code>tensor_basis(single_basis, n)</code>","text":"<p>Construct n-fold tensor product basis from a single-system basis.</p> <p>Parameters:</p> Name Type Description Default <code>single_basis</code> <code>Qarray</code> <p>The single-system operator basis as a Qarray.</p> required <code>n</code> <code>int</code> <p>Number of tensor copies to construct.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Qarray containing the n-fold tensor product basis operators.</p> <code>Qarray</code> <p>The resulting basis has b^n elements where b is the number</p> <code>Qarray</code> <p>of operators in the single-system basis.</p> Source code in <code>jaxquantum/core/measurements.py</code> <pre><code>def tensor_basis(single_basis: Qarray, n: int) -&gt; Qarray:\n    \"\"\"Construct n-fold tensor product basis from a single-system basis.\n\n    Args:\n        single_basis: The single-system operator basis as a Qarray.\n        n: Number of tensor copies to construct.\n\n    Returns:\n        Qarray containing the n-fold tensor product basis operators.\n        The resulting basis has b^n elements where b is the number\n        of operators in the single-system basis.\n    \"\"\"\n\n    dims = single_basis.dims\n\n    single_basis = single_basis.data\n    b, d, _ = single_basis.shape\n    indices = jnp.stack(jnp.meshgrid(*[jnp.arange(b)] * n, indexing=\"ij\"),\n                        axis=-1).reshape(-1, n)  # shape (b^n, n)\n\n    # Select the operators based on indices: shape (b^n, n, d, d)\n    selected = single_basis[indices]  # shape: (b^n, n, d, d)\n\n    # Vectorized Kronecker products\n    full_basis = vmap(lambda ops: reduce(jnp.kron, ops))(selected)\n\n    new_dims = tuple(tuple(x**n for x in row) for row in dims)\n\n    return Qarray.create(full_basis, dims=new_dims, bdims=(b**n,))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html","title":"operators","text":"<p>States.</p>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.basis","title":"<code>basis(N, k)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert space dimension</p> required <code>k</code> <code>int</code> <p>fock number</p> required <p>Returns:</p> Type Description <p>Fock State |k&gt;</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis(N: int, k: int):\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.\n\n    Args:\n        N: Hilbert space dimension\n        k: fock number\n\n    Returns:\n        Fock State |k&gt;\n    \"\"\"\n    return Qarray.create(one_hot(k, N).reshape(N, 1))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.basis_like","title":"<code>basis_like(A, ks)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Qarray</code> <p>state or operator.</p> required <code>k</code> <p>fock number.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Fock State |k&gt; with the same space dims as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis_like(A: Qarray, ks: List[int]) -&gt; Qarray:\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.\n\n    Args:\n        A: state or operator.\n        k: fock number.\n\n    Returns:\n        Fock State |k&gt; with the same space dims as A.\n    \"\"\"\n    space_dims = A.space_dims\n    assert len(space_dims) == len(ks), \"len(ks) must be equal to len(space_dims)\"\n\n    kets = []\n    for j, k in enumerate(ks):\n        kets.append(basis(space_dims[j], k))\n    return tensor(*kets)\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.coherent","title":"<code>coherent(N, \u03b1)</code>","text":"<p>Coherent state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>\u03b1</code> <code>complex</code> <p>coherent state amplitude.</p> required Return <p>Coherent state |\u03b1\u27e9.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def coherent(N: int, \u03b1: complex) -&gt; Qarray:\n    \"\"\"Coherent state.\n\n    Args:\n        N: Hilbert Space Size.\n        \u03b1: coherent state amplitude.\n\n    Return:\n        Coherent state |\u03b1\u27e9.\n    \"\"\"\n    return displace(N, \u03b1) @ basis(N, 0)\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.displace","title":"<code>displace(N, \u03b1)</code>","text":"<p>Displacement operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>\u03b1</code> <p>Phase space displacement</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Displace operator D(\u03b1)</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def displace(N, \u03b1) -&gt; Qarray:\n    \"\"\"Displacement operator\n\n    Args:\n        N: Hilbert Space Size\n        \u03b1: Phase space displacement\n\n    Returns:\n        Displace operator D(\u03b1)\n    \"\"\"\n    a = destroy(N)\n    return (\u03b1 * a.dag() - jnp.conj(\u03b1) * a).expm()\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.hadamard","title":"<code>hadamard()</code>","text":"<p>H</p> <p>Returns:</p> Name Type Description <code>H</code> <code>Qarray</code> <p>Hadamard gate</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def hadamard() -&gt; Qarray:\n    \"\"\"H\n\n    Returns:\n        H: Hadamard gate\n    \"\"\"\n    return Qarray.create(jnp.array([[1, 1], [1, -1]]) / jnp.sqrt(2))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.identity_like","title":"<code>identity_like(A)</code>","text":"<p>Identity matrix with the same shape as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <p>Matrix.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix with the same shape as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity_like(A) -&gt; Qarray:\n    \"\"\"Identity matrix with the same shape as A.\n\n    Args:\n        A: Matrix.\n\n    Returns:\n        Identity matrix with the same shape as A.\n    \"\"\"\n    space_dims = A.space_dims\n    total_dim = prod(space_dims)\n    return Qarray.create(jnp.eye(total_dim, total_dim), dims=[space_dims, space_dims])\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.multi_mode_basis_set","title":"<code>multi_mode_basis_set(Ns)</code>","text":"<p>Creates a multi-mode basis set.</p> <p>Parameters:</p> Name Type Description Default <code>Ns</code> <code>List[int]</code> <p>List of Hilbert space dimensions for each mode.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Multi-mode basis set.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def multi_mode_basis_set(Ns: List[int]) -&gt; Qarray:\n    \"\"\"Creates a multi-mode basis set.\n\n    Args:\n        Ns: List of Hilbert space dimensions for each mode.\n\n    Returns:\n        Multi-mode basis set.\n    \"\"\"\n    data = jnp.eye(prod(Ns))\n    dims = (tuple(Ns), tuple([1 for _ in Ns]))\n    return Qarray.create(data, dims=dims, bdims=(prod(Ns),))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.num","title":"<code>num(N)</code>","text":"<p>Number operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>number operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def num(N) -&gt; Qarray:\n    \"\"\"Number operator\n\n    Args:\n        N: Hilbert Space size\n\n    Returns:\n        number operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.arange(N)))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.qubit_rotation","title":"<code>qubit_rotation(theta, nx, ny, nz)</code>","text":"<p>Single qubit rotation.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>rotation angle.</p> required <code>nx</code> <p>rotation axis x component.</p> required <code>ny</code> <p>rotation axis y component.</p> required <code>nz</code> <p>rotation axis z component.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Single qubit rotation operator.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def qubit_rotation(theta: float, nx, ny, nz) -&gt; Qarray:\n    \"\"\"Single qubit rotation.\n\n    Args:\n        theta: rotation angle.\n        nx: rotation axis x component.\n        ny: rotation axis y component.\n        nz: rotation axis z component.\n\n    Returns:\n        Single qubit rotation operator.\n    \"\"\"\n    return jnp.cos(theta / 2) * identity(2) - 1j * jnp.sin(theta / 2) * (\n        nx * sigmax() + ny * sigmay() + nz * sigmaz()\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmam","title":"<code>sigmam()</code>","text":"<p>\u03c3-</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3- Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmam() -&gt; Qarray:\n    \"\"\"\u03c3-\n\n    Returns:\n        \u03c3- Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 0.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmap","title":"<code>sigmap()</code>","text":"<p>\u03c3+</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3+ Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmap() -&gt; Qarray:\n    \"\"\"\u03c3+\n\n    Returns:\n        \u03c3+ Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [0.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.squeeze","title":"<code>squeeze(N, z)</code>","text":"<p>Single-mode Squeezing operator.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>z</code> <p>squeezing parameter</p> required <p>Returns:</p> Type Description <p>Sqeezing operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def squeeze(N, z):\n    \"\"\"Single-mode Squeezing operator.\n\n\n    Args:\n        N: Hilbert Space Size\n        z: squeezing parameter\n\n    Returns:\n        Sqeezing operator\n    \"\"\"\n\n    a = destroy(N)\n    op = (1 / 2.0) * jnp.conj(z) * (a @ a) - (1 / 2.0) * z * (a.dag() @ a.dag())\n    return op.expm()\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.thermal_dm","title":"<code>thermal_dm(N, n)</code>","text":"<p>Thermal state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>n</code> <code>float</code> <p>average photon number.</p> required Return <p>Thermal state.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def thermal_dm(N: int, n: float) -&gt; Qarray:\n    \"\"\"Thermal state.\n\n    Args:\n        N: Hilbert Space Size.\n        n: average photon number.\n\n    Return:\n        Thermal state.\n    \"\"\"\n\n    beta = jnp.log(1 + 1 / n)\n\n    return Qarray.create(\n        jnp.where(\n            jnp.isposinf(beta),\n            basis(N, 0).to_dm().data,\n            jnp.diag(jnp.exp(-beta * jnp.linspace(0, N - 1, N))),\n        )\n    ).unit()\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html","title":"qarray","text":"<p>QArray.</p>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray","title":"<code>Qarray</code>","text":"Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@struct.dataclass  # this allows us to send in and return Qarray from jitted functions\nclass Qarray:\n    _data: Array\n    _qdims: Qdims = struct.field(pytree_node=False)\n    _bdims: tuple[int] = struct.field(pytree_node=False)\n\n    # Initialization ----\n    @classmethod\n    def create(cls, data, dims=None, bdims=None):\n        # Step 1: Prepare data ----\n        data = jnp.asarray(data)\n\n        if len(data.shape) == 1 and data.shape[0] &gt; 0:\n            data = data.reshape(data.shape[0], 1)\n\n        if len(data.shape) &gt;= 2:\n            if data.shape[-2] != data.shape[-1] and not (\n                data.shape[-2] == 1 or data.shape[-1] == 1\n            ):\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n\n        if bdims is not None:\n            if len(data.shape) - len(bdims) == 1:\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n        # ----\n\n        # Step 2: Prepare dimensions ----\n        if bdims is None:\n            bdims = tuple(data.shape[:-2])\n\n        if dims is None:\n            dims = ((data.shape[-2],), (data.shape[-1],))\n\n        if not isinstance(dims[0], (list, tuple)):\n            # This handles the case where only the hilbert space dimensions are sent in.\n            if data.shape[-1] == 1:\n                dims = (tuple(dims), tuple([1 for _ in dims]))\n            elif data.shape[-2] == 1:\n                dims = (tuple([1 for _ in dims]), tuple(dims))\n            else:\n                dims = (tuple(dims), tuple(dims))\n        else:\n            dims = (tuple(dims[0]), tuple(dims[1]))\n\n        check_dims(dims, bdims, data.shape)\n\n        qdims = Qdims(dims)\n\n        # NOTE: Constantly tidying up on Qarray creation might be a bit overkill.\n        # It increases the compilation time, but only very slightly\n        # increased the runtime of the jit compiled function.\n        # We could instead use this tidy_up where we think we need it.\n        data = tidy_up(data, SETTINGS[\"auto_tidyup_atol\"])\n\n        return cls(data, qdims, bdims)\n\n    # ----\n\n    @classmethod\n    def from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n        \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n        data = jnp.array([qarr.data for qarr in qarr_list])\n\n        if len(qarr_list) == 0:\n            dims = ((), ())\n            bdims = ()\n        else:\n            dims = qarr_list[0].dims\n            bdims = qarr_list[0].bdims\n\n        if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n            raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n        bdims = (len(qarr_list),) + bdims\n\n        return cls.create(data, dims=dims, bdims=bdims)\n\n    @classmethod\n    def from_array(cls, qarr_arr) -&gt; Qarray:\n        \"\"\"Create a Qarray from a nested list of Qarrays.\n\n        Args:\n            qarr_arr (list): nested list of Qarrays\n\n        Returns:\n            Qarray: Qarray object\n        \"\"\"\n        if isinstance(qarr_arr, Qarray):\n            return qarr_arr\n\n        bdims = ()\n        lvl = qarr_arr\n        while not isinstance(lvl, Qarray):\n            bdims = bdims + (len(lvl),)\n            if len(lvl) &gt; 0:\n                lvl = lvl[0]\n            else:\n                break\n\n        def flat(lis):\n            flatList = []\n            for element in lis:\n                if type(element) is list:\n                    flatList += flat(element)\n                else:\n                    flatList.append(element)\n            return flatList\n\n        qarr_list = flat(qarr_arr)\n        qarr = cls.from_list(qarr_list)\n        qarr = qarr.reshape_bdims(*bdims)\n        return qarr\n\n    # Properties ----\n    @property\n    def qtype(self):\n        return self._qdims.qtype\n\n    @property\n    def dtype(self):\n        return self._data.dtype\n\n    @property\n    def dims(self):\n        return self._qdims.dims\n\n    @property\n    def bdims(self):\n        return self._bdims\n\n    @property\n    def qdims(self):\n        return self._qdims\n\n    @property\n    def space_dims(self):\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return self.dims[0]\n        elif self.qtype == Qtypes.bra:\n            return self.dims[1]\n        else:\n            # TODO: not reached for some reason\n            raise ValueError(\"Unsupported qtype.\")\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def shaped_data(self):\n        return self._data.reshape(self.bdims + self.dims[0] + self.dims[1])\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def is_batched(self):\n        return len(self.bdims) &gt; 0\n\n    def __getitem__(self, index):\n        if len(self.bdims) &gt; 0:\n            return Qarray.create(\n                self.data[index],\n                dims=self.dims,\n            )\n        else:\n            raise ValueError(\"Cannot index a non-batched Qarray.\")\n\n    def reshape_bdims(self, *args):\n        \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n        new_bdims = tuple(args)\n\n        if prod(new_bdims) == 0:\n            new_shape = new_bdims\n        else:\n            new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n        return Qarray.create(\n            self.data.reshape(new_shape),\n            dims=self.dims,\n            bdims=new_bdims,\n        )\n\n    def space_to_qdims(self, space_dims: List[int]):\n        if isinstance(space_dims[0], (list, tuple)):\n            return space_dims\n\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return (tuple(space_dims), tuple([1 for _ in range(len(space_dims))]))\n        elif self.qtype == Qtypes.bra:\n            return (tuple([1 for _ in range(len(space_dims))]), tuple(space_dims))\n        else:\n            raise ValueError(\"Unsupported qtype for space_to_qdims conversion.\")\n\n    def reshape_qdims(self, *args):\n        \"\"\"Reshape the quantum dimensions of the Qarray.\n\n        Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n        Args:\n            *args: new Hilbert dimensions for the Qarray.\n\n        Returns:\n            Qarray: reshaped Qarray.\n        \"\"\"\n\n        new_space_dims = tuple(args)\n        current_space_dims = self.space_dims\n        assert prod(new_space_dims) == prod(current_space_dims)\n\n        new_qdims = self.space_to_qdims(new_space_dims)\n        new_bdims = self.bdims\n\n        return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n\n    def resize(self, new_shape):\n        \"\"\"Resize the Qarray to a new shape.\n\n        TODO: review and maybe deprecate this method.\n        \"\"\"\n        dims = self.dims\n        data = jnp.resize(self.data, new_shape)\n        return Qarray.create(\n            data,\n            dims=dims,\n        )\n\n    def __len__(self):\n        \"\"\"Length of the Qarray.\"\"\"\n        if len(self.bdims) &gt; 0:\n            return self.data.shape[0]\n        else:\n            raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Qarray):\n            raise ValueError(\"Cannot calculate equality of a Qarray with a non-Qarray.\")\n\n        if self.dims != other.dims:\n            return False\n\n        if self.bdims != other.bdims:\n            return False\n\n        return jnp.all(self.data == other.data)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # ----\n\n    # Elementary Math ----\n    def __matmul__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        _qdims_new = self._qdims @ other._qdims\n        return Qarray.create(\n            self.data @ other.data,\n            dims=_qdims_new.dims,\n        )\n\n    # NOTE: not possible to reach this.\n    # def __rmatmul__(self, other):\n    #     if not isinstance(other, Qarray):\n    #         return NotImplemented\n\n    #     _qdims_new = other._qdims @ self._qdims\n    #     return Qarray.create(\n    #         other.data @ self.data,\n    #         dims=_qdims_new.dims,\n    #     )\n\n    def __mul__(self, other):\n        if isinstance(other, Qarray):\n            return self.__matmul__(other)\n\n        other = other + 0.0j\n        if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n            other = other.reshape(other.shape + (1, 1))\n\n        return Qarray.create(\n            other * self.data,\n            dims=self._qdims.dims,\n        )\n\n    def __rmul__(self, other):\n        # NOTE: not possible to reach this.\n        # if isinstance(other, Qarray):\n        #     return self.__rmatmul__(other)\n\n        return self.__mul__(other)\n\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    def __truediv__(self, other):\n        \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n        if isinstance(other, Qarray):\n            raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n        return self.__mul__(1 / other)\n\n    def __add__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data + other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__add__(other)\n\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data - other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__sub__(other)\n\n        return NotImplemented\n\n    def __rsub__(self, other):\n        return self.__neg__().__add__(other)\n\n    def __xor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(self, other)\n\n    def __rxor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(other, self)\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n\n        return powm(self, other)\n\n    # ----\n\n    # String Representation ----\n    def _str_header(self):\n        out = \", \".join(\n            [\n                \"Quantum array: dims = \" + str(self.dims),\n                \"bdims = \" + str(self.bdims),\n                \"shape = \" + str(self._data.shape),\n                \"type = \" + str(self.qtype),\n            ]\n        )\n        return out\n\n    def __str__(self):\n        return self._str_header() + \"\\nQarray data =\\n\" + str(self.data)\n\n    @property\n    def header(self):\n        \"\"\"Print the header of the Qarray.\"\"\"\n        return self._str_header()\n\n    def __repr__(self):\n        return self.__str__()\n\n    # ----\n\n    # Utilities ----\n    def copy(self, memo=None):\n        # return Qarray.create(deepcopy(self.data), dims=self.dims)\n        return self.__deepcopy__(memo)\n\n    def __deepcopy__(self, memo):\n        \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n        return Qarray(\n            _data=deepcopy(self._data, memo=memo),\n            _qdims=deepcopy(self._qdims, memo=memo),\n            _bdims=deepcopy(self._bdims, memo=memo),\n        )\n\n    def __getattr__(self, method_name):\n        if \"__\" == method_name[:2]:\n            # NOTE: we return NotImplemented for binary special methods logic in python, plus things like __jax_array__\n            return lambda *args, **kwargs: NotImplemented\n\n        modules = [jnp, jnp.linalg, jsp, jsp.linalg]\n\n        method_f = None\n        for mod in modules:\n            method_f = getattr(mod, method_name, None)\n            if method_f is not None:\n                break\n\n        if method_f is None:\n            raise NotImplementedError(\n                f\"Method {method_name} does not exist. No backup method found in {modules}.\"\n            )\n\n        def func(*args, **kwargs):\n            res = method_f(self.data, *args, **kwargs)\n\n            if getattr(res, \"shape\", None) is None or res.shape != self.data.shape:\n                return res\n            else:\n                return Qarray.create(res, dims=self._qdims.dims)\n\n        return func\n\n    # ----\n\n    # Conversions / Reshaping ----\n    def dag(self):\n        return dag(self)\n\n    def to_dm(self):\n        return ket2dm(self)\n\n    def is_dm(self):\n        return self.qtype == Qtypes.oper\n\n    def is_vec(self):\n        return self.qtype == Qtypes.ket or self.qtype == Qtypes.bra\n\n    def to_ket(self):\n        return to_ket(self)\n\n    def transpose(self, *args):\n        return transpose(self, *args)\n\n    def keep_only_diag_elements(self):\n        return keep_only_diag_elements(self)\n\n    # ----\n\n    # Math Functions ----\n    def unit(self):\n        return unit(self)\n\n    def norm(self):\n        return norm(self)\n\n    def expm(self):\n        return expm(self)\n\n    def powm(self, n):\n        return powm(self, n)\n\n    def cosm(self):\n        return cosm(self)\n\n    def sinm(self):\n        return sinm(self)\n\n    def tr(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def trace(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def ptrace(self, indx):\n        return ptrace(self, indx)\n\n    def eigenstates(self):\n        return eigenstates(self)\n\n    def eigenenergies(self):\n        return eigenenergies(self)\n\n    def collapse(self, mode=\"sum\"):\n        return collapse(self, mode=mode)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.header","title":"<code>header</code>  <code>property</code>","text":"<p>Print the header of the Qarray.</p>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Need to override this when defininig getattr.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n    return Qarray(\n        _data=deepcopy(self._data, memo=memo),\n        _qdims=deepcopy(self._qdims, memo=memo),\n        _bdims=deepcopy(self._bdims, memo=memo),\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.__len__","title":"<code>__len__()</code>","text":"<p>Length of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __len__(self):\n    \"\"\"Length of the Qarray.\"\"\"\n    if len(self.bdims) &gt; 0:\n        return self.data.shape[0]\n    else:\n        raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>For Qarray's, this only really makes sense in the context of division by a scalar.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n    if isinstance(other, Qarray):\n        raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n    return self.__mul__(1 / other)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.from_array","title":"<code>from_array(qarr_arr)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a nested list of Qarrays.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_arr</code> <code>list</code> <p>nested list of Qarrays</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Qarray object</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_array(cls, qarr_arr) -&gt; Qarray:\n    \"\"\"Create a Qarray from a nested list of Qarrays.\n\n    Args:\n        qarr_arr (list): nested list of Qarrays\n\n    Returns:\n        Qarray: Qarray object\n    \"\"\"\n    if isinstance(qarr_arr, Qarray):\n        return qarr_arr\n\n    bdims = ()\n    lvl = qarr_arr\n    while not isinstance(lvl, Qarray):\n        bdims = bdims + (len(lvl),)\n        if len(lvl) &gt; 0:\n            lvl = lvl[0]\n        else:\n            break\n\n    def flat(lis):\n        flatList = []\n        for element in lis:\n            if type(element) is list:\n                flatList += flat(element)\n            else:\n                flatList.append(element)\n        return flatList\n\n    qarr_list = flat(qarr_arr)\n    qarr = cls.from_list(qarr_list)\n    qarr = qarr.reshape_bdims(*bdims)\n    return qarr\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.from_list","title":"<code>from_list(qarr_list)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a list of Qarrays.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n    \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n    data = jnp.array([qarr.data for qarr in qarr_list])\n\n    if len(qarr_list) == 0:\n        dims = ((), ())\n        bdims = ()\n    else:\n        dims = qarr_list[0].dims\n        bdims = qarr_list[0].bdims\n\n    if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n        raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n    bdims = (len(qarr_list),) + bdims\n\n    return cls.create(data, dims=dims, bdims=bdims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.reshape_bdims","title":"<code>reshape_bdims(*args)</code>","text":"<p>Reshape the batch dimensions of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_bdims(self, *args):\n    \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n    new_bdims = tuple(args)\n\n    if prod(new_bdims) == 0:\n        new_shape = new_bdims\n    else:\n        new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n    return Qarray.create(\n        self.data.reshape(new_shape),\n        dims=self.dims,\n        bdims=new_bdims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.reshape_qdims","title":"<code>reshape_qdims(*args)</code>","text":"<p>Reshape the quantum dimensions of the Qarray.</p> <p>Note that this does not take in qdims but rather the new Hilbert space dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>new Hilbert dimensions for the Qarray.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>reshaped Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_qdims(self, *args):\n    \"\"\"Reshape the quantum dimensions of the Qarray.\n\n    Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n    Args:\n        *args: new Hilbert dimensions for the Qarray.\n\n    Returns:\n        Qarray: reshaped Qarray.\n    \"\"\"\n\n    new_space_dims = tuple(args)\n    current_space_dims = self.space_dims\n    assert prod(new_space_dims) == prod(current_space_dims)\n\n    new_qdims = self.space_to_qdims(new_space_dims)\n    new_bdims = self.bdims\n\n    return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.Qarray.resize","title":"<code>resize(new_shape)</code>","text":"<p>Resize the Qarray to a new shape.</p> <p>TODO: review and maybe deprecate this method.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def resize(self, new_shape):\n    \"\"\"Resize the Qarray to a new shape.\n\n    TODO: review and maybe deprecate this method.\n    \"\"\"\n    dims = self.dims\n    data = jnp.resize(self.data, new_shape)\n    return Qarray.create(\n        data,\n        dims=dims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.collapse","title":"<code>collapse(qarr, mode='sum')</code>","text":"<p>Collapse the Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Collapsed quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def collapse(qarr: Qarray, mode=\"sum\") -&gt; Qarray:\n    \"\"\"Collapse the Qarray.\n\n    Args:\n        qarr (Qarray): quantum array array\n\n    Returns:\n        Collapsed quantum array\n    \"\"\"\n    if mode == \"sum\":\n        if len(qarr.bdims) == 0:\n            return qarr\n\n        batch_axes = list(range(len(qarr.bdims)))\n        return Qarray.create(jnp.sum(qarr.data, axis=batch_axes), dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.concatenate","title":"<code>concatenate(qarr_list, axis=0)</code>","text":"<p>Concatenate a list of Qarrays along a specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_list</code> <code>List[Qarray]</code> <p>List of Qarrays to concatenate.</p> required <code>axis</code> <code>int</code> <p>Axis along which to concatenate. Default is 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Concatenated Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def concatenate(qarr_list: List[Qarray], axis: int = 0) -&gt; Qarray:\n    \"\"\"Concatenate a list of Qarrays along a specified axis.\n\n    Args:\n        qarr_list (List[Qarray]): List of Qarrays to concatenate.\n        axis (int): Axis along which to concatenate. Default is 0.\n\n    Returns:\n        Qarray: Concatenated Qarray.\n    \"\"\"\n\n    non_empty_qarr_list = [qarr for qarr in qarr_list if len(qarr.data) != 0]\n\n    if len(non_empty_qarr_list) == 0:\n        return Qarray.from_list([])\n\n    concatenated_data = jnp.concatenate(\n        [qarr.data for qarr in non_empty_qarr_list], axis=axis\n    )\n\n    dims = non_empty_qarr_list[0].dims\n    return Qarray.create(concatenated_data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.cosm","title":"<code>cosm(qarr)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Matrix cosine wrapper.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    dims = qarr.dims\n    data = cosm_data(qarr.data)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.cosm_data","title":"<code>cosm_data(data, **kwargs)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix cosine wrapper.\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    return (expm_data(1j * data) + expm_data(-1j * data)) / 2\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.dag","title":"<code>dag(qarr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>conjugate transpose of qarr</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        conjugate transpose of qarr\n    \"\"\"\n    dims = qarr.dims[::-1]\n\n    data = dag_data(qarr.data)\n\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.dag_data","title":"<code>dag_data(arr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag_data(arr: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        arr: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    # TODO: revisit this case...\n    if len(arr.shape) == 1:\n        return jnp.conj(arr)\n\n    return jnp.moveaxis(\n        jnp.conj(arr), -1, -2\n    )  # transposes last two axes, good for batching\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.eigenenergies","title":"<code>eigenenergies(qarr)</code>","text":"<p>Eigenvalues of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>eigenvalues</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenenergies(qarr: Qarray) -&gt; Array:\n    \"\"\"Eigenvalues of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues\n    \"\"\"\n\n    evals = jnp.linalg.eigvalsh(qarr.data)\n    return evals\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.eigenstates","title":"<code>eigenstates(qarr)</code>","text":"<p>Eigenstates of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>eigenvalues and eigenstates</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenstates(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Eigenstates of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues and eigenstates\n    \"\"\"\n\n    evals, evecs = jnp.linalg.eigh(qarr.data)\n    idxs_sorted = jnp.argsort(evals, axis=-1)\n\n    dims = ket_from_op_dims(qarr.dims)\n\n    evals = jnp.take_along_axis(evals, idxs_sorted, axis=-1)\n    evecs = jnp.take_along_axis(evecs, idxs_sorted[..., None, :], axis=-1)\n\n    # numpy returns [batch, :, i] as the i-th eigenvector\n    # we want [batch, i, :] as the i-th eigenvector\n    evecs = jnp.swapaxes(evecs, -2, -1)\n\n    evecs = Qarray.create(\n        evecs,\n        dims=dims,\n        bdims=evecs.shape[:-1],\n    )\n\n    return evals, evecs\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.expm","title":"<code>expm(qarr, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm(qarr: Qarray, **kwargs) -&gt; Qarray:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    dims = qarr.dims\n    data = expm_data(qarr.data, **kwargs)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.expm_data","title":"<code>expm_data(data, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    return jsp.linalg.expm(data, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.is_dm_data","title":"<code>is_dm_data(data)</code>","text":"<p>Check if data is a density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:     True if data is a density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def is_dm_data(data: Array) -&gt; bool:\n    \"\"\"Check if data is a density matrix.\n\n    Args:\n        data: matrix\n    Returns:\n        True if data is a density matrix\n    \"\"\"\n    return data.shape[-2] == data.shape[-1]\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.ket2dm","title":"<code>ket2dm(qarr)</code>","text":"<p>Turns ket into density matrix. Does nothing if already operator.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>qarr</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ket2dm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Turns ket into density matrix.\n    Does nothing if already operator.\n\n    Args:\n        qarr (Qarray): qarr\n\n    Returns:\n        Density matrix\n    \"\"\"\n\n    if qarr.qtype == Qtypes.oper:\n        return qarr\n\n    if qarr.qtype == Qtypes.bra:\n        qarr = qarr.dag()\n\n    return qarr @ qarr.dag()\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.powm","title":"<code>powm(qarr, n, clip_eigvals=False)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>n</code> <code>int</code> <p>power</p> required <code>clip_eigvals</code> <code>bool</code> <p>clip eigenvalues to always be able to compute</p> <code>False</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm(qarr: Qarray, n: Union[int, float], clip_eigvals=False) -&gt; Qarray:\n    \"\"\"Matrix power.\n\n    Args:\n        qarr (Qarray): quantum array\n        n (int): power\n        clip_eigvals (bool): clip eigenvalues to always be able to compute\n        non-integer powers\n\n    Returns:\n        matrix power\n    \"\"\"\n    if isinstance(n, int):\n        data_res = jnp.linalg.matrix_power(qarr.data, n)\n    else:\n        evalues, evectors = jnp.linalg.eig(qarr.data)\n        if clip_eigvals:\n            evalues = jnp.maximum(evalues, 0)\n        else:\n            if not (evalues &gt;= 0).all():\n                raise ValueError(\n                    \"Non-integer power of a matrix can only be \"\n                    \"computed if the matrix is positive semi-definite.\"\n                    \"Got a matrix with a negative eigenvalue.\"\n                )\n        data_res = evectors * jnp.pow(evalues, n) @ jnp.linalg.inv(evectors)\n    return Qarray.create(data_res, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.powm_data","title":"<code>powm_data(data, n)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <code>n</code> <code>int</code> <p>power</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm_data(data: Array, n: int) -&gt; Array:\n    \"\"\"Matrix power.\n\n    Args:\n        data: matrix\n        n: power\n\n    Returns:\n        matrix power\n    \"\"\"\n    return jnp.linalg.matrix_power(data, n)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.ptrace","title":"<code>ptrace(qarr, indx)</code>","text":"<p>Partial Trace.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <p>density matrix</p> required <code>indx</code> <p>index of quantum object to keep, rest will be partial traced out</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>partial traced out density matrix</p> <p>TODO: Fix weird tracing errors that arise with reshape</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ptrace(qarr: Qarray, indx) -&gt; Qarray:\n    \"\"\"Partial Trace.\n\n    Args:\n        rho: density matrix\n        indx: index of quantum object to keep, rest will be partial traced out\n\n    Returns:\n        partial traced out density matrix\n\n    TODO: Fix weird tracing errors that arise with reshape\n    \"\"\"\n\n    qarr = ket2dm(qarr)\n    rho = qarr.shaped_data\n    dims = qarr.dims\n\n    Nq = len(dims[0])\n\n    indxs = [indx, indx + Nq]\n    for j in range(Nq):\n        if j == indx:\n            continue\n        indxs.append(j)\n        indxs.append(j + Nq)\n\n    bdims = qarr.bdims\n    len_bdims = len(bdims)\n    bdims_indxs = list(range(len_bdims))\n    indxs = bdims_indxs + [j + len_bdims for j in indxs]\n    rho = rho.transpose(indxs)\n\n    for j in range(Nq - 1):\n        rho = jnp.trace(rho, axis1=2 + len_bdims, axis2=3 + len_bdims)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.sinm_data","title":"<code>sinm_data(data, **kwargs)</code>","text":"<p>Matrix sine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix sine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def sinm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix sine wrapper.\n\n    Args:\n        data: matrix\n\n    Returns:\n        matrix sine\n    \"\"\"\n    return (expm_data(1j * data) - expm_data(-1j * data)) / (2j)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <code>parallel</code> <code>bool</code> <p>if True, use parallel einsum for tensor product true: [A,B] ^ [C,D] = [A^C, B^D] false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n        parallel (bool): if True, use parallel einsum for tensor product\n            true: [A,B] ^ [C,D] = [A^C, B^D]\n            false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n\n    parallel = kwargs.pop(\"parallel\", False)\n\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    dims_0 = dims[0]\n    dims_1 = dims[1]\n    for arg in args[1:]:\n        if parallel:\n            a = data\n            b = arg.data\n\n            if len(a.shape) &gt; len(b.shape):\n                batch_dim = a.shape[:-2]\n            elif len(a.shape) == len(b.shape):\n                if prod(a.shape[:-2]) &gt; prod(b.shape[:-2]):\n                    batch_dim = a.shape[:-2]\n                else:\n                    batch_dim = b.shape[:-2]\n            else:\n                batch_dim = b.shape[:-2]\n\n            data = jnp.einsum(\"...ij,...kl-&gt;...ikjl\", a, b).reshape(\n                *batch_dim, a.shape[-2] * b.shape[-2], -1\n            )\n        else:\n            data = jnp.kron(data, arg.data, **kwargs)\n\n        dims_0 = dims_0 + arg.dims[0]\n        dims_1 = dims_1 + arg.dims[1]\n\n    return Qarray.create(data, dims=(dims_0, dims_1))\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.tr","title":"<code>tr(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tr(qarr: Qarray, **kwargs) -&gt; Array:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Full trace.\n    \"\"\"\n    axis1 = kwargs.get(\"axis1\", -2)\n    axis2 = kwargs.get(\"axis2\", -1)\n    return jnp.trace(qarr.data, axis1=axis1, axis2=axis2, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.trace","title":"<code>trace(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def trace(qarr: Qarray, **kwargs) -&gt; Array:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Full trace.\n    \"\"\"\n    return tr(qarr, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.transpose","title":"<code>transpose(qarr, indices)</code>","text":"<p>Transpose the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>*args</code> <p>axes to transpose</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>tranposed Qarray</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def transpose(qarr: Qarray, indices: List[int]) -&gt; Qarray:\n    \"\"\"Transpose the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n        *args: axes to transpose\n\n    Returns:\n        tranposed Qarray\n    \"\"\"\n\n    indices = list(indices)\n\n    shaped_data = qarr.shaped_data\n    dims = qarr.dims\n    bdims_indxs = list(range(len(qarr.bdims)))\n\n    reshape_indices = indices + [j + len(dims[0]) for j in indices]\n\n    reshape_indices = bdims_indxs + [j + len(bdims_indxs) for j in reshape_indices]\n\n    shaped_data = shaped_data.transpose(reshape_indices)\n    new_dims = (\n        tuple([dims[0][j] for j in indices]),\n        tuple([dims[1][j] for j in indices]),\n    )\n\n    full_dims = prod(dims[0])\n    full_data = shaped_data.reshape(*qarr.bdims, full_dims, -1)\n    return Qarray.create(full_data, dims=new_dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.unit","title":"<code>unit(qarr)</code>","text":"<p>Normalize the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Normalized quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def unit(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Normalize the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Normalized quantum array\n    \"\"\"\n    return qarr / qarr.norm()\n</code></pre>"},{"location":"reference/jaxquantum/core/qp_distributions.html","title":"qp_distributions","text":""},{"location":"reference/jaxquantum/core/qp_distributions.html#jaxquantum.core.qp_distributions.qfunc","title":"<code>qfunc(psi, xvec, yvec, g=2)</code>","text":"<p>Husimi-Q function of a given state vector or density matrix at phase-space points <code>0.5 * g * (xvec + i*yvec)</code>.</p>"},{"location":"reference/jaxquantum/core/qp_distributions.html#jaxquantum.core.qp_distributions.qfunc--parameters","title":"Parameters","text":"<p>state : Qarray     A state vector or density matrix. This cannot have tensor-product     structure.</p> <p>xvec, yvec : array_like     x- and y-coordinates at which to calculate the Husimi-Q function.</p> float, default: 2 <p>Scaling factor for <code>a = 0.5 * g * (x + iy)</code>.  The value of <code>g</code> is related to the value of :math:<code>\\hbar</code> in the commutation relation :math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p>"},{"location":"reference/jaxquantum/core/qp_distributions.html#jaxquantum.core.qp_distributions.qfunc--returns","title":"Returns","text":"<p>jnp.ndarray     Values representing the Husimi-Q function calculated over the specified     range <code>[xvec, yvec]</code>.</p> Source code in <code>jaxquantum/core/qp_distributions.py</code> <pre><code>def qfunc(psi, xvec, yvec, g=2):\n    r\"\"\"\n    Husimi-Q function of a given state vector or density matrix at phase-space\n    points ``0.5 * g * (xvec + i*yvec)``.\n\n    Parameters\n    ----------\n    state : Qarray\n        A state vector or density matrix. This cannot have tensor-product\n        structure.\n\n    xvec, yvec : array_like\n        x- and y-coordinates at which to calculate the Husimi-Q function.\n\n    g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\hbar` via :math:`\\hbar=2/g^2`.\n\n    Returns\n    -------\n    jnp.ndarray\n        Values representing the Husimi-Q function calculated over the specified\n        range ``[xvec, yvec]``.\n\n    \"\"\"\n\n    alpha_grid, prefactor = _qfunc_coherent_grid(xvec, yvec, g)\n\n    if psi.is_vec():\n        psi = psi.to_ket()\n\n        def _compute_qfunc(psi, alpha_grid, prefactor, g):\n            out = _qfunc_iterative_single(psi, alpha_grid, prefactor, g)\n            out /= jnp.pi\n            return out\n    else:\n\n        def _compute_qfunc(psi, alpha_grid, prefactor, g):\n            values, vectors = jnp.linalg.eigh(psi)\n            vectors = vectors.T\n            out = values[0] * _qfunc_iterative_single(\n                vectors[0], alpha_grid, prefactor, g\n            )\n            for value, vector in zip(values[1:], vectors[1:]):\n                out += value * _qfunc_iterative_single(vector, alpha_grid, prefactor, g)\n            out /= jnp.pi\n\n            return out\n\n    psi = psi.data\n\n    vmapped_compute_qfunc = [_compute_qfunc]\n\n    for _ in psi.shape[:-2]:\n        vmapped_compute_qfunc.append(\n            vmap(\n                vmapped_compute_qfunc[-1],\n                in_axes=(0, None, None, None),\n                out_axes=0,\n            )\n        )\n    return vmapped_compute_qfunc[-1](psi, alpha_grid, prefactor, g)\n</code></pre>"},{"location":"reference/jaxquantum/core/qp_distributions.html#jaxquantum.core.qp_distributions.wigner","title":"<code>wigner(psi, xvec, yvec, method='clenshaw', g=2)</code>","text":"<p>Wigner function for a state vector or density matrix at points <code>xvec + i * yvec</code>.</p>"},{"location":"reference/jaxquantum/core/qp_distributions.html#jaxquantum.core.qp_distributions.wigner--parameters","title":"Parameters","text":"Qarray <p>A state vector or density matrix.</p> array_like <p>x-coordinates at which to calculate the Wigner function.</p> array_like <p>y-coordinates at which to calculate the Wigner function.</p> float, default: 2 <p>Scaling factor for <code>a = 0.5 * g * (x + iy)</code>, default <code>g = 2</code>. The value of <code>g</code> is related to the value of <code>hbar</code> in the commutation relation <code>[x, y] = i * hbar</code> via <code>hbar=2/g^2</code>.</p> string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw' <p>Only 'clenshaw' is currently supported. Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' and 'iterative' use an iterative method to evaluate the Wigner functions for density matrices :math:<code>|m&gt;&lt;n|</code>, while 'laguerre' uses the Laguerre polynomials in scipy for the same task. The 'fft' method evaluates the Fourier transform of the density matrix. The 'iterative' method is default, and in general recommended, but the 'laguerre' method is more efficient for very sparse density matrices (e.g., superpositions of Fock states in a large Hilbert space). The 'clenshaw' method is the preferred method for dealing with density matrices that have a large number of excitations (&gt;~50). 'clenshaw' is a fast and numerically stable method.</p>"},{"location":"reference/jaxquantum/core/qp_distributions.html#jaxquantum.core.qp_distributions.wigner--returns","title":"Returns","text":"array <p>Values representing the Wigner function calculated over the specified range [xvec,yvec].</p>"},{"location":"reference/jaxquantum/core/qp_distributions.html#jaxquantum.core.qp_distributions.wigner--references","title":"References","text":"<p>Ulf Leonhardt, Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p> Source code in <code>jaxquantum/core/qp_distributions.py</code> <pre><code>def wigner(psi, xvec, yvec, method=\"clenshaw\", g=2):\n    \"\"\"Wigner function for a state vector or density matrix at points\n    `xvec + i * yvec`.\n\n    Parameters\n    ----------\n\n    state : Qarray\n        A state vector or density matrix.\n\n    xvec : array_like\n        x-coordinates at which to calculate the Wigner function.\n\n    yvec : array_like\n        y-coordinates at which to calculate the Wigner function.\n\n    g : float, default: 2\n        Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = 2`.\n        The value of `g` is related to the value of `hbar` in the commutation\n        relation `[x, y] = i * hbar` via `hbar=2/g^2`.\n\n    method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw'\n        Only 'clenshaw' is currently supported.\n        Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'\n        and 'iterative' use an iterative method to evaluate the Wigner functions for density\n        matrices :math:`|m&gt;&lt;n|`, while 'laguerre' uses the Laguerre polynomials\n        in scipy for the same task. The 'fft' method evaluates the Fourier\n        transform of the density matrix. The 'iterative' method is default, and\n        in general recommended, but the 'laguerre' method is more efficient for\n        very sparse density matrices (e.g., superpositions of Fock states in a\n        large Hilbert space). The 'clenshaw' method is the preferred method for\n        dealing with density matrices that have a large number of excitations\n        (&gt;~50). 'clenshaw' is a fast and numerically stable method.\n\n    Returns\n    -------\n\n    W : array\n        Values representing the Wigner function calculated over the specified\n        range [xvec,yvec].\n\n\n    References\n    ----------\n\n    Ulf Leonhardt,\n    Measuring the Quantum State of Light, (Cambridge University Press, 1997)\n\n    \"\"\"\n\n    if not (psi.is_vec() or psi.is_dm()):\n        raise TypeError(\"Input state is not a valid operator.\")\n\n    if method == \"fft\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    if method == \"iterative\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    elif method == \"laguerre\":\n        raise NotImplementedError(\"Only the 'clenshaw' method is implemented.\")\n\n    elif method == \"clenshaw\":\n        rho = psi.to_dm()\n        rho = rho.data\n\n        vmapped_wigner_clenshaw = [_wigner_clenshaw]\n\n        for _ in rho.shape[:-2]:\n            vmapped_wigner_clenshaw.append(\n                vmap(\n                    vmapped_wigner_clenshaw[-1],\n                    in_axes=(0, None, None, None),\n                    out_axes=0,\n                )\n            )\n        return vmapped_wigner_clenshaw[-1](rho, xvec, yvec, g)\n\n    else:\n        raise TypeError(\"method must be either 'iterative', 'laguerre', or 'fft'.\")\n</code></pre>"},{"location":"reference/jaxquantum/core/settings.html","title":"settings","text":"<p>Core settings.</p>"},{"location":"reference/jaxquantum/core/solvers.html","title":"solvers","text":"<p>Solvers</p>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.mesolve","title":"<code>mesolve(H, rho0, tlist, saveat_tlist=None, c_ops=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[Qarray, Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function or time-independent Qarray.</p> required <code>rho0</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>tlist</code> <code>Array</code> <p>time list</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <code>c_ops</code> <code>Optional[Qarray]</code> <p>qarray list of collapse operators</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    rho0: Qarray,\n    tlist: Array,\n    saveat_tlist: Optional[Array] = None,\n    c_ops: Optional[Qarray] = None,\n    solver_options: Optional[SolverOptions] = None,\n) -&gt; Qarray:\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        H: time dependent Hamiltonian function or time-independent Qarray.\n        rho0: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        tlist: time list\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n        c_ops: qarray list of collapse operators\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    saveat_tlist = saveat_tlist if saveat_tlist is not None else tlist\n\n    saveat_tlist = jnp.atleast_1d(saveat_tlist)\n\n    c_ops = c_ops if c_ops is not None else Qarray.from_list([])\n\n    # if isinstance(H, Qarray):\n\n    if len(c_ops) == 0 and rho0.qtype != Qtypes.oper:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = rho0.to_dm()\n    dims = \u03c10.dims\n    \u03c10 = \u03c10.data\n\n    c_ops = c_ops.data\n\n    if isinstance(H, Qarray):\n        Ht_data = lambda t: H.data\n    else:\n        Ht_data = lambda t: H(t).data\n\n    ys = _mesolve_data(Ht_data, \u03c10, tlist, saveat_tlist, c_ops,\n                       solver_options=solver_options)\n\n    return jnp2jqt(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.propagator","title":"<code>propagator(H, ts, saveat_tlist=None, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Qarray or callable</code> <p>A Qarray static Hamiltonian OR a function that takes a time argument and returns a Hamiltonian.</p> required <code>ts</code> <code>float or Array</code> <p>A single time point or an Array of time points.</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray or List[Qarray]: The propagator for the Hamiltonian at time t. OR a list of propagators for the Hamiltonian at each time in t.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    ts: Union[float, Array],\n    saveat_tlist: Optional[Array] = None,\n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian.\n\n    Args:\n        H (Qarray or callable):\n            A Qarray static Hamiltonian OR\n            a function that takes a time argument and returns a Hamiltonian.\n        ts (float or Array):\n            A single time point or\n            an Array of time points.\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n\n    Returns:\n        Qarray or List[Qarray]:\n            The propagator for the Hamiltonian at time t.\n            OR a list of propagators for the Hamiltonian at each time in t.\n\n    \"\"\"\n\n\n    ts_is_scalar = robust_isscalar(ts)\n    H_is_qarray = isinstance(H, Qarray)\n\n    if H_is_qarray:\n        return (-1j * H * ts).expm()\n    else:\n\n        if ts_is_scalar:\n            H_first = H(0.0)\n            if ts == 0:\n                return identity_like(H_first)\n            ts = jnp.array([0.0, ts])\n        else:\n            H_first = H(ts[0])\n\n        basis_states = multi_mode_basis_set(H_first.space_dims)\n        results = sesolve(H, basis_states, ts, saveat_tlist=saveat_tlist)\n        propagators_data = results.data.squeeze(-1).mT\n        propagators = Qarray.create(propagators_data, dims=H_first.space_dims)\n\n        return propagators\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.sesolve","title":"<code>sesolve(H, rho0, tlist, saveat_tlist=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Union[Qarray, Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function or time-independent Qarray.</p> required <code>rho0</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>tlist</code> <code>Array</code> <p>time list</p> required <code>saveat_tlist</code> <code>Optional[Array]</code> <p>list of times at which to save the state. If -1 or [-1], save only at final time. If None, save at all times in tlist. Default: None.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    rho0: Qarray,\n    tlist: Array,\n    saveat_tlist: Optional[Array] = None,\n    solver_options: Optional[SolverOptions] = None,\n) -&gt; Qarray:\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        H: time dependent Hamiltonian function or time-independent Qarray.\n        rho0: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        tlist: time list\n        saveat_tlist: list of times at which to save the state.\n            If -1 or [-1], save only at final time.\n            If None, save at all times in tlist. Default: None.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    saveat_tlist = saveat_tlist if saveat_tlist is not None else tlist\n\n    saveat_tlist = jnp.atleast_1d(saveat_tlist)\n\n    \u03c8 = rho0\n\n    if \u03c8.qtype == Qtypes.oper:\n        raise ValueError(\n            \"Please use `jqt.mesolve` for initial state inputs in density matrix form.\"\n        )\n\n    \u03c8 = \u03c8.to_ket()\n    dims = \u03c8.dims\n    \u03c8 = \u03c8.data\n\n    if isinstance(H, Qarray):\n        Ht_data = lambda t: H.data\n    else:\n        Ht_data = lambda t: H(t).data\n\n    ys = _sesolve_data(Ht_data, \u03c8, tlist, saveat_tlist,\n                       solver_options=solver_options)\n\n    return jnp2jqt(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.solve","title":"<code>solve(f, \u03c10, tlist, saveat_tlist, args, solver_options=None)</code>","text":"<p>Gets teh desired solver from diffrax.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>function defining the ODE</p> required <code>\u03c10</code> <p>initial state</p> required <code>tlist</code> <p>time list</p> required <code>saveat_tlist</code> <p>list of times at which to save the state pass in [-1] to save only at final time</p> required <code>args</code> <p>additional arguments to f</p> required <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>dictionary with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>solution</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def solve(f, \u03c10, tlist, saveat_tlist, args, solver_options: Optional[\n    SolverOptions] = None):\n    \"\"\"Gets teh desired solver from diffrax.\n\n    Args:\n        f: function defining the ODE\n        \u03c10: initial state\n        tlist: time list\n        saveat_tlist: list of times at which to save the state\n            pass in [-1] to save only at final time\n        args: additional arguments to f\n        solver_options: dictionary with solver options\n\n    Returns:\n        solution\n    \"\"\"\n\n    # f and ts\n    term = ODETerm(f)\n\n    if saveat_tlist.shape[0] == 1 and saveat_tlist == -1:\n        saveat = SaveAt(t1=True)\n    else:\n        saveat = SaveAt(ts=saveat_tlist)\n\n    # solver\n    solver_options = solver_options or SolverOptions.create()\n\n    solver_name = solver_options.solver\n    solver = getattr(diffrax, solver_name)()\n    stepsize_controller = PIDController(rtol=solver_options.rtol, atol=solver_options.atol)\n\n    # solve!\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\",\n                                message=\"Complex dtype support in Diffrax\",\n                                category=UserWarning)  # NOTE: suppresses complex dtype warning in diffrax\n        sol = diffeqsolve(\n            term,\n            solver,\n            t0=tlist[0],\n            t1=tlist[-1],\n            dt0=tlist[1] - tlist[0],\n            y0=\u03c10,\n            saveat=saveat,\n            stepsize_controller=stepsize_controller,\n            args=args,\n            max_steps=solver_options.max_steps,\n            progress_meter=CustomProgressMeter()\n            if solver_options.progress_meter\n            else NoProgressMeter(),\n        )\n\n    return sol\n</code></pre>"},{"location":"reference/jaxquantum/core/visualization.html","title":"visualization","text":"<p>Visualization utils.</p>"},{"location":"reference/jaxquantum/core/visualization.html#jaxquantum.core.visualization.plot_cf","title":"<code>plot_cf(state, pts_x, pts_y=None, axs=None, contour=True, qp_type=WIGNER, cbar_label='', axis_scale_factor=1, plot_cbar=True, plot_grid=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot characteristic function.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\")</p> <code>WIGNER</code> <code>cbar_label</code> <p>labels for the real and imaginary cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_cf(\n        state,\n        pts_x,\n        pts_y=None,\n        axs=None,\n        contour=True,\n        qp_type=WIGNER,\n        cbar_label=\"\",\n        axis_scale_factor=1,\n        plot_cbar=True,\n        plot_grid=True,\n        x_ticks=None,\n        y_ticks=None,\n        z_ticks=None,\n        subtitles=None,\n        figtitle=None,\n):\n    \"\"\"Plot characteristic function.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\")\n        cbar_label: labels for the real and imaginary cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    if pts_y is None:\n        pts_y = pts_x\n    pts_x = jnp.array(pts_x)\n    pts_y = jnp.array(pts_y)\n\n    bdims = state.bdims\n    added_baxes = 0\n\n    if subtitles is not None:\n        if subtitles.shape != bdims:\n            raise ValueError(\n                f\"labels must have same shape as bdims, \"\n                f\"got shapes {subtitles.shape} and {bdims}\"\n            )\n\n    if len(bdims) == 0:\n        bdims = (1,)\n        added_baxes += 1\n    if len(bdims) == 1:\n        bdims = (1, bdims[0])\n        added_baxes += 1\n\n    extra_dims = bdims[2:]\n    if extra_dims != ():\n        state = state.reshape_bdims(\n            bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n        )\n        if subtitles is not None:\n            subtitles = subtitles.reshape(\n                bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n            )\n        bdims = state.bdims\n\n    if axs is None:\n        _, axs = plt.subplots(\n            bdims[0],\n            bdims[1]*2,\n            figsize=(4 * bdims[1]*2, 3 * bdims[0]),\n            dpi=200,\n        )\n\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = 1\n        cmap = \"seismic\"\n        cbar_label = [r\"$\\mathcal{Re}(\\chi_W(\\alpha))$\", r\"$\\mathcal{\"\n                                                         r\"Im}(\\chi_W(\"\n                                                         r\"\\alpha))$\"]\n        QP = scale * cf_wigner(state, pts_x, pts_y)\n\n    for _ in range(added_baxes):\n        QP = jnp.array([QP])\n        axs = np.array([axs])\n        if subtitles is not None:\n            subtitles = np.array([subtitles])\n\n    if added_baxes==2:\n        axs = axs[0] # When the input state is zero-dimensional, remove an\n                     # axis that is automatically added due to the subcolumns\n\n\n    pts_x = pts_x * axis_scale_factor\n    pts_y = pts_y * axis_scale_factor\n\n    x_ticks = (\n        jnp.linspace(jnp.min(pts_x), jnp.max(pts_x),\n                     5) if x_ticks is None else x_ticks\n    )\n    y_ticks = (\n        jnp.linspace(jnp.min(pts_y), jnp.max(pts_y),\n                     5) if y_ticks is None else y_ticks\n    )\n    z_ticks = jnp.linspace(vmin, vmax, 11) if z_ticks is None else z_ticks\n    print(axs.shape)\n    for row in range(bdims[0]):\n        for col in range(bdims[1]):\n            for subcol in range(2):\n                ax = axs[row, 2 * col + subcol]\n                if contour:\n                    im = ax.contourf(\n                        pts_x,\n                        pts_y,\n                        jnp.real(QP[row, col]) if subcol==0 else jnp.imag(QP[\n                                                                           row, col]),\n                        cmap=cmap,\n                        vmin=vmin,\n                        vmax=vmax,\n                        levels=np.linspace(vmin, vmax, 101),\n                    )\n                else:\n                    im = ax.pcolormesh(\n                        pts_x,\n                        pts_y,\n                        jnp.real(QP[row, col]) if subcol == 0 else jnp.imag(QP[\n                                                                                row, col]),\n                        cmap=cmap,\n                        vmin=vmin,\n                        vmax=vmax,\n                    )\n                ax.set_xticks(x_ticks)\n                ax.set_yticks(y_ticks)\n                # ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n                # ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n\n                if plot_grid:\n                    ax.grid()\n\n                ax.set_aspect(\"equal\", adjustable=\"box\")\n\n                if plot_cbar:\n                    cbar = plt.colorbar(\n                        im, ax=ax, orientation=\"vertical\",\n                        ticks=np.linspace(-1, 1, 11)\n                    )\n                    cbar.ax.set_title(cbar_label[subcol])\n                    cbar.set_ticks(z_ticks)\n\n                ax.set_xlabel(r\"Re[$\\alpha$]\")\n                ax.set_ylabel(r\"Im[$\\alpha$]\")\n                if subtitles is not None:\n                    ax.set_title(subtitles[row, col])\n\n    fig = ax.get_figure()\n    fig.tight_layout()\n    if figtitle is not None:\n        fig.suptitle(figtitle, y=1.04)\n    return axs, im\n</code></pre>"},{"location":"reference/jaxquantum/core/visualization.html#jaxquantum.core.visualization.plot_cf_wigner","title":"<code>plot_cf_wigner(state, pts_x, pts_y=None, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, plot_grid=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the Wigner characteristic function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_cf_wigner(\n    state,\n    pts_x,\n    pts_y=None,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    plot_grid=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the Wigner characteristic function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_cf(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        axs=axs,\n        contour=contour,\n        qp_type=WIGNER,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        plot_grid=plot_grid,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/visualization.html#jaxquantum.core.visualization.plot_qfunc","title":"<code>plot_qfunc(state, pts_x, pts_y=None, g=2, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the husimi function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qfunc(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the husimi function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_qp(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        g=g,\n        axs=axs,\n        contour=contour,\n        qp_type=HUSIMI,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/visualization.html#jaxquantum.core.visualization.plot_qp","title":"<code>plot_qp(state, pts_x, pts_y=None, g=2, axs=None, contour=True, qp_type=WIGNER, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot quasi-probability distribution.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\", \"qfunc\")</p> <code>WIGNER</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qp(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    qp_type=WIGNER,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot quasi-probability distribution.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\", \"qfunc\")\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    if pts_y is None:\n        pts_y = pts_x\n    pts_x = jnp.array(pts_x)\n    pts_y = jnp.array(pts_y)\n\n    if len(state.bdims)==1 and state.bdims[0]==1:\n        state = state[0]\n\n\n    bdims = state.bdims\n    added_baxes = 0\n\n    if subtitles is not None:\n        if subtitles.shape != bdims:\n            raise ValueError(\n                f\"labels must have same shape as bdims, \"\n                f\"got shapes {subtitles.shape} and {bdims}\"\n            )\n\n    if len(bdims) == 0:\n        bdims = (1,)\n        added_baxes += 1\n    if len(bdims) == 1:\n        bdims = (1, bdims[0])\n        added_baxes += 1\n\n    extra_dims = bdims[2:]\n    if extra_dims != ():\n        state = state.reshape_bdims(\n            bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n        )\n        if subtitles is not None:\n            subtitles = subtitles.reshape(\n                bdims[0] * int(jnp.prod(jnp.array(extra_dims))), bdims[1]\n            )\n        bdims = state.bdims\n\n    if axs is None:\n        _, axs = plt.subplots(\n            bdims[0],\n            bdims[1],\n            figsize=(4 * bdims[1], 3 * bdims[0]),\n            dpi=200,\n        )\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = np.pi / 2\n        cmap = \"seismic\"\n        cbar_label = r\"$\\mathcal{W}(\\alpha)$\"\n        QP = scale * wigner(state, pts_x, pts_y, g=g)\n\n    elif qp_type == HUSIMI:\n        vmin = 0\n        vmax = 1\n        scale = np.pi\n        cmap = \"jet\"\n        cbar_label = r\"$\\mathcal{Q}(\\alpha)$\"\n        QP = scale * qfunc(state, pts_x, pts_y, g=g)\n\n\n\n    for _ in range(added_baxes):\n        QP = jnp.array([QP])\n        axs = np.array([axs])\n        if subtitles is not None:\n            subtitles = np.array([subtitles])\n\n\n\n\n    pts_x = pts_x * axis_scale_factor\n    pts_y = pts_y * axis_scale_factor\n\n    x_ticks = (\n        jnp.linspace(jnp.min(pts_x), jnp.max(pts_x), 5) if x_ticks is None else x_ticks\n    )\n    y_ticks = (\n        jnp.linspace(jnp.min(pts_y), jnp.max(pts_y), 5) if y_ticks is None else y_ticks\n    )\n    z_ticks = jnp.linspace(vmin, vmax, 3) if z_ticks is None else z_ticks\n\n    for row in range(bdims[0]):\n        for col in range(bdims[1]):\n            ax = axs[row, col]\n            if contour:\n                im = ax.contourf(\n                    pts_x,\n                    pts_y,\n                    QP[row, col],\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    levels=np.linspace(vmin, vmax, 101),\n                )\n            else:\n                im = ax.pcolormesh(\n                    pts_x,\n                    pts_y,\n                    QP[row, col],\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                )\n            ax.set_xticks(x_ticks)\n            ax.set_yticks(y_ticks)\n            ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n            ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n            ax.grid()\n            ax.set_aspect(\"equal\", adjustable=\"box\")\n\n            if plot_cbar:\n                cbar = plt.colorbar(\n                    im, ax=ax, orientation=\"vertical\", ticks=np.linspace(-1, 1, 11)\n                )\n                cbar.ax.set_title(cbar_label)\n                cbar.set_ticks(z_ticks)\n\n            ax.set_xlabel(r\"Re[$\\alpha$]\")\n            ax.set_ylabel(r\"Im[$\\alpha$]\")\n            if subtitles is not None:\n                ax.set_title(subtitles[row, col])\n\n    fig = ax.get_figure()\n    fig.tight_layout()\n    if figtitle is not None:\n        fig.suptitle(figtitle, y=1.04)\n    return axs, im\n</code></pre>"},{"location":"reference/jaxquantum/core/visualization.html#jaxquantum.core.visualization.plot_wigner","title":"<code>plot_wigner(state, pts_x, pts_y=None, g=2, axs=None, contour=True, cbar_label='', axis_scale_factor=1, plot_cbar=True, x_ticks=None, y_ticks=None, z_ticks=None, subtitles=None, figtitle=None)</code>","text":"<p>Plot the wigner function of the state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>state with arbitrary number of batch dimensions, result will</p> required <code>pts_x</code> <p>x points to evaluate quasi-probability distribution at</p> required <code>pts_y</code> <p>y points to evaluate quasi-probability distribution at</p> <code>None</code> <code>g </code> <p>float, default: 2</p> required <code>related to the value of </code> <p>math:<code>\\hbar</code> in the commutation relation</p> required <code></code> <p>math:<code>[x,\\,y] = i\\hbar</code> via :math:<code>\\hbar=2/g^2</code>.</p> required <code>axs</code> <p>matplotlib axes to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>cbar_label</code> <p>label for the cbar</p> <code>''</code> <code>axis_scale_factor</code> <p>scale of the axes labels relative</p> <code>1</code> <code>plot_cbar</code> <p>whether to plot cbar</p> <code>True</code> <code>x_ticks</code> <p>tick position for the x-axis</p> <code>None</code> <code>y_ticks</code> <p>tick position for the y-axis</p> <code>None</code> <code>z_ticks</code> <p>tick position for the z-axis</p> <code>None</code> <code>subtitles</code> <p>subtitles for the subplots</p> <code>None</code> <code>figtitle</code> <p>figure title</p> <code>None</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_wigner(\n    state,\n    pts_x,\n    pts_y=None,\n    g=2,\n    axs=None,\n    contour=True,\n    cbar_label=\"\",\n    axis_scale_factor=1,\n    plot_cbar=True,\n    x_ticks=None,\n    y_ticks=None,\n    z_ticks=None,\n    subtitles=None,\n    figtitle=None,\n):\n    \"\"\"Plot the wigner function of the state.\n\n\n    Args:\n        state: state with arbitrary number of batch dimensions, result will\n        be flattened to a 2d grid to allow for plotting\n        pts_x: x points to evaluate quasi-probability distribution at\n        pts_y: y points to evaluate quasi-probability distribution at\n        g : float, default: 2\n        Scaling factor for ``a = 0.5 * g * (x + iy)``.  The value of `g` is\n        related to the value of :math:`\\\\hbar` in the commutation relation\n        :math:`[x,\\,y] = i\\\\hbar` via :math:`\\\\hbar=2/g^2`.\n        axs: matplotlib axes to plot on\n        contour: make the plot use contouring\n        cbar_label: label for the cbar\n        axis_scale_factor: scale of the axes labels relative\n        plot_cbar: whether to plot cbar\n        x_ticks: tick position for the x-axis\n        y_ticks: tick position for the y-axis\n        z_ticks: tick position for the z-axis\n        subtitles: subtitles for the subplots\n        figtitle: figure title\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    return plot_qp(\n        state=state,\n        pts_x=pts_x,\n        pts_y=pts_y,\n        g=g,\n        axs=axs,\n        contour=contour,\n        qp_type=WIGNER,\n        cbar_label=cbar_label,\n        axis_scale_factor=axis_scale_factor,\n        plot_cbar=plot_cbar,\n        x_ticks=x_ticks,\n        y_ticks=y_ticks,\n        z_ticks=z_ticks,\n        subtitles=subtitles,\n        figtitle=figtitle,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html","title":"devices","text":"<p>qcsys</p>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS","title":"<code>ATS</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>ATS Device.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>@struct.dataclass\nclass ATS(FluxDevice):\n    \"\"\"\n    ATS Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.params[\"El\"] / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    @staticmethod\n    def get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta):\n        cos_phi_op = cosm(phi_op)\n        sin_phi_op = sinm(phi_op)\n\n        cos_2phi_op = cos_phi_op @ cos_phi_op - sin_phi_op @ sin_phi_op\n        sin_2phi_op = 2 * cos_phi_op @ sin_phi_op\n\n        H_nl_Ej = (\n            -2\n            * Ej\n            * (\n                cos_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n                - sin_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n            )\n            * jnp.cos(2 * jnp.pi * phi_sum)\n        )\n        H_nl_dEj = (\n            2\n            * dEj\n            * (\n                sin_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n                + cos_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n            )\n            * jnp.sin(2 * jnp.pi * phi_sum)\n        )\n        H_nl_Ej2 = (\n            2\n            * Ej2\n            * (\n                cos_2phi_op * jnp.cos(2 * 2 * jnp.pi * phi_delta)\n                - sin_2phi_op * jnp.sin(2 * 2 * jnp.pi * phi_delta)\n            )\n            * jnp.cos(2 * 2 * jnp.pi * phi_sum)\n        )\n\n        H_nl = H_nl_Ej + H_nl_dEj + H_nl_Ej2\n\n        # id_op = jqt.identity_like(phi_op)\n        # phi_delta_ext_op = self.params[\"phi_delta_ext\"] * id_op\n        # H_nl_old = - 2 * Ej * jqt.cosm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * dEj * jqt.sinm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.sin(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * Ej2 * jqt.cosm(2*phi_op + 2 * 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * 2 * jnp.pi * self.params[\"phi_sum_ext\"])\n\n        return H_nl\n\n    def get_H_nonlinear(self, phi_op):\n        \"\"\"Return nonlinear terms in H.\"\"\"\n\n        Ej = self.params[\"Ej\"]\n        dEj = self.params[\"dEj\"]\n        Ej2 = self.params[\"Ej2\"]\n\n        phi_sum = self.params[\"phi_sum_ext\"]\n        phi_delta = self.params[\"phi_delta_ext\"]\n\n        return ATS.get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        phi_b = self.linear_ops[\"phi\"]\n        H_nl = self.get_H_nonlinear(phi_b)\n        H = self.get_H_linear() + H_nl\n        return H\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n\n        phi_delta_ext = self.params[\"phi_delta_ext\"]\n        phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n        V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n        V += (\n            -2\n            * self.params[\"Ej\"]\n            * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.cos(2 * jnp.pi * phi_sum_ext)\n        )\n        V += (\n            2\n            * self.params[\"dEj\"]\n            * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.sin(2 * jnp.pi * phi_sum_ext)\n        )\n        V += (\n            2\n            * self.params[\"Ej2\"]\n            * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n        )\n\n        return V\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    phi_b = self.linear_ops[\"phi\"]\n    H_nl = self.get_H_nonlinear(phi_b)\n    H = self.get_H_linear() + H_nl\n    return H\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS.get_H_nonlinear","title":"<code>get_H_nonlinear(phi_op)</code>","text":"<p>Return nonlinear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_nonlinear(self, phi_op):\n    \"\"\"Return nonlinear terms in H.\"\"\"\n\n    Ej = self.params[\"Ej\"]\n    dEj = self.params[\"dEj\"]\n    Ej2 = self.params[\"Ej2\"]\n\n    phi_sum = self.params[\"phi_sum_ext\"]\n    phi_delta = self.params[\"phi_delta_ext\"]\n\n    return ATS.get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.params[\"El\"] / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.ATS.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n\n    phi_delta_ext = self.params[\"phi_delta_ext\"]\n    phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n    V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n    V += (\n        -2\n        * self.params[\"Ej\"]\n        * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.cos(2 * jnp.pi * phi_sum_ext)\n    )\n    V += (\n        2\n        * self.params[\"dEj\"]\n        * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.sin(2 * jnp.pi * phi_sum_ext)\n    )\n    V += (\n        2\n        * self.params[\"Ej2\"]\n        * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n    )\n\n    return V\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@struct.dataclass\nclass Device(ABC):\n    DEFAULT_BASIS = BasisTypes.fock\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    N: int = struct.field(pytree_node=False)\n    N_pre_diag: int = struct.field(pytree_node=False)\n    params: Dict[str, Any]\n    _label: int = struct.field(pytree_node=False)\n    _basis: BasisTypes = struct.field(pytree_node=False)\n    _hamiltonian: HamiltonianTypes = struct.field(pytree_node=False)\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        pass\n\n    @classmethod\n    def create(\n        cls,\n        N,\n        params,\n        label=0,\n        N_pre_diag=None,\n        use_linear=False,\n        hamiltonian: HamiltonianTypes = None,\n        basis: BasisTypes = None,\n    ):\n        \"\"\"Create a device.\n\n        Args:\n            N (int): dimension of Hilbert space.\n            params (dict): parameters of the device.\n            label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n            N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n            use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n            hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n            basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n        \"\"\"\n\n        if N_pre_diag is None:\n            N_pre_diag = N\n\n        assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n        _basis = basis if basis is not None else cls.DEFAULT_BASIS\n        _hamiltonian = (\n            hamiltonian if hamiltonian is not None else cls.DEFAULT_HAMILTONIAN\n        )\n\n        if use_linear:\n            _hamiltonian = HamiltonianTypes.linear\n\n        cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n        return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n\n    @property\n    def basis(self):\n        return self._basis\n\n    @property\n    def hamiltonian(self):\n        return self._hamiltonian\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def linear_ops(self):\n        return self.common_ops()\n\n    @property\n    def original_ops(self):\n        return self.common_ops()\n\n    @property\n    def ops(self):\n        return self.full_ops()\n\n    @abstractmethod\n    def common_ops(self) -&gt; Dict[str, Qarray]:\n        \"\"\"Set up common ops in the specified basis.\"\"\"\n\n    @abstractmethod\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n\n    @abstractmethod\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n\n    @abstractmethod\n    def get_H_full(self):\n        \"\"\"Return full H.\"\"\"\n\n    def get_H(self):\n        \"\"\"\n        Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n        \"\"\"\n        return self.get_op_in_H_eigenbasis(\n            self._get_H_in_original_basis()\n        ).keep_only_diag_elements()\n\n    def _get_H_in_original_basis(self):\n        \"\"\"This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n\n    def _calculate_eig_systems(self):\n        evs, evecs = jnp.linalg.eigh(self._get_H_in_original_basis().data)  # Hermitian\n        idxs_sorted = jnp.argsort(evs)\n        return evs[idxs_sorted], evecs[:, idxs_sorted]\n\n    @property\n    def eig_systems(self):\n        eig_systems = {}\n        eig_systems[\"vals\"], eig_systems[\"vecs\"] = self._calculate_eig_systems()\n\n        eig_systems[\"vecs\"] = eig_systems[\"vecs\"]\n        eig_systems[\"vals\"] = eig_systems[\"vals\"]\n        return eig_systems\n\n    def get_op_in_H_eigenbasis(self, op: Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        dims = [[self.N], [self.N]]\n        return get_op_in_new_basis(op, evecs, dims)\n\n    def get_op_data_in_H_eigenbasis(self, op: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_op_data_in_new_basis(op, evecs)\n\n    def get_vec_in_H_eigenbasis(self, vec: Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        if vec.qtype == Qtypes.ket:\n            dims = [[self.N], [1]]\n        else:\n            dims = [[1], [self.N]]\n        return get_vec_in_new_basis(vec, evecs, dims)\n\n    def get_vec_data_in_H_eigenbasis(self, vec: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_vec_data_in_new_basis(vec, evecs)\n\n    def full_ops(self):\n        # TODO: use JAX vmap here\n\n        linear_ops = self.linear_ops\n        ops = {}\n        for name, op in linear_ops.items():\n            ops[name] = self.get_op_in_H_eigenbasis(op)\n\n        return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Device.common_ops","title":"<code>common_ops()</code>  <code>abstractmethod</code>","text":"<p>Set up common ops in the specified basis.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef common_ops(self) -&gt; Dict[str, Qarray]:\n    \"\"\"Set up common ops in the specified basis.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Device.create","title":"<code>create(N, params, label=0, N_pre_diag=None, use_linear=False, hamiltonian=None, basis=None)</code>  <code>classmethod</code>","text":"<p>Create a device.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>dimension of Hilbert space.</p> required <code>params</code> <code>dict</code> <p>parameters of the device.</p> required <code>label</code> <code>int</code> <p>label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.</p> <code>0</code> <code>N_pre_diag</code> <code>int</code> <p>dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.</p> <code>None</code> <code>use_linear</code> <code>bool</code> <p>whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.</p> <code>False</code> <code>hamiltonian</code> <code>HamiltonianTypes</code> <p>type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.</p> <code>None</code> <code>basis</code> <code>BasisTypes</code> <p>type of basis. Defaults to None, in which case the fock basis is used.</p> <code>None</code> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    N,\n    params,\n    label=0,\n    N_pre_diag=None,\n    use_linear=False,\n    hamiltonian: HamiltonianTypes = None,\n    basis: BasisTypes = None,\n):\n    \"\"\"Create a device.\n\n    Args:\n        N (int): dimension of Hilbert space.\n        params (dict): parameters of the device.\n        label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n        N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n        use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n        hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n        basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n    \"\"\"\n\n    if N_pre_diag is None:\n        N_pre_diag = N\n\n    assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n    _basis = basis if basis is not None else cls.DEFAULT_BASIS\n    _hamiltonian = (\n        hamiltonian if hamiltonian is not None else cls.DEFAULT_HAMILTONIAN\n    )\n\n    if use_linear:\n        _hamiltonian = HamiltonianTypes.linear\n\n    cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n    return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Device.get_H","title":"<code>get_H()</code>","text":"<p>Return diagonalized H. Explicitly keep only diagonal elements of matrix.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n    \"\"\"\n    return self.get_op_in_H_eigenbasis(\n        self._get_H_in_original_basis()\n    ).keep_only_diag_elements()\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Device.get_H_full","title":"<code>get_H_full()</code>  <code>abstractmethod</code>","text":"<p>Return full H.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_H_full(self):\n    \"\"\"Return full H.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Device.get_H_linear","title":"<code>get_H_linear()</code>  <code>abstractmethod</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Device.get_linear_frequency","title":"<code>get_linear_frequency()</code>  <code>abstractmethod</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Device.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Drive","title":"<code>Drive</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>jaxquantum/devices/superconducting/drive.py</code> <pre><code>@struct.dataclass\nclass Drive(ABC):\n    N: int = struct.field(pytree_node=False)\n    fd: float\n    _label: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(cls, M_max, fd, label=0):\n        cls.M_max = M_max\n        N = 2 * M_max + 1\n        return cls(N, fd, label)\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def ops(self):\n        return self.common_ops()\n\n    def common_ops(self) -&gt; Dict[str, Qarray]:\n        ops = {}\n\n        M_max = self.M_max\n\n        # Construct M = \u2211\u2098 m|m&gt;&lt;m| operator in drive charge basis\n        ops[\"M\"] = jnp2jqt(jnp.diag(jnp.arange(-M_max, M_max + 1)))\n\n        # Construct Id = \u2211\u2098|m&gt;&lt;m| in the drive charge basis\n        ops[\"id\"] = jnp2jqt(jnp.identity(2 * M_max + 1))\n\n        # Construct M\u208a \u2261 exp(i\u03b8) and M\u208b \u2261 exp(-i\u03b8) operators for drive\n        ops[\"M-\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=1))\n        ops[\"M+\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=-1))\n\n        # Construct cos(\u03b8) \u2261 1/2 * [M\u208a + M\u208b] = 1/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"cos(\u03b8)\"] = 0.5 * (ops[\"M+\"] + ops[\"M-\"])\n\n        # Construct sin(\u03b8) \u2261 -i/2 * [M\u208a - M\u208b] = -i/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"sin(\u03b8)\"] = -0.5j * (ops[\"M+\"] - ops[\"M-\"])\n\n        # Construct more general drive operators cos(k\u03b8) and sin(k\u03b8)\n        for k in range(2, M_max + 1):\n            ops[f\"M_+{k}\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=-k))\n            ops[f\"M_-{k}\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=k))\n            ops[f\"cos({k}\u03b8)\"] = 0.5 * (ops[f\"M_+{k}\"] + ops[f\"M_-{k}\"])\n            ops[f\"sin({k}\u03b8)\"] = -0.5j * (ops[f\"M_+{k}\"] - ops[f\"M_-{k}\"])\n\n        return ops\n\n    #############################################################\n\n    def get_H(self):\n        \"\"\"\n        Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.\n        \"\"\"\n        return self.fd * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Drive.get_H","title":"<code>get_H()</code>","text":"<p>Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.</p> Source code in <code>jaxquantum/devices/superconducting/drive.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.\n    \"\"\"\n    return self.fd * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.FluxDevice","title":"<code>FluxDevice</code>","text":"<p>               Bases: <code>Device</code></p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@struct.dataclass\nclass FluxDevice(Device):\n    @abstractmethod\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n\n    def _calculate_wavefunctions_fock(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n        phi_osc = self.phi_zpf() * jnp.sqrt(2)  # length of oscillator\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        for n in range(self.N_pre_diag):\n            basis_functions.append(\n                harm_osc_wavefunction(n, phi_vals, jnp.real(phi_osc))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(\n            basis_functions\n        )\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        wavefunctions = basis_functions_in_H_eigenbasis\n        return wavefunctions\n\n    def _calculate_wavefunctions_charge(self, phi_vals):\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        n_labels = jnp.diag(self.original_ops[\"n\"].data)\n        for n in n_labels:\n            basis_functions.append(\n                1 / (jnp.sqrt(2 * jnp.pi)) * jnp.exp(1j * n * (2 * jnp.pi * -1 * phi_vals)) # Added a -1 to work with the SNAIL\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(\n            basis_functions\n        )\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        num_eigenstates = basis_functions_in_H_eigenbasis.shape[0]\n        phase_correction_factors = (1j ** (jnp.arange(0, num_eigenstates))).reshape(\n            num_eigenstates, 1\n        )  # TODO: review why these are needed...\n        wavefunctions = basis_functions_in_H_eigenbasis * phase_correction_factors\n        return wavefunctions\n\n    @abstractmethod\n    def potential(self, phi):\n        \"\"\"Return potential energy as a function of phi.\"\"\"\n\n    def plot_wavefunctions(self, phi_vals, max_n=None, which=None, ax=None, mode=\"abs\", ylim=None, y_scale_factor=1, zero_potential=False, wavefunction_color=None):\n        if self.basis == BasisTypes.fock:\n            _calculate_wavefunctions = self._calculate_wavefunctions_fock\n        elif self.basis == BasisTypes.charge:\n            _calculate_wavefunctions = self._calculate_wavefunctions_charge\n        else:\n            raise NotImplementedError(\n                f\"The {self.basis} is not yet supported for plotting wavefunctions.\"\n            )\n\n        \"\"\"Plot wavefunctions at phi_exts.\"\"\"\n        wavefunctions = _calculate_wavefunctions(phi_vals)\n        energy_levels = self.eig_systems[\"vals\"][: self.N]\n\n        potential = self.potential(phi_vals)\n\n        min_potential = 0 if not zero_potential else jnp.min(potential)\n        if ax is None:\n            fig, ax = plt.subplots(1, 1, figsize=(3.5, 2.5), dpi=1000)\n        else:\n            fig = ax.get_figure()\n\n        min_val = None\n        max_val = None\n\n        assert max_n is None or which is None, \"Can't specify both max_n and which\"\n\n        max_n = self.N if max_n is None else max_n\n        levels = range(max_n) if which is None else which\n\n        for n in levels:\n            if mode == \"abs\":\n                wf_vals = jnp.abs(wavefunctions[n, :]) ** 2\n            elif mode == \"real\":\n                wf_vals = wavefunctions[n, :].real\n            elif mode == \"imag\":\n                wf_vals = wavefunctions[n, :].imag\n\n            wf_vals += energy_levels[n]\n            curr_min_val = min(wf_vals)\n            curr_max_val = max(wf_vals)\n\n            if min_val is None or curr_min_val &lt; min_val:\n                min_val = curr_min_val\n\n            if max_val is None or curr_max_val &gt; max_val:\n                max_val = curr_max_val\n\n            extra_kwargs = {}\n            if wavefunction_color is not None:\n                if isinstance(wavefunction_color, list):\n                    extra_kwargs[\"color\"] = wavefunction_color[n]\n                else:\n                    extra_kwargs[\"color\"] = wavefunction_color\n\n            ax.plot(\n                phi_vals, (wf_vals - min_potential)*y_scale_factor, label=f\"$|${n}$\\\\rangle$\", linestyle=\"-\", linewidth=1, **extra_kwargs\n            )\n\n            ax.fill_between(phi_vals, (energy_levels[n] - min_potential)*y_scale_factor, (wf_vals - min_potential)*y_scale_factor, alpha=0.5, **extra_kwargs)\n\n        ax.plot(\n            phi_vals,\n            (potential - min_potential)*y_scale_factor,\n            label=\"potential\",\n            color=\"black\",\n            linestyle=\"-\",\n            linewidth=1,\n        )\n\n        ylim = ylim if ylim is not None else [jnp.min(jnp.array([min_val - 1 - min_potential, jnp.min(potential) - min_potential]))*y_scale_factor, (max_val + 1 - min_potential)*y_scale_factor]\n        ax.set_ylim(ylim)\n        ax.set_xlabel(r\"$\\varphi/2\\pi$\")\n        ax.set_ylabel(r\"Energy [GHz]\")\n\n        if mode == \"abs\":\n            title_str = r\"$|\\psi_n(\\Phi)|^2$\"\n        elif mode == \"real\":\n            title_str = r\"Re($\\psi_n(\\Phi)$)\"\n        elif mode == \"imag\":\n            title_str = r\"Im($\\psi_n(\\Phi)$)\"\n\n        ax.set_title(f\"{title_str}\")\n\n        ax.legend(fontsize='xx-small')\n        fig.tight_layout()\n\n        return ax\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.FluxDevice.phi_zpf","title":"<code>phi_zpf()</code>  <code>abstractmethod</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@abstractmethod\ndef phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.FluxDevice.potential","title":"<code>potential(phi)</code>  <code>abstractmethod</code>","text":"<p>Return potential energy as a function of phi.</p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@abstractmethod\ndef potential(self, phi):\n    \"\"\"Return potential energy as a function of phi.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Fluxonium","title":"<code>Fluxonium</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Fluxonium Device.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>@struct.dataclass\nclass Fluxonium(FluxDevice):\n    \"\"\"\n    Fluxonium Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        ops[\"cos(\u03c6/2)\"] = cosm(ops[\"phi\"] / 2)\n        ops[\"sin(\u03c6/2)\"] = sinm(ops[\"phi\"] / 2)\n\n        return ops\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        phi_op = self.linear_ops[\"phi\"]\n        return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n\n    def get_H_nonlinear(self, phi_op):\n        op_cos_phi = cosm(phi_op)\n        op_sin_phi = sinm(phi_op)\n\n        phi_ext = self.params[\"phi_ext\"]\n        Hcos = op_cos_phi * jnp.cos(2.0 * jnp.pi * phi_ext) + op_sin_phi * jnp.sin(\n            2.0 * jnp.pi * phi_ext\n        )\n        H_nl = -self.params[\"Ej\"] * Hcos\n        return H_nl\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        phi_ext = self.params[\"phi_ext\"]\n        V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return V_linear\n\n        V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n        if self.hamiltonian == HamiltonianTypes.full:\n            return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Fluxonium.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    ops[\"cos(\u03c6/2)\"] = cosm(ops[\"phi\"] / 2)\n    ops[\"sin(\u03c6/2)\"] = sinm(ops[\"phi\"] / 2)\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Fluxonium.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    phi_op = self.linear_ops[\"phi\"]\n    return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Fluxonium.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Fluxonium.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Fluxonium.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Fluxonium.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    phi_ext = self.params[\"phi_ext\"]\n    V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return V_linear\n\n    V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n    if self.hamiltonian == HamiltonianTypes.full:\n        return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.IdealQubit","title":"<code>IdealQubit</code>","text":"<p>               Bases: <code>Device</code></p> <p>Ideal qubit Device.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>@struct.dataclass\nclass IdealQubit(Device):\n    \"\"\"\n    Ideal qubit Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, (\n            \"IdealQubit is a two-level system defined in the Fock basis.\"\n        )\n        assert hamiltonian == HamiltonianTypes.full, (\n            \"IdealQubit requires a full Hamiltonian.\"\n        )\n        assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n        assert \"f\" in params, \"IdealQubit requires a frequency parameter 'f'.\"\n\n        params[\"\u0394\"] = params.get(\"\u0394\", 0.0)\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        assert self.N_pre_diag == 2\n        assert self.N == 2\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"sigmaz\"] = sigmaz()\n        ops[\"sigmax\"] = sigmax()\n        ops[\"sigmay\"] = sigmay()\n        ops[\"sigmam\"] = sigmam()\n        ops[\"sigmap\"] = sigmap()\n\n        return ops\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"f\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return (w / 2) * self.linear_ops[\"sigmaz\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        return self.get_H_linear() + self.params[\"\u0394\"] / 2 * self.linear_ops[\"sigmax\"] \n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.IdealQubit.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    assert self.N_pre_diag == 2\n    assert self.N == 2\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"sigmaz\"] = sigmaz()\n    ops[\"sigmax\"] = sigmax()\n    ops[\"sigmay\"] = sigmay()\n    ops[\"sigmam\"] = sigmam()\n    ops[\"sigmap\"] = sigmap()\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.IdealQubit.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    return self.get_H_linear() + self.params[\"\u0394\"] / 2 * self.linear_ops[\"sigmax\"] \n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.IdealQubit.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return (w / 2) * self.linear_ops[\"sigmaz\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.IdealQubit.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"f\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.IdealQubit.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, (\n        \"IdealQubit is a two-level system defined in the Fock basis.\"\n    )\n    assert hamiltonian == HamiltonianTypes.full, (\n        \"IdealQubit requires a full Hamiltonian.\"\n    )\n    assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n    assert \"f\" in params, \"IdealQubit requires a frequency parameter 'f'.\"\n\n    params[\"\u0394\"] = params.get(\"\u0394\", 0.0)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.KNO","title":"<code>KNO</code>","text":"<p>               Bases: <code>Device</code></p> <p>Kerr Nonlinear Oscillator Device.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>@struct.dataclass\nclass KNO(Device):\n    \"\"\"\n    Kerr Nonlinear Oscillator Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, (\n            \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\"\n        )\n        assert hamiltonian == HamiltonianTypes.full, (\n            \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n        )\n        assert \"f\" in params and \"\u03b1\" in params, (\n            \"Kerr Nonlinear Oscillator requires frequency 'f' and anharmonicity '\u03b1' as parameters.\"\n        )\n\n    def common_ops(self):\n        ops = {}\n\n        N = self.N\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = (ops[\"a\"] + ops[\"a_dag\"]) / jnp.sqrt(2)\n        ops[\"n\"] = 1j * (ops[\"a_dag\"] - ops[\"a\"]) / jnp.sqrt(2)\n        return ops\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"f\"]\n\n    def get_anharm(self):\n        \"\"\"Get anharmonicity.\"\"\"\n        return self.params[\"\u03b1\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        \u03b1 = self.get_anharm()\n\n        return self.get_H_linear() + (\u03b1 / 2) * (\n            self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a\"]\n            @ self.linear_ops[\"a\"]\n        )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.KNO.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    \u03b1 = self.get_anharm()\n\n    return self.get_H_linear() + (\u03b1 / 2) * (\n        self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a\"]\n        @ self.linear_ops[\"a\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.KNO.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.KNO.get_anharm","title":"<code>get_anharm()</code>","text":"<p>Get anharmonicity.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_anharm(self):\n    \"\"\"Get anharmonicity.\"\"\"\n    return self.params[\"\u03b1\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.KNO.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"f\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.KNO.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, (\n        \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\"\n    )\n    assert hamiltonian == HamiltonianTypes.full, (\n        \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n    )\n    assert \"f\" in params and \"\u03b1\" in params, (\n        \"Kerr Nonlinear Oscillator requires frequency 'f' and anharmonicity '\u03b1' as parameters.\"\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray","title":"<code>Qarray</code>","text":"Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@struct.dataclass  # this allows us to send in and return Qarray from jitted functions\nclass Qarray:\n    _data: Array\n    _qdims: Qdims = struct.field(pytree_node=False)\n    _bdims: tuple[int] = struct.field(pytree_node=False)\n\n    # Initialization ----\n    @classmethod\n    def create(cls, data, dims=None, bdims=None):\n        # Step 1: Prepare data ----\n        data = jnp.asarray(data)\n\n        if len(data.shape) == 1 and data.shape[0] &gt; 0:\n            data = data.reshape(data.shape[0], 1)\n\n        if len(data.shape) &gt;= 2:\n            if data.shape[-2] != data.shape[-1] and not (\n                data.shape[-2] == 1 or data.shape[-1] == 1\n            ):\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n\n        if bdims is not None:\n            if len(data.shape) - len(bdims) == 1:\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n        # ----\n\n        # Step 2: Prepare dimensions ----\n        if bdims is None:\n            bdims = tuple(data.shape[:-2])\n\n        if dims is None:\n            dims = ((data.shape[-2],), (data.shape[-1],))\n\n        if not isinstance(dims[0], (list, tuple)):\n            # This handles the case where only the hilbert space dimensions are sent in.\n            if data.shape[-1] == 1:\n                dims = (tuple(dims), tuple([1 for _ in dims]))\n            elif data.shape[-2] == 1:\n                dims = (tuple([1 for _ in dims]), tuple(dims))\n            else:\n                dims = (tuple(dims), tuple(dims))\n        else:\n            dims = (tuple(dims[0]), tuple(dims[1]))\n\n        check_dims(dims, bdims, data.shape)\n\n        qdims = Qdims(dims)\n\n        # NOTE: Constantly tidying up on Qarray creation might be a bit overkill.\n        # It increases the compilation time, but only very slightly\n        # increased the runtime of the jit compiled function.\n        # We could instead use this tidy_up where we think we need it.\n        data = tidy_up(data, SETTINGS[\"auto_tidyup_atol\"])\n\n        return cls(data, qdims, bdims)\n\n    # ----\n\n    @classmethod\n    def from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n        \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n        data = jnp.array([qarr.data for qarr in qarr_list])\n\n        if len(qarr_list) == 0:\n            dims = ((), ())\n            bdims = ()\n        else:\n            dims = qarr_list[0].dims\n            bdims = qarr_list[0].bdims\n\n        if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n            raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n        bdims = (len(qarr_list),) + bdims\n\n        return cls.create(data, dims=dims, bdims=bdims)\n\n    @classmethod\n    def from_array(cls, qarr_arr) -&gt; Qarray:\n        \"\"\"Create a Qarray from a nested list of Qarrays.\n\n        Args:\n            qarr_arr (list): nested list of Qarrays\n\n        Returns:\n            Qarray: Qarray object\n        \"\"\"\n        if isinstance(qarr_arr, Qarray):\n            return qarr_arr\n\n        bdims = ()\n        lvl = qarr_arr\n        while not isinstance(lvl, Qarray):\n            bdims = bdims + (len(lvl),)\n            if len(lvl) &gt; 0:\n                lvl = lvl[0]\n            else:\n                break\n\n        def flat(lis):\n            flatList = []\n            for element in lis:\n                if type(element) is list:\n                    flatList += flat(element)\n                else:\n                    flatList.append(element)\n            return flatList\n\n        qarr_list = flat(qarr_arr)\n        qarr = cls.from_list(qarr_list)\n        qarr = qarr.reshape_bdims(*bdims)\n        return qarr\n\n    # Properties ----\n    @property\n    def qtype(self):\n        return self._qdims.qtype\n\n    @property\n    def dtype(self):\n        return self._data.dtype\n\n    @property\n    def dims(self):\n        return self._qdims.dims\n\n    @property\n    def bdims(self):\n        return self._bdims\n\n    @property\n    def qdims(self):\n        return self._qdims\n\n    @property\n    def space_dims(self):\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return self.dims[0]\n        elif self.qtype == Qtypes.bra:\n            return self.dims[1]\n        else:\n            # TODO: not reached for some reason\n            raise ValueError(\"Unsupported qtype.\")\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def shaped_data(self):\n        return self._data.reshape(self.bdims + self.dims[0] + self.dims[1])\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def is_batched(self):\n        return len(self.bdims) &gt; 0\n\n    def __getitem__(self, index):\n        if len(self.bdims) &gt; 0:\n            return Qarray.create(\n                self.data[index],\n                dims=self.dims,\n            )\n        else:\n            raise ValueError(\"Cannot index a non-batched Qarray.\")\n\n    def reshape_bdims(self, *args):\n        \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n        new_bdims = tuple(args)\n\n        if prod(new_bdims) == 0:\n            new_shape = new_bdims\n        else:\n            new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n        return Qarray.create(\n            self.data.reshape(new_shape),\n            dims=self.dims,\n            bdims=new_bdims,\n        )\n\n    def space_to_qdims(self, space_dims: List[int]):\n        if isinstance(space_dims[0], (list, tuple)):\n            return space_dims\n\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return (tuple(space_dims), tuple([1 for _ in range(len(space_dims))]))\n        elif self.qtype == Qtypes.bra:\n            return (tuple([1 for _ in range(len(space_dims))]), tuple(space_dims))\n        else:\n            raise ValueError(\"Unsupported qtype for space_to_qdims conversion.\")\n\n    def reshape_qdims(self, *args):\n        \"\"\"Reshape the quantum dimensions of the Qarray.\n\n        Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n        Args:\n            *args: new Hilbert dimensions for the Qarray.\n\n        Returns:\n            Qarray: reshaped Qarray.\n        \"\"\"\n\n        new_space_dims = tuple(args)\n        current_space_dims = self.space_dims\n        assert prod(new_space_dims) == prod(current_space_dims)\n\n        new_qdims = self.space_to_qdims(new_space_dims)\n        new_bdims = self.bdims\n\n        return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n\n    def resize(self, new_shape):\n        \"\"\"Resize the Qarray to a new shape.\n\n        TODO: review and maybe deprecate this method.\n        \"\"\"\n        dims = self.dims\n        data = jnp.resize(self.data, new_shape)\n        return Qarray.create(\n            data,\n            dims=dims,\n        )\n\n    def __len__(self):\n        \"\"\"Length of the Qarray.\"\"\"\n        if len(self.bdims) &gt; 0:\n            return self.data.shape[0]\n        else:\n            raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Qarray):\n            raise ValueError(\"Cannot calculate equality of a Qarray with a non-Qarray.\")\n\n        if self.dims != other.dims:\n            return False\n\n        if self.bdims != other.bdims:\n            return False\n\n        return jnp.all(self.data == other.data)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # ----\n\n    # Elementary Math ----\n    def __matmul__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        _qdims_new = self._qdims @ other._qdims\n        return Qarray.create(\n            self.data @ other.data,\n            dims=_qdims_new.dims,\n        )\n\n    # NOTE: not possible to reach this.\n    # def __rmatmul__(self, other):\n    #     if not isinstance(other, Qarray):\n    #         return NotImplemented\n\n    #     _qdims_new = other._qdims @ self._qdims\n    #     return Qarray.create(\n    #         other.data @ self.data,\n    #         dims=_qdims_new.dims,\n    #     )\n\n    def __mul__(self, other):\n        if isinstance(other, Qarray):\n            return self.__matmul__(other)\n\n        other = other + 0.0j\n        if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n            other = other.reshape(other.shape + (1, 1))\n\n        return Qarray.create(\n            other * self.data,\n            dims=self._qdims.dims,\n        )\n\n    def __rmul__(self, other):\n        # NOTE: not possible to reach this.\n        # if isinstance(other, Qarray):\n        #     return self.__rmatmul__(other)\n\n        return self.__mul__(other)\n\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    def __truediv__(self, other):\n        \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n        if isinstance(other, Qarray):\n            raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n        return self.__mul__(1 / other)\n\n    def __add__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data + other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__add__(other)\n\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data - other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__sub__(other)\n\n        return NotImplemented\n\n    def __rsub__(self, other):\n        return self.__neg__().__add__(other)\n\n    def __xor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(self, other)\n\n    def __rxor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(other, self)\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n\n        return powm(self, other)\n\n    # ----\n\n    # String Representation ----\n    def _str_header(self):\n        out = \", \".join(\n            [\n                \"Quantum array: dims = \" + str(self.dims),\n                \"bdims = \" + str(self.bdims),\n                \"shape = \" + str(self._data.shape),\n                \"type = \" + str(self.qtype),\n            ]\n        )\n        return out\n\n    def __str__(self):\n        return self._str_header() + \"\\nQarray data =\\n\" + str(self.data)\n\n    @property\n    def header(self):\n        \"\"\"Print the header of the Qarray.\"\"\"\n        return self._str_header()\n\n    def __repr__(self):\n        return self.__str__()\n\n    # ----\n\n    # Utilities ----\n    def copy(self, memo=None):\n        # return Qarray.create(deepcopy(self.data), dims=self.dims)\n        return self.__deepcopy__(memo)\n\n    def __deepcopy__(self, memo):\n        \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n        return Qarray(\n            _data=deepcopy(self._data, memo=memo),\n            _qdims=deepcopy(self._qdims, memo=memo),\n            _bdims=deepcopy(self._bdims, memo=memo),\n        )\n\n    def __getattr__(self, method_name):\n        if \"__\" == method_name[:2]:\n            # NOTE: we return NotImplemented for binary special methods logic in python, plus things like __jax_array__\n            return lambda *args, **kwargs: NotImplemented\n\n        modules = [jnp, jnp.linalg, jsp, jsp.linalg]\n\n        method_f = None\n        for mod in modules:\n            method_f = getattr(mod, method_name, None)\n            if method_f is not None:\n                break\n\n        if method_f is None:\n            raise NotImplementedError(\n                f\"Method {method_name} does not exist. No backup method found in {modules}.\"\n            )\n\n        def func(*args, **kwargs):\n            res = method_f(self.data, *args, **kwargs)\n\n            if getattr(res, \"shape\", None) is None or res.shape != self.data.shape:\n                return res\n            else:\n                return Qarray.create(res, dims=self._qdims.dims)\n\n        return func\n\n    # ----\n\n    # Conversions / Reshaping ----\n    def dag(self):\n        return dag(self)\n\n    def to_dm(self):\n        return ket2dm(self)\n\n    def is_dm(self):\n        return self.qtype == Qtypes.oper\n\n    def is_vec(self):\n        return self.qtype == Qtypes.ket or self.qtype == Qtypes.bra\n\n    def to_ket(self):\n        return to_ket(self)\n\n    def transpose(self, *args):\n        return transpose(self, *args)\n\n    def keep_only_diag_elements(self):\n        return keep_only_diag_elements(self)\n\n    # ----\n\n    # Math Functions ----\n    def unit(self):\n        return unit(self)\n\n    def norm(self):\n        return norm(self)\n\n    def expm(self):\n        return expm(self)\n\n    def powm(self, n):\n        return powm(self, n)\n\n    def cosm(self):\n        return cosm(self)\n\n    def sinm(self):\n        return sinm(self)\n\n    def tr(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def trace(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def ptrace(self, indx):\n        return ptrace(self, indx)\n\n    def eigenstates(self):\n        return eigenstates(self)\n\n    def eigenenergies(self):\n        return eigenenergies(self)\n\n    def collapse(self, mode=\"sum\"):\n        return collapse(self, mode=mode)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.header","title":"<code>header</code>  <code>property</code>","text":"<p>Print the header of the Qarray.</p>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Need to override this when defininig getattr.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n    return Qarray(\n        _data=deepcopy(self._data, memo=memo),\n        _qdims=deepcopy(self._qdims, memo=memo),\n        _bdims=deepcopy(self._bdims, memo=memo),\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.__len__","title":"<code>__len__()</code>","text":"<p>Length of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __len__(self):\n    \"\"\"Length of the Qarray.\"\"\"\n    if len(self.bdims) &gt; 0:\n        return self.data.shape[0]\n    else:\n        raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>For Qarray's, this only really makes sense in the context of division by a scalar.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n    if isinstance(other, Qarray):\n        raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n    return self.__mul__(1 / other)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.from_array","title":"<code>from_array(qarr_arr)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a nested list of Qarrays.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_arr</code> <code>list</code> <p>nested list of Qarrays</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Qarray object</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_array(cls, qarr_arr) -&gt; Qarray:\n    \"\"\"Create a Qarray from a nested list of Qarrays.\n\n    Args:\n        qarr_arr (list): nested list of Qarrays\n\n    Returns:\n        Qarray: Qarray object\n    \"\"\"\n    if isinstance(qarr_arr, Qarray):\n        return qarr_arr\n\n    bdims = ()\n    lvl = qarr_arr\n    while not isinstance(lvl, Qarray):\n        bdims = bdims + (len(lvl),)\n        if len(lvl) &gt; 0:\n            lvl = lvl[0]\n        else:\n            break\n\n    def flat(lis):\n        flatList = []\n        for element in lis:\n            if type(element) is list:\n                flatList += flat(element)\n            else:\n                flatList.append(element)\n        return flatList\n\n    qarr_list = flat(qarr_arr)\n    qarr = cls.from_list(qarr_list)\n    qarr = qarr.reshape_bdims(*bdims)\n    return qarr\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.from_list","title":"<code>from_list(qarr_list)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a list of Qarrays.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n    \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n    data = jnp.array([qarr.data for qarr in qarr_list])\n\n    if len(qarr_list) == 0:\n        dims = ((), ())\n        bdims = ()\n    else:\n        dims = qarr_list[0].dims\n        bdims = qarr_list[0].bdims\n\n    if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n        raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n    bdims = (len(qarr_list),) + bdims\n\n    return cls.create(data, dims=dims, bdims=bdims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.reshape_bdims","title":"<code>reshape_bdims(*args)</code>","text":"<p>Reshape the batch dimensions of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_bdims(self, *args):\n    \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n    new_bdims = tuple(args)\n\n    if prod(new_bdims) == 0:\n        new_shape = new_bdims\n    else:\n        new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n    return Qarray.create(\n        self.data.reshape(new_shape),\n        dims=self.dims,\n        bdims=new_bdims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.reshape_qdims","title":"<code>reshape_qdims(*args)</code>","text":"<p>Reshape the quantum dimensions of the Qarray.</p> <p>Note that this does not take in qdims but rather the new Hilbert space dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>new Hilbert dimensions for the Qarray.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>reshaped Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_qdims(self, *args):\n    \"\"\"Reshape the quantum dimensions of the Qarray.\n\n    Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n    Args:\n        *args: new Hilbert dimensions for the Qarray.\n\n    Returns:\n        Qarray: reshaped Qarray.\n    \"\"\"\n\n    new_space_dims = tuple(args)\n    current_space_dims = self.space_dims\n    assert prod(new_space_dims) == prod(current_space_dims)\n\n    new_qdims = self.space_to_qdims(new_space_dims)\n    new_bdims = self.bdims\n\n    return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Qarray.resize","title":"<code>resize(new_shape)</code>","text":"<p>Resize the Qarray to a new shape.</p> <p>TODO: review and maybe deprecate this method.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def resize(self, new_shape):\n    \"\"\"Resize the Qarray to a new shape.\n\n    TODO: review and maybe deprecate this method.\n    \"\"\"\n    dims = self.dims\n    data = jnp.resize(self.data, new_shape)\n    return Qarray.create(\n        data,\n        dims=dims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Resonator","title":"<code>Resonator</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Resonator Device.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>@struct.dataclass\nclass Resonator(FluxDevice):\n    \"\"\"\n    Resonator Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"] + 1 / 2)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Resonator.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Resonator.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Resonator.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"] + 1 / 2)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Resonator.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Resonator.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Resonator.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL","title":"<code>SNAIL</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>SNAIL Device.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>@struct.dataclass\nclass SNAIL(FluxDevice):\n    \"\"\"\n    SNAIL Device.\n    \"\"\"\n\n    DEFAULT_BASIS = BasisTypes.charge\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n\n        assert params[\"m\"] % 1 == 0, \"m must be an integer.\"\n        assert params[\"m\"] &gt;= 2, \"m must be greater than or equal to 2.\"\n\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            charge_basis_types = [\n                BasisTypes.charge\n            ]\n            assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n            assert (N_pre_diag - 1) % 2 * (params[\"m\"]) == 0, \"(N_pre_diag - 1)/2 must be divisible by m.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = identity(N)\n            ops[\"a\"] = destroy(N)\n            ops[\"a_dag\"] = create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            m = self.params[\"m\"]\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6/m)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6/m)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=m) + jnp.eye(N, k=-m)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=m) - jnp.eye(N, k=-m)))\n\n            n_max = (N - 1) // 2\n            n_array = jnp.arange(-n_max, n_max + 1) / self.params[\"m\"]\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n\n            n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n\n        \u03b1 = self.params[\"alpha\"]\n        m = self.params[\"m\"]\n        phi_ext = self.params[\"phi_ext\"]\n        Ej = self.Ej\n\n        H_charge = self.original_ops[\"H_charge\"]\n        H_inductive = - \u03b1 * Ej * self.original_ops[\"cos(\u03c6)\"] - m * Ej * (\n            jnp.cos(2 * jnp.pi * phi_ext/m) * self.original_ops[\"cos(\u03c6/m)\"] + jnp.sin(2 * jnp.pi * phi_ext/m) * self.original_ops[\"sin(\u03c6/m)\"]\n        )\n        return H_charge + H_inductive\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        raise NotImplementedError(\"Truncated Hamiltonian not implemented for SNAIL.\")\n        # phi_op = self.original_ops[\"phi\"]  \n        # fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        # sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        # return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n\n            \u03b1 = self.params[\"alpha\"]\n            m = self.params[\"m\"]\n            phi_ext = self.params[\"phi_ext\"]\n\n            return - \u03b1 * self.Ej * jnp.cos(2 * jnp.pi * phi) - (\n                m * self.Ej * jnp.cos(2 * jnp.pi * (phi_ext - phi) / m)\n            )\n\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            raise NotImplementedError(\"Truncated potential not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        m = self.params[\"m\"]\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6/m)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6/m)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=m) + jnp.eye(N, k=-m)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=m) - jnp.eye(N, k=-m)))\n\n        n_max = (N - 1) // 2\n        n_array = jnp.arange(-n_max, n_max + 1) / self.params[\"m\"]\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n\n        n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n\n    \u03b1 = self.params[\"alpha\"]\n    m = self.params[\"m\"]\n    phi_ext = self.params[\"phi_ext\"]\n    Ej = self.Ej\n\n    H_charge = self.original_ops[\"H_charge\"]\n    H_inductive = - \u03b1 * Ej * self.original_ops[\"cos(\u03c6)\"] - m * Ej * (\n        jnp.cos(2 * jnp.pi * phi_ext/m) * self.original_ops[\"cos(\u03c6/m)\"] + jnp.sin(2 * jnp.pi * phi_ext/m) * self.original_ops[\"sin(\u03c6/m)\"]\n    )\n    return H_charge + H_inductive\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    raise NotImplementedError(\"Truncated Hamiltonian not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n\n    assert params[\"m\"] % 1 == 0, \"m must be an integer.\"\n    assert params[\"m\"] &gt;= 2, \"m must be greater than or equal to 2.\"\n\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        charge_basis_types = [\n            BasisTypes.charge\n        ]\n        assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        assert (N_pre_diag - 1) % 2 * (params[\"m\"]) == 0, \"(N_pre_diag - 1)/2 must be divisible by m.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.SNAIL.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n\n        \u03b1 = self.params[\"alpha\"]\n        m = self.params[\"m\"]\n        phi_ext = self.params[\"phi_ext\"]\n\n        return - \u03b1 * self.Ej * jnp.cos(2 * jnp.pi * phi) - (\n            m * self.Ej * jnp.cos(2 * jnp.pi * (phi_ext - phi) / m)\n        )\n\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        raise NotImplementedError(\"Truncated potential not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon","title":"<code>Transmon</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Transmon Device.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>@struct.dataclass\nclass Transmon(FluxDevice):\n    \"\"\"\n    Transmon Device.\n    \"\"\"\n\n    DEFAULT_BASIS = BasisTypes.charge\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            charge_basis_types = [\n                BasisTypes.charge,\n                BasisTypes.singlecharge,\n                BasisTypes.singlecharge_even,\n                BasisTypes.singlecharge_odd,\n            ]\n            assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n        if basis in [BasisTypes.singlecharge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            assert (N_pre_diag) % 2 == 0, \"N_pre_diag must be even for single charge bases.\"\n        else:\n            assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = identity(N)\n            ops[\"a\"] = destroy(N)\n            ops[\"a_dag\"] = create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n            ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n            ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n\n            n_max = (N - 1) // 2\n            n_array = jnp.arange(-n_max, n_max + 1)\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            n_max = N\n\n            if self.basis == BasisTypes.singlecharge_even:\n                n_array = jnp.arange(-n_max, n_max, 2)\n            elif self.basis == BasisTypes.singlecharge_odd:\n                n_array = jnp.arange(-n_max + 1, n_max, 2)\n\n            ops[\"id\"] = identity(n_max)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=1) + jnp.eye(n_max, k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=1) - jnp.eye(n_max, k=-1)))\n            ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=2) + jnp.eye(n_max, k=-2)))\n            ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=2) - jnp.eye(n_max, k=-2)))\n\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(n_max)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis == BasisTypes.singlecharge:\n            \"\"\"\n            Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n            thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n            not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n            (as done in Kyle's thesis).\n            \"\"\"\n            n_max = (N) // 2\n\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n            ops[\"cos(\u03c6/2)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6/2)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n\n            n_array = jnp.arange(-n_max, n_max)\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n        return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        phi_op = self.original_ops[\"phi\"]  \n        fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            phi_scaled = 2 * jnp.pi * phi\n            second_order = 0.5 * self.Ej * phi_scaled ** 2\n            fourth_order =  -(1 / 24) * self.Ej * phi_scaled ** 4\n            sixth_order = (1 / 720) * self.Ej * phi_scaled ** 6\n            return second_order + fourth_order + sixth_order\n\n    def calculate_wavefunctions(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\n\n        TODO: this is not currently being used for plotting... needs to be updated!\n        \"\"\"\n\n        if self.basis == BasisTypes.fock:\n            return super().calculate_wavefunctions(phi_vals)\n        elif self.basis == BasisTypes.singlecharge:\n            raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n        elif self.basis in [BasisTypes.charge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            phi_vals = jnp.array(phi_vals)\n\n            if self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n                n_labels = 1/2 * jnp.diag(self.original_ops[\"n\"].data)\n            else:\n                n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n            wavefunctions = []\n            for nj in range(self.N_pre_diag):\n                wavefunction = []\n                for phi in phi_vals:\n                    wavefunction.append(\n                        (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                            self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                        )\n                    )\n                wavefunctions.append(jnp.array(wavefunction))\n            return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.calculate_wavefunctions","title":"<code>calculate_wavefunctions(phi_vals)</code>","text":"<p>Calculate wavefunctions at phi_exts.</p> <p>TODO: this is not currently being used for plotting... needs to be updated!</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def calculate_wavefunctions(self, phi_vals):\n    \"\"\"Calculate wavefunctions at phi_exts.\n\n    TODO: this is not currently being used for plotting... needs to be updated!\n    \"\"\"\n\n    if self.basis == BasisTypes.fock:\n        return super().calculate_wavefunctions(phi_vals)\n    elif self.basis == BasisTypes.singlecharge:\n        raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n    elif self.basis in [BasisTypes.charge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        phi_vals = jnp.array(phi_vals)\n\n        if self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            n_labels = 1/2 * jnp.diag(self.original_ops[\"n\"].data)\n        else:\n            n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n        wavefunctions = []\n        for nj in range(self.N_pre_diag):\n            wavefunction = []\n            for phi in phi_vals:\n                wavefunction.append(\n                    (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                        self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                    )\n                )\n            wavefunctions.append(jnp.array(wavefunction))\n        return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n        ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n        ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n\n        n_max = (N - 1) // 2\n        n_array = jnp.arange(-n_max, n_max + 1)\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        n_max = N\n\n        if self.basis == BasisTypes.singlecharge_even:\n            n_array = jnp.arange(-n_max, n_max, 2)\n        elif self.basis == BasisTypes.singlecharge_odd:\n            n_array = jnp.arange(-n_max + 1, n_max, 2)\n\n        ops[\"id\"] = identity(n_max)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=1) + jnp.eye(n_max, k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=1) - jnp.eye(n_max, k=-1)))\n        ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=2) + jnp.eye(n_max, k=-2)))\n        ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=2) - jnp.eye(n_max, k=-2)))\n\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(n_max)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis == BasisTypes.singlecharge:\n        \"\"\"\n        Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n        thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n        not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n        (as done in Kyle's thesis).\n        \"\"\"\n        n_max = (N) // 2\n\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n        ops[\"cos(\u03c6/2)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6/2)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n\n        n_array = jnp.arange(-n_max, n_max)\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n    return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    phi_op = self.original_ops[\"phi\"]  \n    fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n    sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n    return self.get_H_linear() + fourth_order_term + sixth_order_term\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        charge_basis_types = [\n            BasisTypes.charge,\n            BasisTypes.singlecharge,\n            BasisTypes.singlecharge_even,\n            BasisTypes.singlecharge_odd,\n        ]\n        assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n\n    if basis in [BasisTypes.singlecharge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        assert (N_pre_diag) % 2 == 0, \"N_pre_diag must be even for single charge bases.\"\n    else:\n        assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.Transmon.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n        return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        phi_scaled = 2 * jnp.pi * phi\n        second_order = 0.5 * self.Ej * phi_scaled ** 2\n        fourth_order =  -(1 / 24) * self.Ej * phi_scaled ** 4\n        sixth_order = (1 / 720) * self.Ej * phi_scaled ** 6\n        return second_order + fourth_order + sixth_order\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.TunableTransmon","title":"<code>TunableTransmon</code>","text":"<p>               Bases: <code>Transmon</code></p> <p>Tunable Transmon Device.</p> Source code in <code>jaxquantum/devices/superconducting/tunable_transmon.py</code> <pre><code>@struct.dataclass\nclass TunableTransmon(Transmon):\n    \"\"\"\n    Tunable Transmon Device.\n    \"\"\"\n\n    @property\n    def Ej(self):\n        Ejsum = self.params[\"Ej1\"] + self.params[\"Ej2\"]\n        phi_ext = 2 * jnp.pi * self.params[\"phi_ext\"]\n        gamma = self.params[\"Ej2\"] / self.params[\"Ej1\"]\n        d = (gamma - 1) / (gamma + 1)\n        external_flux_factor = jnp.abs(\n            jnp.sqrt(jnp.cos(phi_ext / 2) ** 2 + d**2 * jnp.sin(phi_ext / 2) ** 2)\n        )\n        return Ejsum * external_flux_factor\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.cosm","title":"<code>cosm(qarr)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Matrix cosine wrapper.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    dims = qarr.dims\n    data = cosm_data(qarr.data)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.harm_osc_wavefunction","title":"<code>harm_osc_wavefunction(n, x, l_osc)</code>","text":"<p>Taken from scqubits... not jit-able</p> <p>For given quantum number n=0,1,2,... return the value of the harmonic oscillator wave function :math:<code>\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{ osc})</code>, N being the proper normalization factor.</p> <p>Directly uses <code>scipy.special.pbdv</code> (implementation of the parabolic cylinder function) to mitigate numerical stability issues with the more commonly used expression in terms of a Gaussian and a Hermite polynomial factor.</p>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.harm_osc_wavefunction--parameters","title":"Parameters","text":"<p>n:     index of wave function, n=0 is ground state x:     coordinate(s) where wave function is evaluated l_osc:     oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2</p>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.harm_osc_wavefunction--returns","title":"Returns","text":"<pre><code>value of harmonic oscillator wave function\n</code></pre> Source code in <code>jaxquantum/devices/common/utils.py</code> <pre><code>def harm_osc_wavefunction(n, x, l_osc):\n    r\"\"\"\n    Taken from scqubits... not jit-able\n\n    For given quantum number n=0,1,2,... return the value of the harmonic\n    oscillator wave function :math:`\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{\n    osc})`, N being the proper normalization factor.\n\n    Directly uses `scipy.special.pbdv` (implementation of the parabolic cylinder\n    function) to mitigate numerical stability issues with the more commonly used\n    expression in terms of a Gaussian and a Hermite polynomial factor.\n\n    Parameters\n    ----------\n    n:\n        index of wave function, n=0 is ground state\n    x:\n        coordinate(s) where wave function is evaluated\n    l_osc:\n        oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2\n\n    Returns\n    -------\n        value of harmonic oscillator wave function\n    \"\"\"\n    x = 2 * jnp.pi * x\n    result = pbdv(n, jnp.sqrt(2.0) * x / l_osc)[0]\n    result = result / jnp.sqrt(l_osc * jnp.sqrt(jnp.pi) * factorial_approx(n))\n    return result\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.jnp2jqt","title":"<code>jnp2jqt(arr, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnp2jqt(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n        dims: Qarray dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    dims = extract_dims(arr, dims) if dims is not None else None\n    return Qarray.create(arr, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.run_sweep","title":"<code>run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode='end', return_errors=False)</code>","text":"<p>Run a sweep over a single parameter, or multiple parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>The base parameters to sweep over.</p> required <code>sweep_params</code> <code>dict</code> <p>The parameters to sweep over. key: The parameter name. value: The list of values to sweep over.</p> required <code>metrics_func</code> <code>function</code> <p>The function to evaluate the metrics.</p> required <code>fixed_params</code> <code>dict</code> <p>The fixed parameters to send into metrics_func. Defaults to None.</p> required <code>data</code> <code>dict</code> <p>The data to append to. Defaults to None.</p> <code>None</code> <code>is_parallel</code> <code>bool</code> <p>Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.</p> <code>False</code> <code>save_file</code> <code>str</code> <p>The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).</p> <code>None</code> <code>data_save_mode</code> <code>str</code> <p>The mode to save the data. Defaults to None. Options are:     \"no\" - don't save data     \"end\" - save data at the end of the sweep     \"during\" - save data during and at the end of the sweep</p> <code>'end'</code> <p>Returns:     dict: The data after the sweep.</p> Source code in <code>jaxquantum/devices/analysis/sweeps.py</code> <pre><code>def run_sweep(\n    params,\n    sweep_params,\n    metrics_func,\n    fixed_kwargs=None,\n    data=None,\n    is_parallel=False,\n    save_file=None,\n    data_save_mode=\"end\",\n    return_errors=False,\n):\n    \"\"\"Run a sweep over a single parameter, or multiple parameters.\n\n    Args:\n        params (dict): The base parameters to sweep over.\n        sweep_params (dict): The parameters to sweep over.\n            key: The parameter name.\n            value: The list of values to sweep over.\n        metrics_func (function): The function to evaluate the metrics.\n        fixed_params (dict, optional): The fixed parameters to send into metrics_func. Defaults to None.\n        data (dict, optional): The data to append to. Defaults to None.\n        is_parallel (bool, optional): Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.\n        save_file (str, optional): The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).\n        data_save_mode (str, optional): The mode to save the data. Defaults to None.\n            Options are:\n                \"no\" - don't save data\n                \"end\" - save data at the end of the sweep\n                \"during\" - save data during and at the end of the sweep\n    Returns:\n        dict: The data after the sweep.\n    \"\"\"\n    if data is None:\n        data = {}\n        run = -1\n    else:\n        run = max(data.keys())\n\n    assert data_save_mode in [\"no\", \"end\", \"during\"], \"Invalid data_save_mode.\"\n\n    if data_save_mode in [\"during\", \"end\"]:\n        if isinstance(save_file, str):\n            print(\"Saving data to: \", save_file)\n            dirname = os.path.dirname(save_file)\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n        else:\n            save_file = save_file or NamedTemporaryFile()\n            print(\"Saving data to a temporary file: \", save_file.name)\n\n    fixed_kwargs = fixed_kwargs or {}\n\n    if is_parallel:\n        sweep_length = len(list(sweep_params.values())[0])\n        assert [len(vals) == sweep_length for vals in sweep_params.values()], (\n            \"Parallel sweep parameters must have the same length.\"\n        )\n\n        errors = []\n        try:\n            for j in tqdm(range(sweep_length)):\n                run += 1\n                data[run] = {}\n                data[run][\"params\"] = deepcopy(params)\n                sweep_point_info = {\n                    \"labels\": [],\n                    \"values\": [],\n                    \"indices\": [],\n                }\n                for key, vals in sweep_params.items():\n                    data[run][\"params\"][key] = vals[j]\n                    sweep_point_info[\"labels\"].append(key)\n                    sweep_point_info[\"values\"].append(vals[j])\n                    sweep_point_info[\"indices\"].append(j)\n                data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                data[run][\"sweep_point_info\"] = sweep_point_info\n                if data_save_mode == \"during\":\n                    jnp.savez(\n                        save_file, data=data, sweep_params=sweep_params, params=params\n                    )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(\n                    save_file,\n                    data=data,\n                    sweep_params=sweep_params,\n                    params=params,\n                    error=None,\n                )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n    else:\n        # Product Sweep\n        sweep_points = list(itertools.product(*list(sweep_params.values())))\n        sweep_points_indxs = list(\n            itertools.product(\n                *[list(range(len(vals))) for vals in list(sweep_params.values())]\n            )\n        )\n        sweep_point_labels = list(sweep_params.keys())\n\n        errors = []\n\n        try:\n            with tqdm(total=len(sweep_points)) as pbar:\n                for j, sweep_point in enumerate(sweep_points):\n                    run += 1\n                    data[run] = {}\n                    data[run][\"params\"] = deepcopy(params)\n                    sweep_point_info = {\n                        \"labels\": [],\n                        \"values\": [],\n                        \"indices\": [],\n                    }\n                    for i, key in enumerate(sweep_point_labels):\n                        data[run][\"params\"][key] = sweep_point[i]\n                        sweep_point_info[\"labels\"].append(key)\n                        sweep_point_info[\"values\"].append(sweep_point[i])\n                        sweep_point_info[\"indices\"].append(sweep_points_indxs[j][i])\n                    data[run][\"results\"] = metrics_func(\n                        data[run][\"params\"], **fixed_kwargs\n                    )\n                    data[run][\"sweep_point_info\"] = sweep_point_info\n                    pbar.update(1)\n                    if data_save_mode == \"during\":\n                        jnp.savez(\n                            save_file,\n                            data=data,\n                            sweep_params=sweep_params,\n                            params=params,\n                        )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(\n                    save_file, data=data, sweep_params=sweep_params, params=params\n                )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.sigmam","title":"<code>sigmam()</code>","text":"<p>\u03c3-</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3- Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmam() -&gt; Qarray:\n    \"\"\"\u03c3-\n\n    Returns:\n        \u03c3- Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 0.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.sigmap","title":"<code>sigmap()</code>","text":"<p>\u03c3+</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3+ Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmap() -&gt; Qarray:\n    \"\"\"\u03c3+\n\n    Returns:\n        \u03c3+ Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [0.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/index.html#jaxquantum.devices.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <code>parallel</code> <code>bool</code> <p>if True, use parallel einsum for tensor product true: [A,B] ^ [C,D] = [A^C, B^D] false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n        parallel (bool): if True, use parallel einsum for tensor product\n            true: [A,B] ^ [C,D] = [A^C, B^D]\n            false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n\n    parallel = kwargs.pop(\"parallel\", False)\n\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    dims_0 = dims[0]\n    dims_1 = dims[1]\n    for arg in args[1:]:\n        if parallel:\n            a = data\n            b = arg.data\n\n            if len(a.shape) &gt; len(b.shape):\n                batch_dim = a.shape[:-2]\n            elif len(a.shape) == len(b.shape):\n                if prod(a.shape[:-2]) &gt; prod(b.shape[:-2]):\n                    batch_dim = a.shape[:-2]\n                else:\n                    batch_dim = b.shape[:-2]\n            else:\n                batch_dim = b.shape[:-2]\n\n            data = jnp.einsum(\"...ij,...kl-&gt;...ikjl\", a, b).reshape(\n                *batch_dim, a.shape[-2] * b.shape[-2], -1\n            )\n        else:\n            data = jnp.kron(data, arg.data, **kwargs)\n\n        dims_0 = dims_0 + arg.dims[0]\n        dims_1 = dims_1 + arg.dims[1]\n\n    return Qarray.create(data, dims=(dims_0, dims_1))\n</code></pre>"},{"location":"reference/jaxquantum/devices/analysis/index.html","title":"analysis","text":"<p>Analysis Tools</p>"},{"location":"reference/jaxquantum/devices/analysis/index.html#jaxquantum.devices.analysis.run_sweep","title":"<code>run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode='end', return_errors=False)</code>","text":"<p>Run a sweep over a single parameter, or multiple parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>The base parameters to sweep over.</p> required <code>sweep_params</code> <code>dict</code> <p>The parameters to sweep over. key: The parameter name. value: The list of values to sweep over.</p> required <code>metrics_func</code> <code>function</code> <p>The function to evaluate the metrics.</p> required <code>fixed_params</code> <code>dict</code> <p>The fixed parameters to send into metrics_func. Defaults to None.</p> required <code>data</code> <code>dict</code> <p>The data to append to. Defaults to None.</p> <code>None</code> <code>is_parallel</code> <code>bool</code> <p>Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.</p> <code>False</code> <code>save_file</code> <code>str</code> <p>The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).</p> <code>None</code> <code>data_save_mode</code> <code>str</code> <p>The mode to save the data. Defaults to None. Options are:     \"no\" - don't save data     \"end\" - save data at the end of the sweep     \"during\" - save data during and at the end of the sweep</p> <code>'end'</code> <p>Returns:     dict: The data after the sweep.</p> Source code in <code>jaxquantum/devices/analysis/sweeps.py</code> <pre><code>def run_sweep(\n    params,\n    sweep_params,\n    metrics_func,\n    fixed_kwargs=None,\n    data=None,\n    is_parallel=False,\n    save_file=None,\n    data_save_mode=\"end\",\n    return_errors=False,\n):\n    \"\"\"Run a sweep over a single parameter, or multiple parameters.\n\n    Args:\n        params (dict): The base parameters to sweep over.\n        sweep_params (dict): The parameters to sweep over.\n            key: The parameter name.\n            value: The list of values to sweep over.\n        metrics_func (function): The function to evaluate the metrics.\n        fixed_params (dict, optional): The fixed parameters to send into metrics_func. Defaults to None.\n        data (dict, optional): The data to append to. Defaults to None.\n        is_parallel (bool, optional): Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.\n        save_file (str, optional): The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).\n        data_save_mode (str, optional): The mode to save the data. Defaults to None.\n            Options are:\n                \"no\" - don't save data\n                \"end\" - save data at the end of the sweep\n                \"during\" - save data during and at the end of the sweep\n    Returns:\n        dict: The data after the sweep.\n    \"\"\"\n    if data is None:\n        data = {}\n        run = -1\n    else:\n        run = max(data.keys())\n\n    assert data_save_mode in [\"no\", \"end\", \"during\"], \"Invalid data_save_mode.\"\n\n    if data_save_mode in [\"during\", \"end\"]:\n        if isinstance(save_file, str):\n            print(\"Saving data to: \", save_file)\n            dirname = os.path.dirname(save_file)\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n        else:\n            save_file = save_file or NamedTemporaryFile()\n            print(\"Saving data to a temporary file: \", save_file.name)\n\n    fixed_kwargs = fixed_kwargs or {}\n\n    if is_parallel:\n        sweep_length = len(list(sweep_params.values())[0])\n        assert [len(vals) == sweep_length for vals in sweep_params.values()], (\n            \"Parallel sweep parameters must have the same length.\"\n        )\n\n        errors = []\n        try:\n            for j in tqdm(range(sweep_length)):\n                run += 1\n                data[run] = {}\n                data[run][\"params\"] = deepcopy(params)\n                sweep_point_info = {\n                    \"labels\": [],\n                    \"values\": [],\n                    \"indices\": [],\n                }\n                for key, vals in sweep_params.items():\n                    data[run][\"params\"][key] = vals[j]\n                    sweep_point_info[\"labels\"].append(key)\n                    sweep_point_info[\"values\"].append(vals[j])\n                    sweep_point_info[\"indices\"].append(j)\n                data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                data[run][\"sweep_point_info\"] = sweep_point_info\n                if data_save_mode == \"during\":\n                    jnp.savez(\n                        save_file, data=data, sweep_params=sweep_params, params=params\n                    )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(\n                    save_file,\n                    data=data,\n                    sweep_params=sweep_params,\n                    params=params,\n                    error=None,\n                )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n    else:\n        # Product Sweep\n        sweep_points = list(itertools.product(*list(sweep_params.values())))\n        sweep_points_indxs = list(\n            itertools.product(\n                *[list(range(len(vals))) for vals in list(sweep_params.values())]\n            )\n        )\n        sweep_point_labels = list(sweep_params.keys())\n\n        errors = []\n\n        try:\n            with tqdm(total=len(sweep_points)) as pbar:\n                for j, sweep_point in enumerate(sweep_points):\n                    run += 1\n                    data[run] = {}\n                    data[run][\"params\"] = deepcopy(params)\n                    sweep_point_info = {\n                        \"labels\": [],\n                        \"values\": [],\n                        \"indices\": [],\n                    }\n                    for i, key in enumerate(sweep_point_labels):\n                        data[run][\"params\"][key] = sweep_point[i]\n                        sweep_point_info[\"labels\"].append(key)\n                        sweep_point_info[\"values\"].append(sweep_point[i])\n                        sweep_point_info[\"indices\"].append(sweep_points_indxs[j][i])\n                    data[run][\"results\"] = metrics_func(\n                        data[run][\"params\"], **fixed_kwargs\n                    )\n                    data[run][\"sweep_point_info\"] = sweep_point_info\n                    pbar.update(1)\n                    if data_save_mode == \"during\":\n                        jnp.savez(\n                            save_file,\n                            data=data,\n                            sweep_params=sweep_params,\n                            params=params,\n                        )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(\n                    save_file, data=data, sweep_params=sweep_params, params=params\n                )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n</code></pre>"},{"location":"reference/jaxquantum/devices/analysis/sweeps.html","title":"sweeps","text":"<p>Sweeping tools.</p>"},{"location":"reference/jaxquantum/devices/analysis/sweeps.html#jaxquantum.devices.analysis.sweeps.run_sweep","title":"<code>run_sweep(params, sweep_params, metrics_func, fixed_kwargs=None, data=None, is_parallel=False, save_file=None, data_save_mode='end', return_errors=False)</code>","text":"<p>Run a sweep over a single parameter, or multiple parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>The base parameters to sweep over.</p> required <code>sweep_params</code> <code>dict</code> <p>The parameters to sweep over. key: The parameter name. value: The list of values to sweep over.</p> required <code>metrics_func</code> <code>function</code> <p>The function to evaluate the metrics.</p> required <code>fixed_params</code> <code>dict</code> <p>The fixed parameters to send into metrics_func. Defaults to None.</p> required <code>data</code> <code>dict</code> <p>The data to append to. Defaults to None.</p> <code>None</code> <code>is_parallel</code> <code>bool</code> <p>Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.</p> <code>False</code> <code>save_file</code> <code>str</code> <p>The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).</p> <code>None</code> <code>data_save_mode</code> <code>str</code> <p>The mode to save the data. Defaults to None. Options are:     \"no\" - don't save data     \"end\" - save data at the end of the sweep     \"during\" - save data during and at the end of the sweep</p> <code>'end'</code> <p>Returns:     dict: The data after the sweep.</p> Source code in <code>jaxquantum/devices/analysis/sweeps.py</code> <pre><code>def run_sweep(\n    params,\n    sweep_params,\n    metrics_func,\n    fixed_kwargs=None,\n    data=None,\n    is_parallel=False,\n    save_file=None,\n    data_save_mode=\"end\",\n    return_errors=False,\n):\n    \"\"\"Run a sweep over a single parameter, or multiple parameters.\n\n    Args:\n        params (dict): The base parameters to sweep over.\n        sweep_params (dict): The parameters to sweep over.\n            key: The parameter name.\n            value: The list of values to sweep over.\n        metrics_func (function): The function to evaluate the metrics.\n        fixed_params (dict, optional): The fixed parameters to send into metrics_func. Defaults to None.\n        data (dict, optional): The data to append to. Defaults to None.\n        is_parallel (bool, optional): Whether to sweep through the sweep_params lists in parallel or through their cartesian product. Defaults to False.\n        save_file (str, optional): The file to save the data to. Defaults to None, in which case data is saved to a temporary file, which will be deleted upon closing (e.g. during garbage collection).\n        data_save_mode (str, optional): The mode to save the data. Defaults to None.\n            Options are:\n                \"no\" - don't save data\n                \"end\" - save data at the end of the sweep\n                \"during\" - save data during and at the end of the sweep\n    Returns:\n        dict: The data after the sweep.\n    \"\"\"\n    if data is None:\n        data = {}\n        run = -1\n    else:\n        run = max(data.keys())\n\n    assert data_save_mode in [\"no\", \"end\", \"during\"], \"Invalid data_save_mode.\"\n\n    if data_save_mode in [\"during\", \"end\"]:\n        if isinstance(save_file, str):\n            print(\"Saving data to: \", save_file)\n            dirname = os.path.dirname(save_file)\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n        else:\n            save_file = save_file or NamedTemporaryFile()\n            print(\"Saving data to a temporary file: \", save_file.name)\n\n    fixed_kwargs = fixed_kwargs or {}\n\n    if is_parallel:\n        sweep_length = len(list(sweep_params.values())[0])\n        assert [len(vals) == sweep_length for vals in sweep_params.values()], (\n            \"Parallel sweep parameters must have the same length.\"\n        )\n\n        errors = []\n        try:\n            for j in tqdm(range(sweep_length)):\n                run += 1\n                data[run] = {}\n                data[run][\"params\"] = deepcopy(params)\n                sweep_point_info = {\n                    \"labels\": [],\n                    \"values\": [],\n                    \"indices\": [],\n                }\n                for key, vals in sweep_params.items():\n                    data[run][\"params\"][key] = vals[j]\n                    sweep_point_info[\"labels\"].append(key)\n                    sweep_point_info[\"values\"].append(vals[j])\n                    sweep_point_info[\"indices\"].append(j)\n                data[run][\"results\"] = metrics_func(data[run][\"params\"], **fixed_kwargs)\n                data[run][\"sweep_point_info\"] = sweep_point_info\n                if data_save_mode == \"during\":\n                    jnp.savez(\n                        save_file, data=data, sweep_params=sweep_params, params=params\n                    )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(\n                    save_file,\n                    data=data,\n                    sweep_params=sweep_params,\n                    params=params,\n                    error=None,\n                )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n    else:\n        # Product Sweep\n        sweep_points = list(itertools.product(*list(sweep_params.values())))\n        sweep_points_indxs = list(\n            itertools.product(\n                *[list(range(len(vals))) for vals in list(sweep_params.values())]\n            )\n        )\n        sweep_point_labels = list(sweep_params.keys())\n\n        errors = []\n\n        try:\n            with tqdm(total=len(sweep_points)) as pbar:\n                for j, sweep_point in enumerate(sweep_points):\n                    run += 1\n                    data[run] = {}\n                    data[run][\"params\"] = deepcopy(params)\n                    sweep_point_info = {\n                        \"labels\": [],\n                        \"values\": [],\n                        \"indices\": [],\n                    }\n                    for i, key in enumerate(sweep_point_labels):\n                        data[run][\"params\"][key] = sweep_point[i]\n                        sweep_point_info[\"labels\"].append(key)\n                        sweep_point_info[\"values\"].append(sweep_point[i])\n                        sweep_point_info[\"indices\"].append(sweep_points_indxs[j][i])\n                    data[run][\"results\"] = metrics_func(\n                        data[run][\"params\"], **fixed_kwargs\n                    )\n                    data[run][\"sweep_point_info\"] = sweep_point_info\n                    pbar.update(1)\n                    if data_save_mode == \"during\":\n                        jnp.savez(\n                            save_file,\n                            data=data,\n                            sweep_params=sweep_params,\n                            params=params,\n                        )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during run: \", errors[-1])\n\n        try:\n            if data_save_mode in [\"during\", \"end\"]:\n                jnp.savez(\n                    save_file, data=data, sweep_params=sweep_params, params=params\n                )\n        except Exception as e:\n            errors.append(str(e))\n            print(\"Error during saving: \", errors[-1])\n\n        if return_errors:\n            return data, errors\n        else:\n            return data\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html","title":"base","text":"<p>Base.</p>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@struct.dataclass\nclass Device(ABC):\n    DEFAULT_BASIS = BasisTypes.fock\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    N: int = struct.field(pytree_node=False)\n    N_pre_diag: int = struct.field(pytree_node=False)\n    params: Dict[str, Any]\n    _label: int = struct.field(pytree_node=False)\n    _basis: BasisTypes = struct.field(pytree_node=False)\n    _hamiltonian: HamiltonianTypes = struct.field(pytree_node=False)\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        pass\n\n    @classmethod\n    def create(\n        cls,\n        N,\n        params,\n        label=0,\n        N_pre_diag=None,\n        use_linear=False,\n        hamiltonian: HamiltonianTypes = None,\n        basis: BasisTypes = None,\n    ):\n        \"\"\"Create a device.\n\n        Args:\n            N (int): dimension of Hilbert space.\n            params (dict): parameters of the device.\n            label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n            N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n            use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n            hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n            basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n        \"\"\"\n\n        if N_pre_diag is None:\n            N_pre_diag = N\n\n        assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n        _basis = basis if basis is not None else cls.DEFAULT_BASIS\n        _hamiltonian = (\n            hamiltonian if hamiltonian is not None else cls.DEFAULT_HAMILTONIAN\n        )\n\n        if use_linear:\n            _hamiltonian = HamiltonianTypes.linear\n\n        cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n        return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n\n    @property\n    def basis(self):\n        return self._basis\n\n    @property\n    def hamiltonian(self):\n        return self._hamiltonian\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def linear_ops(self):\n        return self.common_ops()\n\n    @property\n    def original_ops(self):\n        return self.common_ops()\n\n    @property\n    def ops(self):\n        return self.full_ops()\n\n    @abstractmethod\n    def common_ops(self) -&gt; Dict[str, Qarray]:\n        \"\"\"Set up common ops in the specified basis.\"\"\"\n\n    @abstractmethod\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n\n    @abstractmethod\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n\n    @abstractmethod\n    def get_H_full(self):\n        \"\"\"Return full H.\"\"\"\n\n    def get_H(self):\n        \"\"\"\n        Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n        \"\"\"\n        return self.get_op_in_H_eigenbasis(\n            self._get_H_in_original_basis()\n        ).keep_only_diag_elements()\n\n    def _get_H_in_original_basis(self):\n        \"\"\"This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n\n    def _calculate_eig_systems(self):\n        evs, evecs = jnp.linalg.eigh(self._get_H_in_original_basis().data)  # Hermitian\n        idxs_sorted = jnp.argsort(evs)\n        return evs[idxs_sorted], evecs[:, idxs_sorted]\n\n    @property\n    def eig_systems(self):\n        eig_systems = {}\n        eig_systems[\"vals\"], eig_systems[\"vecs\"] = self._calculate_eig_systems()\n\n        eig_systems[\"vecs\"] = eig_systems[\"vecs\"]\n        eig_systems[\"vals\"] = eig_systems[\"vals\"]\n        return eig_systems\n\n    def get_op_in_H_eigenbasis(self, op: Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        dims = [[self.N], [self.N]]\n        return get_op_in_new_basis(op, evecs, dims)\n\n    def get_op_data_in_H_eigenbasis(self, op: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_op_data_in_new_basis(op, evecs)\n\n    def get_vec_in_H_eigenbasis(self, vec: Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        if vec.qtype == Qtypes.ket:\n            dims = [[self.N], [1]]\n        else:\n            dims = [[1], [self.N]]\n        return get_vec_in_new_basis(vec, evecs, dims)\n\n    def get_vec_data_in_H_eigenbasis(self, vec: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_vec_data_in_new_basis(vec, evecs)\n\n    def full_ops(self):\n        # TODO: use JAX vmap here\n\n        linear_ops = self.linear_ops\n        ops = {}\n        for name, op in linear_ops.items():\n            ops[name] = self.get_op_in_H_eigenbasis(op)\n\n        return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Device.common_ops","title":"<code>common_ops()</code>  <code>abstractmethod</code>","text":"<p>Set up common ops in the specified basis.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef common_ops(self) -&gt; Dict[str, Qarray]:\n    \"\"\"Set up common ops in the specified basis.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Device.create","title":"<code>create(N, params, label=0, N_pre_diag=None, use_linear=False, hamiltonian=None, basis=None)</code>  <code>classmethod</code>","text":"<p>Create a device.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>dimension of Hilbert space.</p> required <code>params</code> <code>dict</code> <p>parameters of the device.</p> required <code>label</code> <code>int</code> <p>label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.</p> <code>0</code> <code>N_pre_diag</code> <code>int</code> <p>dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.</p> <code>None</code> <code>use_linear</code> <code>bool</code> <p>whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.</p> <code>False</code> <code>hamiltonian</code> <code>HamiltonianTypes</code> <p>type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.</p> <code>None</code> <code>basis</code> <code>BasisTypes</code> <p>type of basis. Defaults to None, in which case the fock basis is used.</p> <code>None</code> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    N,\n    params,\n    label=0,\n    N_pre_diag=None,\n    use_linear=False,\n    hamiltonian: HamiltonianTypes = None,\n    basis: BasisTypes = None,\n):\n    \"\"\"Create a device.\n\n    Args:\n        N (int): dimension of Hilbert space.\n        params (dict): parameters of the device.\n        label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n        N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n        use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n        hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n        basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n    \"\"\"\n\n    if N_pre_diag is None:\n        N_pre_diag = N\n\n    assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n    _basis = basis if basis is not None else cls.DEFAULT_BASIS\n    _hamiltonian = (\n        hamiltonian if hamiltonian is not None else cls.DEFAULT_HAMILTONIAN\n    )\n\n    if use_linear:\n        _hamiltonian = HamiltonianTypes.linear\n\n    cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n    return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Device.get_H","title":"<code>get_H()</code>","text":"<p>Return diagonalized H. Explicitly keep only diagonal elements of matrix.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n    \"\"\"\n    return self.get_op_in_H_eigenbasis(\n        self._get_H_in_original_basis()\n    ).keep_only_diag_elements()\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Device.get_H_full","title":"<code>get_H_full()</code>  <code>abstractmethod</code>","text":"<p>Return full H.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_H_full(self):\n    \"\"\"Return full H.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Device.get_H_linear","title":"<code>get_H_linear()</code>  <code>abstractmethod</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Device.get_linear_frequency","title":"<code>get_linear_frequency()</code>  <code>abstractmethod</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Device.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Drive","title":"<code>Drive</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>jaxquantum/devices/superconducting/drive.py</code> <pre><code>@struct.dataclass\nclass Drive(ABC):\n    N: int = struct.field(pytree_node=False)\n    fd: float\n    _label: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(cls, M_max, fd, label=0):\n        cls.M_max = M_max\n        N = 2 * M_max + 1\n        return cls(N, fd, label)\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def ops(self):\n        return self.common_ops()\n\n    def common_ops(self) -&gt; Dict[str, Qarray]:\n        ops = {}\n\n        M_max = self.M_max\n\n        # Construct M = \u2211\u2098 m|m&gt;&lt;m| operator in drive charge basis\n        ops[\"M\"] = jnp2jqt(jnp.diag(jnp.arange(-M_max, M_max + 1)))\n\n        # Construct Id = \u2211\u2098|m&gt;&lt;m| in the drive charge basis\n        ops[\"id\"] = jnp2jqt(jnp.identity(2 * M_max + 1))\n\n        # Construct M\u208a \u2261 exp(i\u03b8) and M\u208b \u2261 exp(-i\u03b8) operators for drive\n        ops[\"M-\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=1))\n        ops[\"M+\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=-1))\n\n        # Construct cos(\u03b8) \u2261 1/2 * [M\u208a + M\u208b] = 1/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"cos(\u03b8)\"] = 0.5 * (ops[\"M+\"] + ops[\"M-\"])\n\n        # Construct sin(\u03b8) \u2261 -i/2 * [M\u208a - M\u208b] = -i/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"sin(\u03b8)\"] = -0.5j * (ops[\"M+\"] - ops[\"M-\"])\n\n        # Construct more general drive operators cos(k\u03b8) and sin(k\u03b8)\n        for k in range(2, M_max + 1):\n            ops[f\"M_+{k}\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=-k))\n            ops[f\"M_-{k}\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=k))\n            ops[f\"cos({k}\u03b8)\"] = 0.5 * (ops[f\"M_+{k}\"] + ops[f\"M_-{k}\"])\n            ops[f\"sin({k}\u03b8)\"] = -0.5j * (ops[f\"M_+{k}\"] - ops[f\"M_-{k}\"])\n\n        return ops\n\n    #############################################################\n\n    def get_H(self):\n        \"\"\"\n        Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.\n        \"\"\"\n        return self.fd * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Drive.get_H","title":"<code>get_H()</code>","text":"<p>Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.</p> Source code in <code>jaxquantum/devices/superconducting/drive.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.\n    \"\"\"\n    return self.fd * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray","title":"<code>Qarray</code>","text":"Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@struct.dataclass  # this allows us to send in and return Qarray from jitted functions\nclass Qarray:\n    _data: Array\n    _qdims: Qdims = struct.field(pytree_node=False)\n    _bdims: tuple[int] = struct.field(pytree_node=False)\n\n    # Initialization ----\n    @classmethod\n    def create(cls, data, dims=None, bdims=None):\n        # Step 1: Prepare data ----\n        data = jnp.asarray(data)\n\n        if len(data.shape) == 1 and data.shape[0] &gt; 0:\n            data = data.reshape(data.shape[0], 1)\n\n        if len(data.shape) &gt;= 2:\n            if data.shape[-2] != data.shape[-1] and not (\n                data.shape[-2] == 1 or data.shape[-1] == 1\n            ):\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n\n        if bdims is not None:\n            if len(data.shape) - len(bdims) == 1:\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n        # ----\n\n        # Step 2: Prepare dimensions ----\n        if bdims is None:\n            bdims = tuple(data.shape[:-2])\n\n        if dims is None:\n            dims = ((data.shape[-2],), (data.shape[-1],))\n\n        if not isinstance(dims[0], (list, tuple)):\n            # This handles the case where only the hilbert space dimensions are sent in.\n            if data.shape[-1] == 1:\n                dims = (tuple(dims), tuple([1 for _ in dims]))\n            elif data.shape[-2] == 1:\n                dims = (tuple([1 for _ in dims]), tuple(dims))\n            else:\n                dims = (tuple(dims), tuple(dims))\n        else:\n            dims = (tuple(dims[0]), tuple(dims[1]))\n\n        check_dims(dims, bdims, data.shape)\n\n        qdims = Qdims(dims)\n\n        # NOTE: Constantly tidying up on Qarray creation might be a bit overkill.\n        # It increases the compilation time, but only very slightly\n        # increased the runtime of the jit compiled function.\n        # We could instead use this tidy_up where we think we need it.\n        data = tidy_up(data, SETTINGS[\"auto_tidyup_atol\"])\n\n        return cls(data, qdims, bdims)\n\n    # ----\n\n    @classmethod\n    def from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n        \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n        data = jnp.array([qarr.data for qarr in qarr_list])\n\n        if len(qarr_list) == 0:\n            dims = ((), ())\n            bdims = ()\n        else:\n            dims = qarr_list[0].dims\n            bdims = qarr_list[0].bdims\n\n        if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n            raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n        bdims = (len(qarr_list),) + bdims\n\n        return cls.create(data, dims=dims, bdims=bdims)\n\n    @classmethod\n    def from_array(cls, qarr_arr) -&gt; Qarray:\n        \"\"\"Create a Qarray from a nested list of Qarrays.\n\n        Args:\n            qarr_arr (list): nested list of Qarrays\n\n        Returns:\n            Qarray: Qarray object\n        \"\"\"\n        if isinstance(qarr_arr, Qarray):\n            return qarr_arr\n\n        bdims = ()\n        lvl = qarr_arr\n        while not isinstance(lvl, Qarray):\n            bdims = bdims + (len(lvl),)\n            if len(lvl) &gt; 0:\n                lvl = lvl[0]\n            else:\n                break\n\n        def flat(lis):\n            flatList = []\n            for element in lis:\n                if type(element) is list:\n                    flatList += flat(element)\n                else:\n                    flatList.append(element)\n            return flatList\n\n        qarr_list = flat(qarr_arr)\n        qarr = cls.from_list(qarr_list)\n        qarr = qarr.reshape_bdims(*bdims)\n        return qarr\n\n    # Properties ----\n    @property\n    def qtype(self):\n        return self._qdims.qtype\n\n    @property\n    def dtype(self):\n        return self._data.dtype\n\n    @property\n    def dims(self):\n        return self._qdims.dims\n\n    @property\n    def bdims(self):\n        return self._bdims\n\n    @property\n    def qdims(self):\n        return self._qdims\n\n    @property\n    def space_dims(self):\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return self.dims[0]\n        elif self.qtype == Qtypes.bra:\n            return self.dims[1]\n        else:\n            # TODO: not reached for some reason\n            raise ValueError(\"Unsupported qtype.\")\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def shaped_data(self):\n        return self._data.reshape(self.bdims + self.dims[0] + self.dims[1])\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def is_batched(self):\n        return len(self.bdims) &gt; 0\n\n    def __getitem__(self, index):\n        if len(self.bdims) &gt; 0:\n            return Qarray.create(\n                self.data[index],\n                dims=self.dims,\n            )\n        else:\n            raise ValueError(\"Cannot index a non-batched Qarray.\")\n\n    def reshape_bdims(self, *args):\n        \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n        new_bdims = tuple(args)\n\n        if prod(new_bdims) == 0:\n            new_shape = new_bdims\n        else:\n            new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n        return Qarray.create(\n            self.data.reshape(new_shape),\n            dims=self.dims,\n            bdims=new_bdims,\n        )\n\n    def space_to_qdims(self, space_dims: List[int]):\n        if isinstance(space_dims[0], (list, tuple)):\n            return space_dims\n\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return (tuple(space_dims), tuple([1 for _ in range(len(space_dims))]))\n        elif self.qtype == Qtypes.bra:\n            return (tuple([1 for _ in range(len(space_dims))]), tuple(space_dims))\n        else:\n            raise ValueError(\"Unsupported qtype for space_to_qdims conversion.\")\n\n    def reshape_qdims(self, *args):\n        \"\"\"Reshape the quantum dimensions of the Qarray.\n\n        Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n        Args:\n            *args: new Hilbert dimensions for the Qarray.\n\n        Returns:\n            Qarray: reshaped Qarray.\n        \"\"\"\n\n        new_space_dims = tuple(args)\n        current_space_dims = self.space_dims\n        assert prod(new_space_dims) == prod(current_space_dims)\n\n        new_qdims = self.space_to_qdims(new_space_dims)\n        new_bdims = self.bdims\n\n        return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n\n    def resize(self, new_shape):\n        \"\"\"Resize the Qarray to a new shape.\n\n        TODO: review and maybe deprecate this method.\n        \"\"\"\n        dims = self.dims\n        data = jnp.resize(self.data, new_shape)\n        return Qarray.create(\n            data,\n            dims=dims,\n        )\n\n    def __len__(self):\n        \"\"\"Length of the Qarray.\"\"\"\n        if len(self.bdims) &gt; 0:\n            return self.data.shape[0]\n        else:\n            raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Qarray):\n            raise ValueError(\"Cannot calculate equality of a Qarray with a non-Qarray.\")\n\n        if self.dims != other.dims:\n            return False\n\n        if self.bdims != other.bdims:\n            return False\n\n        return jnp.all(self.data == other.data)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # ----\n\n    # Elementary Math ----\n    def __matmul__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        _qdims_new = self._qdims @ other._qdims\n        return Qarray.create(\n            self.data @ other.data,\n            dims=_qdims_new.dims,\n        )\n\n    # NOTE: not possible to reach this.\n    # def __rmatmul__(self, other):\n    #     if not isinstance(other, Qarray):\n    #         return NotImplemented\n\n    #     _qdims_new = other._qdims @ self._qdims\n    #     return Qarray.create(\n    #         other.data @ self.data,\n    #         dims=_qdims_new.dims,\n    #     )\n\n    def __mul__(self, other):\n        if isinstance(other, Qarray):\n            return self.__matmul__(other)\n\n        other = other + 0.0j\n        if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n            other = other.reshape(other.shape + (1, 1))\n\n        return Qarray.create(\n            other * self.data,\n            dims=self._qdims.dims,\n        )\n\n    def __rmul__(self, other):\n        # NOTE: not possible to reach this.\n        # if isinstance(other, Qarray):\n        #     return self.__rmatmul__(other)\n\n        return self.__mul__(other)\n\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    def __truediv__(self, other):\n        \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n        if isinstance(other, Qarray):\n            raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n        return self.__mul__(1 / other)\n\n    def __add__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data + other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__add__(other)\n\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data - other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__sub__(other)\n\n        return NotImplemented\n\n    def __rsub__(self, other):\n        return self.__neg__().__add__(other)\n\n    def __xor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(self, other)\n\n    def __rxor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(other, self)\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n\n        return powm(self, other)\n\n    # ----\n\n    # String Representation ----\n    def _str_header(self):\n        out = \", \".join(\n            [\n                \"Quantum array: dims = \" + str(self.dims),\n                \"bdims = \" + str(self.bdims),\n                \"shape = \" + str(self._data.shape),\n                \"type = \" + str(self.qtype),\n            ]\n        )\n        return out\n\n    def __str__(self):\n        return self._str_header() + \"\\nQarray data =\\n\" + str(self.data)\n\n    @property\n    def header(self):\n        \"\"\"Print the header of the Qarray.\"\"\"\n        return self._str_header()\n\n    def __repr__(self):\n        return self.__str__()\n\n    # ----\n\n    # Utilities ----\n    def copy(self, memo=None):\n        # return Qarray.create(deepcopy(self.data), dims=self.dims)\n        return self.__deepcopy__(memo)\n\n    def __deepcopy__(self, memo):\n        \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n        return Qarray(\n            _data=deepcopy(self._data, memo=memo),\n            _qdims=deepcopy(self._qdims, memo=memo),\n            _bdims=deepcopy(self._bdims, memo=memo),\n        )\n\n    def __getattr__(self, method_name):\n        if \"__\" == method_name[:2]:\n            # NOTE: we return NotImplemented for binary special methods logic in python, plus things like __jax_array__\n            return lambda *args, **kwargs: NotImplemented\n\n        modules = [jnp, jnp.linalg, jsp, jsp.linalg]\n\n        method_f = None\n        for mod in modules:\n            method_f = getattr(mod, method_name, None)\n            if method_f is not None:\n                break\n\n        if method_f is None:\n            raise NotImplementedError(\n                f\"Method {method_name} does not exist. No backup method found in {modules}.\"\n            )\n\n        def func(*args, **kwargs):\n            res = method_f(self.data, *args, **kwargs)\n\n            if getattr(res, \"shape\", None) is None or res.shape != self.data.shape:\n                return res\n            else:\n                return Qarray.create(res, dims=self._qdims.dims)\n\n        return func\n\n    # ----\n\n    # Conversions / Reshaping ----\n    def dag(self):\n        return dag(self)\n\n    def to_dm(self):\n        return ket2dm(self)\n\n    def is_dm(self):\n        return self.qtype == Qtypes.oper\n\n    def is_vec(self):\n        return self.qtype == Qtypes.ket or self.qtype == Qtypes.bra\n\n    def to_ket(self):\n        return to_ket(self)\n\n    def transpose(self, *args):\n        return transpose(self, *args)\n\n    def keep_only_diag_elements(self):\n        return keep_only_diag_elements(self)\n\n    # ----\n\n    # Math Functions ----\n    def unit(self):\n        return unit(self)\n\n    def norm(self):\n        return norm(self)\n\n    def expm(self):\n        return expm(self)\n\n    def powm(self, n):\n        return powm(self, n)\n\n    def cosm(self):\n        return cosm(self)\n\n    def sinm(self):\n        return sinm(self)\n\n    def tr(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def trace(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def ptrace(self, indx):\n        return ptrace(self, indx)\n\n    def eigenstates(self):\n        return eigenstates(self)\n\n    def eigenenergies(self):\n        return eigenenergies(self)\n\n    def collapse(self, mode=\"sum\"):\n        return collapse(self, mode=mode)\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.header","title":"<code>header</code>  <code>property</code>","text":"<p>Print the header of the Qarray.</p>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Need to override this when defininig getattr.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n    return Qarray(\n        _data=deepcopy(self._data, memo=memo),\n        _qdims=deepcopy(self._qdims, memo=memo),\n        _bdims=deepcopy(self._bdims, memo=memo),\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.__len__","title":"<code>__len__()</code>","text":"<p>Length of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __len__(self):\n    \"\"\"Length of the Qarray.\"\"\"\n    if len(self.bdims) &gt; 0:\n        return self.data.shape[0]\n    else:\n        raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>For Qarray's, this only really makes sense in the context of division by a scalar.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n    if isinstance(other, Qarray):\n        raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n    return self.__mul__(1 / other)\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.from_array","title":"<code>from_array(qarr_arr)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a nested list of Qarrays.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_arr</code> <code>list</code> <p>nested list of Qarrays</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Qarray object</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_array(cls, qarr_arr) -&gt; Qarray:\n    \"\"\"Create a Qarray from a nested list of Qarrays.\n\n    Args:\n        qarr_arr (list): nested list of Qarrays\n\n    Returns:\n        Qarray: Qarray object\n    \"\"\"\n    if isinstance(qarr_arr, Qarray):\n        return qarr_arr\n\n    bdims = ()\n    lvl = qarr_arr\n    while not isinstance(lvl, Qarray):\n        bdims = bdims + (len(lvl),)\n        if len(lvl) &gt; 0:\n            lvl = lvl[0]\n        else:\n            break\n\n    def flat(lis):\n        flatList = []\n        for element in lis:\n            if type(element) is list:\n                flatList += flat(element)\n            else:\n                flatList.append(element)\n        return flatList\n\n    qarr_list = flat(qarr_arr)\n    qarr = cls.from_list(qarr_list)\n    qarr = qarr.reshape_bdims(*bdims)\n    return qarr\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.from_list","title":"<code>from_list(qarr_list)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a list of Qarrays.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n    \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n    data = jnp.array([qarr.data for qarr in qarr_list])\n\n    if len(qarr_list) == 0:\n        dims = ((), ())\n        bdims = ()\n    else:\n        dims = qarr_list[0].dims\n        bdims = qarr_list[0].bdims\n\n    if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n        raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n    bdims = (len(qarr_list),) + bdims\n\n    return cls.create(data, dims=dims, bdims=bdims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.reshape_bdims","title":"<code>reshape_bdims(*args)</code>","text":"<p>Reshape the batch dimensions of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_bdims(self, *args):\n    \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n    new_bdims = tuple(args)\n\n    if prod(new_bdims) == 0:\n        new_shape = new_bdims\n    else:\n        new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n    return Qarray.create(\n        self.data.reshape(new_shape),\n        dims=self.dims,\n        bdims=new_bdims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.reshape_qdims","title":"<code>reshape_qdims(*args)</code>","text":"<p>Reshape the quantum dimensions of the Qarray.</p> <p>Note that this does not take in qdims but rather the new Hilbert space dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>new Hilbert dimensions for the Qarray.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>reshaped Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_qdims(self, *args):\n    \"\"\"Reshape the quantum dimensions of the Qarray.\n\n    Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n    Args:\n        *args: new Hilbert dimensions for the Qarray.\n\n    Returns:\n        Qarray: reshaped Qarray.\n    \"\"\"\n\n    new_space_dims = tuple(args)\n    current_space_dims = self.space_dims\n    assert prod(new_space_dims) == prod(current_space_dims)\n\n    new_qdims = self.space_to_qdims(new_space_dims)\n    new_bdims = self.bdims\n\n    return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.Qarray.resize","title":"<code>resize(new_shape)</code>","text":"<p>Resize the Qarray to a new shape.</p> <p>TODO: review and maybe deprecate this method.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def resize(self, new_shape):\n    \"\"\"Resize the Qarray to a new shape.\n\n    TODO: review and maybe deprecate this method.\n    \"\"\"\n    dims = self.dims\n    data = jnp.resize(self.data, new_shape)\n    return Qarray.create(\n        data,\n        dims=dims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/index.html#jaxquantum.devices.base.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <code>parallel</code> <code>bool</code> <p>if True, use parallel einsum for tensor product true: [A,B] ^ [C,D] = [A^C, B^D] false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n        parallel (bool): if True, use parallel einsum for tensor product\n            true: [A,B] ^ [C,D] = [A^C, B^D]\n            false (default): [A,B] ^ [C,D] = [A^C, A^D, B^C, B^D]\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n\n    parallel = kwargs.pop(\"parallel\", False)\n\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    dims_0 = dims[0]\n    dims_1 = dims[1]\n    for arg in args[1:]:\n        if parallel:\n            a = data\n            b = arg.data\n\n            if len(a.shape) &gt; len(b.shape):\n                batch_dim = a.shape[:-2]\n            elif len(a.shape) == len(b.shape):\n                if prod(a.shape[:-2]) &gt; prod(b.shape[:-2]):\n                    batch_dim = a.shape[:-2]\n                else:\n                    batch_dim = b.shape[:-2]\n            else:\n                batch_dim = b.shape[:-2]\n\n            data = jnp.einsum(\"...ij,...kl-&gt;...ikjl\", a, b).reshape(\n                *batch_dim, a.shape[-2] * b.shape[-2], -1\n            )\n        else:\n            data = jnp.kron(data, arg.data, **kwargs)\n\n        dims_0 = dims_0 + arg.dims[0]\n        dims_1 = dims_1 + arg.dims[1]\n\n    return Qarray.create(data, dims=(dims_0, dims_1))\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/base.html","title":"base","text":"<p>Base device.</p>"},{"location":"reference/jaxquantum/devices/base/base.html#jaxquantum.devices.base.base.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@struct.dataclass\nclass Device(ABC):\n    DEFAULT_BASIS = BasisTypes.fock\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    N: int = struct.field(pytree_node=False)\n    N_pre_diag: int = struct.field(pytree_node=False)\n    params: Dict[str, Any]\n    _label: int = struct.field(pytree_node=False)\n    _basis: BasisTypes = struct.field(pytree_node=False)\n    _hamiltonian: HamiltonianTypes = struct.field(pytree_node=False)\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        pass\n\n    @classmethod\n    def create(\n        cls,\n        N,\n        params,\n        label=0,\n        N_pre_diag=None,\n        use_linear=False,\n        hamiltonian: HamiltonianTypes = None,\n        basis: BasisTypes = None,\n    ):\n        \"\"\"Create a device.\n\n        Args:\n            N (int): dimension of Hilbert space.\n            params (dict): parameters of the device.\n            label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n            N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n            use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n            hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n            basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n        \"\"\"\n\n        if N_pre_diag is None:\n            N_pre_diag = N\n\n        assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n        _basis = basis if basis is not None else cls.DEFAULT_BASIS\n        _hamiltonian = (\n            hamiltonian if hamiltonian is not None else cls.DEFAULT_HAMILTONIAN\n        )\n\n        if use_linear:\n            _hamiltonian = HamiltonianTypes.linear\n\n        cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n        return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n\n    @property\n    def basis(self):\n        return self._basis\n\n    @property\n    def hamiltonian(self):\n        return self._hamiltonian\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def linear_ops(self):\n        return self.common_ops()\n\n    @property\n    def original_ops(self):\n        return self.common_ops()\n\n    @property\n    def ops(self):\n        return self.full_ops()\n\n    @abstractmethod\n    def common_ops(self) -&gt; Dict[str, Qarray]:\n        \"\"\"Set up common ops in the specified basis.\"\"\"\n\n    @abstractmethod\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n\n    @abstractmethod\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n\n    @abstractmethod\n    def get_H_full(self):\n        \"\"\"Return full H.\"\"\"\n\n    def get_H(self):\n        \"\"\"\n        Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n        \"\"\"\n        return self.get_op_in_H_eigenbasis(\n            self._get_H_in_original_basis()\n        ).keep_only_diag_elements()\n\n    def _get_H_in_original_basis(self):\n        \"\"\"This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n\n    def _calculate_eig_systems(self):\n        evs, evecs = jnp.linalg.eigh(self._get_H_in_original_basis().data)  # Hermitian\n        idxs_sorted = jnp.argsort(evs)\n        return evs[idxs_sorted], evecs[:, idxs_sorted]\n\n    @property\n    def eig_systems(self):\n        eig_systems = {}\n        eig_systems[\"vals\"], eig_systems[\"vecs\"] = self._calculate_eig_systems()\n\n        eig_systems[\"vecs\"] = eig_systems[\"vecs\"]\n        eig_systems[\"vals\"] = eig_systems[\"vals\"]\n        return eig_systems\n\n    def get_op_in_H_eigenbasis(self, op: Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        dims = [[self.N], [self.N]]\n        return get_op_in_new_basis(op, evecs, dims)\n\n    def get_op_data_in_H_eigenbasis(self, op: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_op_data_in_new_basis(op, evecs)\n\n    def get_vec_in_H_eigenbasis(self, vec: Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        if vec.qtype == Qtypes.ket:\n            dims = [[self.N], [1]]\n        else:\n            dims = [[1], [self.N]]\n        return get_vec_in_new_basis(vec, evecs, dims)\n\n    def get_vec_data_in_H_eigenbasis(self, vec: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_vec_data_in_new_basis(vec, evecs)\n\n    def full_ops(self):\n        # TODO: use JAX vmap here\n\n        linear_ops = self.linear_ops\n        ops = {}\n        for name, op in linear_ops.items():\n            ops[name] = self.get_op_in_H_eigenbasis(op)\n\n        return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/base.html#jaxquantum.devices.base.base.Device.common_ops","title":"<code>common_ops()</code>  <code>abstractmethod</code>","text":"<p>Set up common ops in the specified basis.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef common_ops(self) -&gt; Dict[str, Qarray]:\n    \"\"\"Set up common ops in the specified basis.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/base.html#jaxquantum.devices.base.base.Device.create","title":"<code>create(N, params, label=0, N_pre_diag=None, use_linear=False, hamiltonian=None, basis=None)</code>  <code>classmethod</code>","text":"<p>Create a device.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>dimension of Hilbert space.</p> required <code>params</code> <code>dict</code> <p>parameters of the device.</p> required <code>label</code> <code>int</code> <p>label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.</p> <code>0</code> <code>N_pre_diag</code> <code>int</code> <p>dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.</p> <code>None</code> <code>use_linear</code> <code>bool</code> <p>whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.</p> <code>False</code> <code>hamiltonian</code> <code>HamiltonianTypes</code> <p>type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.</p> <code>None</code> <code>basis</code> <code>BasisTypes</code> <p>type of basis. Defaults to None, in which case the fock basis is used.</p> <code>None</code> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    N,\n    params,\n    label=0,\n    N_pre_diag=None,\n    use_linear=False,\n    hamiltonian: HamiltonianTypes = None,\n    basis: BasisTypes = None,\n):\n    \"\"\"Create a device.\n\n    Args:\n        N (int): dimension of Hilbert space.\n        params (dict): parameters of the device.\n        label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n        N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n        use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n        hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n        basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n    \"\"\"\n\n    if N_pre_diag is None:\n        N_pre_diag = N\n\n    assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n    _basis = basis if basis is not None else cls.DEFAULT_BASIS\n    _hamiltonian = (\n        hamiltonian if hamiltonian is not None else cls.DEFAULT_HAMILTONIAN\n    )\n\n    if use_linear:\n        _hamiltonian = HamiltonianTypes.linear\n\n    cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n    return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/base.html#jaxquantum.devices.base.base.Device.get_H","title":"<code>get_H()</code>","text":"<p>Return diagonalized H. Explicitly keep only diagonal elements of matrix.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n    \"\"\"\n    return self.get_op_in_H_eigenbasis(\n        self._get_H_in_original_basis()\n    ).keep_only_diag_elements()\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/base.html#jaxquantum.devices.base.base.Device.get_H_full","title":"<code>get_H_full()</code>  <code>abstractmethod</code>","text":"<p>Return full H.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_H_full(self):\n    \"\"\"Return full H.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/base.html#jaxquantum.devices.base.base.Device.get_H_linear","title":"<code>get_H_linear()</code>  <code>abstractmethod</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/base.html#jaxquantum.devices.base.base.Device.get_linear_frequency","title":"<code>get_linear_frequency()</code>  <code>abstractmethod</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/base.html#jaxquantum.devices.base.base.Device.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/jaxquantum/devices/base/system.html","title":"system","text":"<p>System.</p>"},{"location":"reference/jaxquantum/devices/common/index.html","title":"common","text":"<p>Common module.</p>"},{"location":"reference/jaxquantum/devices/common/index.html#jaxquantum.devices.common.harm_osc_wavefunction","title":"<code>harm_osc_wavefunction(n, x, l_osc)</code>","text":"<p>Taken from scqubits... not jit-able</p> <p>For given quantum number n=0,1,2,... return the value of the harmonic oscillator wave function :math:<code>\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{ osc})</code>, N being the proper normalization factor.</p> <p>Directly uses <code>scipy.special.pbdv</code> (implementation of the parabolic cylinder function) to mitigate numerical stability issues with the more commonly used expression in terms of a Gaussian and a Hermite polynomial factor.</p>"},{"location":"reference/jaxquantum/devices/common/index.html#jaxquantum.devices.common.harm_osc_wavefunction--parameters","title":"Parameters","text":"<p>n:     index of wave function, n=0 is ground state x:     coordinate(s) where wave function is evaluated l_osc:     oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2</p>"},{"location":"reference/jaxquantum/devices/common/index.html#jaxquantum.devices.common.harm_osc_wavefunction--returns","title":"Returns","text":"<pre><code>value of harmonic oscillator wave function\n</code></pre> Source code in <code>jaxquantum/devices/common/utils.py</code> <pre><code>def harm_osc_wavefunction(n, x, l_osc):\n    r\"\"\"\n    Taken from scqubits... not jit-able\n\n    For given quantum number n=0,1,2,... return the value of the harmonic\n    oscillator wave function :math:`\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{\n    osc})`, N being the proper normalization factor.\n\n    Directly uses `scipy.special.pbdv` (implementation of the parabolic cylinder\n    function) to mitigate numerical stability issues with the more commonly used\n    expression in terms of a Gaussian and a Hermite polynomial factor.\n\n    Parameters\n    ----------\n    n:\n        index of wave function, n=0 is ground state\n    x:\n        coordinate(s) where wave function is evaluated\n    l_osc:\n        oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2\n\n    Returns\n    -------\n        value of harmonic oscillator wave function\n    \"\"\"\n    x = 2 * jnp.pi * x\n    result = pbdv(n, jnp.sqrt(2.0) * x / l_osc)[0]\n    result = result / jnp.sqrt(l_osc * jnp.sqrt(jnp.pi) * factorial_approx(n))\n    return result\n</code></pre>"},{"location":"reference/jaxquantum/devices/common/utils.html","title":"utils","text":"<p>Utility functions</p>"},{"location":"reference/jaxquantum/devices/common/utils.html#jaxquantum.devices.common.utils.harm_osc_wavefunction","title":"<code>harm_osc_wavefunction(n, x, l_osc)</code>","text":"<p>Taken from scqubits... not jit-able</p> <p>For given quantum number n=0,1,2,... return the value of the harmonic oscillator wave function :math:<code>\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{ osc})</code>, N being the proper normalization factor.</p> <p>Directly uses <code>scipy.special.pbdv</code> (implementation of the parabolic cylinder function) to mitigate numerical stability issues with the more commonly used expression in terms of a Gaussian and a Hermite polynomial factor.</p>"},{"location":"reference/jaxquantum/devices/common/utils.html#jaxquantum.devices.common.utils.harm_osc_wavefunction--parameters","title":"Parameters","text":"<p>n:     index of wave function, n=0 is ground state x:     coordinate(s) where wave function is evaluated l_osc:     oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2</p>"},{"location":"reference/jaxquantum/devices/common/utils.html#jaxquantum.devices.common.utils.harm_osc_wavefunction--returns","title":"Returns","text":"<pre><code>value of harmonic oscillator wave function\n</code></pre> Source code in <code>jaxquantum/devices/common/utils.py</code> <pre><code>def harm_osc_wavefunction(n, x, l_osc):\n    r\"\"\"\n    Taken from scqubits... not jit-able\n\n    For given quantum number n=0,1,2,... return the value of the harmonic\n    oscillator wave function :math:`\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{\n    osc})`, N being the proper normalization factor.\n\n    Directly uses `scipy.special.pbdv` (implementation of the parabolic cylinder\n    function) to mitigate numerical stability issues with the more commonly used\n    expression in terms of a Gaussian and a Hermite polynomial factor.\n\n    Parameters\n    ----------\n    n:\n        index of wave function, n=0 is ground state\n    x:\n        coordinate(s) where wave function is evaluated\n    l_osc:\n        oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2\n\n    Returns\n    -------\n        value of harmonic oscillator wave function\n    \"\"\"\n    x = 2 * jnp.pi * x\n    result = pbdv(n, jnp.sqrt(2.0) * x / l_osc)[0]\n    result = result / jnp.sqrt(l_osc * jnp.sqrt(jnp.pi) * factorial_approx(n))\n    return result\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html","title":"superconducting","text":"<p>Devices.</p>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS","title":"<code>ATS</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>ATS Device.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>@struct.dataclass\nclass ATS(FluxDevice):\n    \"\"\"\n    ATS Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.params[\"El\"] / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    @staticmethod\n    def get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta):\n        cos_phi_op = cosm(phi_op)\n        sin_phi_op = sinm(phi_op)\n\n        cos_2phi_op = cos_phi_op @ cos_phi_op - sin_phi_op @ sin_phi_op\n        sin_2phi_op = 2 * cos_phi_op @ sin_phi_op\n\n        H_nl_Ej = (\n            -2\n            * Ej\n            * (\n                cos_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n                - sin_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n            )\n            * jnp.cos(2 * jnp.pi * phi_sum)\n        )\n        H_nl_dEj = (\n            2\n            * dEj\n            * (\n                sin_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n                + cos_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n            )\n            * jnp.sin(2 * jnp.pi * phi_sum)\n        )\n        H_nl_Ej2 = (\n            2\n            * Ej2\n            * (\n                cos_2phi_op * jnp.cos(2 * 2 * jnp.pi * phi_delta)\n                - sin_2phi_op * jnp.sin(2 * 2 * jnp.pi * phi_delta)\n            )\n            * jnp.cos(2 * 2 * jnp.pi * phi_sum)\n        )\n\n        H_nl = H_nl_Ej + H_nl_dEj + H_nl_Ej2\n\n        # id_op = jqt.identity_like(phi_op)\n        # phi_delta_ext_op = self.params[\"phi_delta_ext\"] * id_op\n        # H_nl_old = - 2 * Ej * jqt.cosm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * dEj * jqt.sinm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.sin(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * Ej2 * jqt.cosm(2*phi_op + 2 * 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * 2 * jnp.pi * self.params[\"phi_sum_ext\"])\n\n        return H_nl\n\n    def get_H_nonlinear(self, phi_op):\n        \"\"\"Return nonlinear terms in H.\"\"\"\n\n        Ej = self.params[\"Ej\"]\n        dEj = self.params[\"dEj\"]\n        Ej2 = self.params[\"Ej2\"]\n\n        phi_sum = self.params[\"phi_sum_ext\"]\n        phi_delta = self.params[\"phi_delta_ext\"]\n\n        return ATS.get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        phi_b = self.linear_ops[\"phi\"]\n        H_nl = self.get_H_nonlinear(phi_b)\n        H = self.get_H_linear() + H_nl\n        return H\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n\n        phi_delta_ext = self.params[\"phi_delta_ext\"]\n        phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n        V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n        V += (\n            -2\n            * self.params[\"Ej\"]\n            * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.cos(2 * jnp.pi * phi_sum_ext)\n        )\n        V += (\n            2\n            * self.params[\"dEj\"]\n            * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.sin(2 * jnp.pi * phi_sum_ext)\n        )\n        V += (\n            2\n            * self.params[\"Ej2\"]\n            * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n        )\n\n        return V\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    phi_b = self.linear_ops[\"phi\"]\n    H_nl = self.get_H_nonlinear(phi_b)\n    H = self.get_H_linear() + H_nl\n    return H\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS.get_H_nonlinear","title":"<code>get_H_nonlinear(phi_op)</code>","text":"<p>Return nonlinear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_nonlinear(self, phi_op):\n    \"\"\"Return nonlinear terms in H.\"\"\"\n\n    Ej = self.params[\"Ej\"]\n    dEj = self.params[\"dEj\"]\n    Ej2 = self.params[\"Ej2\"]\n\n    phi_sum = self.params[\"phi_sum_ext\"]\n    phi_delta = self.params[\"phi_delta_ext\"]\n\n    return ATS.get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.params[\"El\"] / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.ATS.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n\n    phi_delta_ext = self.params[\"phi_delta_ext\"]\n    phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n    V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n    V += (\n        -2\n        * self.params[\"Ej\"]\n        * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.cos(2 * jnp.pi * phi_sum_ext)\n    )\n    V += (\n        2\n        * self.params[\"dEj\"]\n        * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.sin(2 * jnp.pi * phi_sum_ext)\n    )\n    V += (\n        2\n        * self.params[\"Ej2\"]\n        * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n    )\n\n    return V\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@struct.dataclass\nclass Device(ABC):\n    DEFAULT_BASIS = BasisTypes.fock\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    N: int = struct.field(pytree_node=False)\n    N_pre_diag: int = struct.field(pytree_node=False)\n    params: Dict[str, Any]\n    _label: int = struct.field(pytree_node=False)\n    _basis: BasisTypes = struct.field(pytree_node=False)\n    _hamiltonian: HamiltonianTypes = struct.field(pytree_node=False)\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        pass\n\n    @classmethod\n    def create(\n        cls,\n        N,\n        params,\n        label=0,\n        N_pre_diag=None,\n        use_linear=False,\n        hamiltonian: HamiltonianTypes = None,\n        basis: BasisTypes = None,\n    ):\n        \"\"\"Create a device.\n\n        Args:\n            N (int): dimension of Hilbert space.\n            params (dict): parameters of the device.\n            label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n            N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n            use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n            hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n            basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n        \"\"\"\n\n        if N_pre_diag is None:\n            N_pre_diag = N\n\n        assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n        _basis = basis if basis is not None else cls.DEFAULT_BASIS\n        _hamiltonian = (\n            hamiltonian if hamiltonian is not None else cls.DEFAULT_HAMILTONIAN\n        )\n\n        if use_linear:\n            _hamiltonian = HamiltonianTypes.linear\n\n        cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n        return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n\n    @property\n    def basis(self):\n        return self._basis\n\n    @property\n    def hamiltonian(self):\n        return self._hamiltonian\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def linear_ops(self):\n        return self.common_ops()\n\n    @property\n    def original_ops(self):\n        return self.common_ops()\n\n    @property\n    def ops(self):\n        return self.full_ops()\n\n    @abstractmethod\n    def common_ops(self) -&gt; Dict[str, Qarray]:\n        \"\"\"Set up common ops in the specified basis.\"\"\"\n\n    @abstractmethod\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n\n    @abstractmethod\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n\n    @abstractmethod\n    def get_H_full(self):\n        \"\"\"Return full H.\"\"\"\n\n    def get_H(self):\n        \"\"\"\n        Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n        \"\"\"\n        return self.get_op_in_H_eigenbasis(\n            self._get_H_in_original_basis()\n        ).keep_only_diag_elements()\n\n    def _get_H_in_original_basis(self):\n        \"\"\"This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n\n    def _calculate_eig_systems(self):\n        evs, evecs = jnp.linalg.eigh(self._get_H_in_original_basis().data)  # Hermitian\n        idxs_sorted = jnp.argsort(evs)\n        return evs[idxs_sorted], evecs[:, idxs_sorted]\n\n    @property\n    def eig_systems(self):\n        eig_systems = {}\n        eig_systems[\"vals\"], eig_systems[\"vecs\"] = self._calculate_eig_systems()\n\n        eig_systems[\"vecs\"] = eig_systems[\"vecs\"]\n        eig_systems[\"vals\"] = eig_systems[\"vals\"]\n        return eig_systems\n\n    def get_op_in_H_eigenbasis(self, op: Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        dims = [[self.N], [self.N]]\n        return get_op_in_new_basis(op, evecs, dims)\n\n    def get_op_data_in_H_eigenbasis(self, op: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_op_data_in_new_basis(op, evecs)\n\n    def get_vec_in_H_eigenbasis(self, vec: Qarray):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        if vec.qtype == Qtypes.ket:\n            dims = [[self.N], [1]]\n        else:\n            dims = [[1], [self.N]]\n        return get_vec_in_new_basis(vec, evecs, dims)\n\n    def get_vec_data_in_H_eigenbasis(self, vec: Array):\n        evecs = self.eig_systems[\"vecs\"][:, : self.N]\n        return get_vec_data_in_new_basis(vec, evecs)\n\n    def full_ops(self):\n        # TODO: use JAX vmap here\n\n        linear_ops = self.linear_ops\n        ops = {}\n        for name, op in linear_ops.items():\n            ops[name] = self.get_op_in_H_eigenbasis(op)\n\n        return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Device.common_ops","title":"<code>common_ops()</code>  <code>abstractmethod</code>","text":"<p>Set up common ops in the specified basis.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef common_ops(self) -&gt; Dict[str, Qarray]:\n    \"\"\"Set up common ops in the specified basis.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Device.create","title":"<code>create(N, params, label=0, N_pre_diag=None, use_linear=False, hamiltonian=None, basis=None)</code>  <code>classmethod</code>","text":"<p>Create a device.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>dimension of Hilbert space.</p> required <code>params</code> <code>dict</code> <p>parameters of the device.</p> required <code>label</code> <code>int</code> <p>label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.</p> <code>0</code> <code>N_pre_diag</code> <code>int</code> <p>dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.</p> <code>None</code> <code>use_linear</code> <code>bool</code> <p>whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.</p> <code>False</code> <code>hamiltonian</code> <code>HamiltonianTypes</code> <p>type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.</p> <code>None</code> <code>basis</code> <code>BasisTypes</code> <p>type of basis. Defaults to None, in which case the fock basis is used.</p> <code>None</code> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    N,\n    params,\n    label=0,\n    N_pre_diag=None,\n    use_linear=False,\n    hamiltonian: HamiltonianTypes = None,\n    basis: BasisTypes = None,\n):\n    \"\"\"Create a device.\n\n    Args:\n        N (int): dimension of Hilbert space.\n        params (dict): parameters of the device.\n        label (int, optional): label for the device. Defaults to 0. This is useful when you have multiple of the same device type in the same system.\n        N_pre_diag (int, optional): dimension of Hilbert space before diagonalization. Defaults to None, in which case it is set to N. This must be greater than or rqual to N.\n        use_linear (bool): whether to use the linearized device. Defaults to False. This will override the hamiltonian keyword argument. This is a bit redundant with hamiltonian, but it is kept for backwards compatibility.\n        hamiltonian (HamiltonianTypes, optional): type of Hamiltonian. Defaults to None, in which case the full hamiltonian is used.\n        basis (BasisTypes, optional): type of basis. Defaults to None, in which case the fock basis is used.\n    \"\"\"\n\n    if N_pre_diag is None:\n        N_pre_diag = N\n\n    assert N_pre_diag &gt;= N, \"N_pre_diag must be greater than or equal to N.\"\n\n    _basis = basis if basis is not None else cls.DEFAULT_BASIS\n    _hamiltonian = (\n        hamiltonian if hamiltonian is not None else cls.DEFAULT_HAMILTONIAN\n    )\n\n    if use_linear:\n        _hamiltonian = HamiltonianTypes.linear\n\n    cls.param_validation(N, N_pre_diag, params, _hamiltonian, _basis)\n\n    return cls(N, N_pre_diag, params, label, _basis, _hamiltonian)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Device.get_H","title":"<code>get_H()</code>","text":"<p>Return diagonalized H. Explicitly keep only diagonal elements of matrix.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Return diagonalized H. Explicitly keep only diagonal elements of matrix.\n    \"\"\"\n    return self.get_op_in_H_eigenbasis(\n        self._get_H_in_original_basis()\n    ).keep_only_diag_elements()\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Device.get_H_full","title":"<code>get_H_full()</code>  <code>abstractmethod</code>","text":"<p>Return full H.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_H_full(self):\n    \"\"\"Return full H.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Device.get_H_linear","title":"<code>get_H_linear()</code>  <code>abstractmethod</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Device.get_linear_frequency","title":"<code>get_linear_frequency()</code>  <code>abstractmethod</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@abstractmethod\ndef get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Device.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/base/base.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Drive","title":"<code>Drive</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>jaxquantum/devices/superconducting/drive.py</code> <pre><code>@struct.dataclass\nclass Drive(ABC):\n    N: int = struct.field(pytree_node=False)\n    fd: float\n    _label: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(cls, M_max, fd, label=0):\n        cls.M_max = M_max\n        N = 2 * M_max + 1\n        return cls(N, fd, label)\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def ops(self):\n        return self.common_ops()\n\n    def common_ops(self) -&gt; Dict[str, Qarray]:\n        ops = {}\n\n        M_max = self.M_max\n\n        # Construct M = \u2211\u2098 m|m&gt;&lt;m| operator in drive charge basis\n        ops[\"M\"] = jnp2jqt(jnp.diag(jnp.arange(-M_max, M_max + 1)))\n\n        # Construct Id = \u2211\u2098|m&gt;&lt;m| in the drive charge basis\n        ops[\"id\"] = jnp2jqt(jnp.identity(2 * M_max + 1))\n\n        # Construct M\u208a \u2261 exp(i\u03b8) and M\u208b \u2261 exp(-i\u03b8) operators for drive\n        ops[\"M-\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=1))\n        ops[\"M+\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=-1))\n\n        # Construct cos(\u03b8) \u2261 1/2 * [M\u208a + M\u208b] = 1/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"cos(\u03b8)\"] = 0.5 * (ops[\"M+\"] + ops[\"M-\"])\n\n        # Construct sin(\u03b8) \u2261 -i/2 * [M\u208a - M\u208b] = -i/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"sin(\u03b8)\"] = -0.5j * (ops[\"M+\"] - ops[\"M-\"])\n\n        # Construct more general drive operators cos(k\u03b8) and sin(k\u03b8)\n        for k in range(2, M_max + 1):\n            ops[f\"M_+{k}\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=-k))\n            ops[f\"M_-{k}\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=k))\n            ops[f\"cos({k}\u03b8)\"] = 0.5 * (ops[f\"M_+{k}\"] + ops[f\"M_-{k}\"])\n            ops[f\"sin({k}\u03b8)\"] = -0.5j * (ops[f\"M_+{k}\"] - ops[f\"M_-{k}\"])\n\n        return ops\n\n    #############################################################\n\n    def get_H(self):\n        \"\"\"\n        Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.\n        \"\"\"\n        return self.fd * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Drive.get_H","title":"<code>get_H()</code>","text":"<p>Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.</p> Source code in <code>jaxquantum/devices/superconducting/drive.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.\n    \"\"\"\n    return self.fd * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.FluxDevice","title":"<code>FluxDevice</code>","text":"<p>               Bases: <code>Device</code></p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@struct.dataclass\nclass FluxDevice(Device):\n    @abstractmethod\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n\n    def _calculate_wavefunctions_fock(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n        phi_osc = self.phi_zpf() * jnp.sqrt(2)  # length of oscillator\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        for n in range(self.N_pre_diag):\n            basis_functions.append(\n                harm_osc_wavefunction(n, phi_vals, jnp.real(phi_osc))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(\n            basis_functions\n        )\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        wavefunctions = basis_functions_in_H_eigenbasis\n        return wavefunctions\n\n    def _calculate_wavefunctions_charge(self, phi_vals):\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        n_labels = jnp.diag(self.original_ops[\"n\"].data)\n        for n in n_labels:\n            basis_functions.append(\n                1 / (jnp.sqrt(2 * jnp.pi)) * jnp.exp(1j * n * (2 * jnp.pi * -1 * phi_vals)) # Added a -1 to work with the SNAIL\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(\n            basis_functions\n        )\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        num_eigenstates = basis_functions_in_H_eigenbasis.shape[0]\n        phase_correction_factors = (1j ** (jnp.arange(0, num_eigenstates))).reshape(\n            num_eigenstates, 1\n        )  # TODO: review why these are needed...\n        wavefunctions = basis_functions_in_H_eigenbasis * phase_correction_factors\n        return wavefunctions\n\n    @abstractmethod\n    def potential(self, phi):\n        \"\"\"Return potential energy as a function of phi.\"\"\"\n\n    def plot_wavefunctions(self, phi_vals, max_n=None, which=None, ax=None, mode=\"abs\", ylim=None, y_scale_factor=1, zero_potential=False, wavefunction_color=None):\n        if self.basis == BasisTypes.fock:\n            _calculate_wavefunctions = self._calculate_wavefunctions_fock\n        elif self.basis == BasisTypes.charge:\n            _calculate_wavefunctions = self._calculate_wavefunctions_charge\n        else:\n            raise NotImplementedError(\n                f\"The {self.basis} is not yet supported for plotting wavefunctions.\"\n            )\n\n        \"\"\"Plot wavefunctions at phi_exts.\"\"\"\n        wavefunctions = _calculate_wavefunctions(phi_vals)\n        energy_levels = self.eig_systems[\"vals\"][: self.N]\n\n        potential = self.potential(phi_vals)\n\n        min_potential = 0 if not zero_potential else jnp.min(potential)\n        if ax is None:\n            fig, ax = plt.subplots(1, 1, figsize=(3.5, 2.5), dpi=1000)\n        else:\n            fig = ax.get_figure()\n\n        min_val = None\n        max_val = None\n\n        assert max_n is None or which is None, \"Can't specify both max_n and which\"\n\n        max_n = self.N if max_n is None else max_n\n        levels = range(max_n) if which is None else which\n\n        for n in levels:\n            if mode == \"abs\":\n                wf_vals = jnp.abs(wavefunctions[n, :]) ** 2\n            elif mode == \"real\":\n                wf_vals = wavefunctions[n, :].real\n            elif mode == \"imag\":\n                wf_vals = wavefunctions[n, :].imag\n\n            wf_vals += energy_levels[n]\n            curr_min_val = min(wf_vals)\n            curr_max_val = max(wf_vals)\n\n            if min_val is None or curr_min_val &lt; min_val:\n                min_val = curr_min_val\n\n            if max_val is None or curr_max_val &gt; max_val:\n                max_val = curr_max_val\n\n            extra_kwargs = {}\n            if wavefunction_color is not None:\n                if isinstance(wavefunction_color, list):\n                    extra_kwargs[\"color\"] = wavefunction_color[n]\n                else:\n                    extra_kwargs[\"color\"] = wavefunction_color\n\n            ax.plot(\n                phi_vals, (wf_vals - min_potential)*y_scale_factor, label=f\"$|${n}$\\\\rangle$\", linestyle=\"-\", linewidth=1, **extra_kwargs\n            )\n\n            ax.fill_between(phi_vals, (energy_levels[n] - min_potential)*y_scale_factor, (wf_vals - min_potential)*y_scale_factor, alpha=0.5, **extra_kwargs)\n\n        ax.plot(\n            phi_vals,\n            (potential - min_potential)*y_scale_factor,\n            label=\"potential\",\n            color=\"black\",\n            linestyle=\"-\",\n            linewidth=1,\n        )\n\n        ylim = ylim if ylim is not None else [jnp.min(jnp.array([min_val - 1 - min_potential, jnp.min(potential) - min_potential]))*y_scale_factor, (max_val + 1 - min_potential)*y_scale_factor]\n        ax.set_ylim(ylim)\n        ax.set_xlabel(r\"$\\varphi/2\\pi$\")\n        ax.set_ylabel(r\"Energy [GHz]\")\n\n        if mode == \"abs\":\n            title_str = r\"$|\\psi_n(\\Phi)|^2$\"\n        elif mode == \"real\":\n            title_str = r\"Re($\\psi_n(\\Phi)$)\"\n        elif mode == \"imag\":\n            title_str = r\"Im($\\psi_n(\\Phi)$)\"\n\n        ax.set_title(f\"{title_str}\")\n\n        ax.legend(fontsize='xx-small')\n        fig.tight_layout()\n\n        return ax\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.FluxDevice.phi_zpf","title":"<code>phi_zpf()</code>  <code>abstractmethod</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@abstractmethod\ndef phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.FluxDevice.potential","title":"<code>potential(phi)</code>  <code>abstractmethod</code>","text":"<p>Return potential energy as a function of phi.</p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@abstractmethod\ndef potential(self, phi):\n    \"\"\"Return potential energy as a function of phi.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Fluxonium","title":"<code>Fluxonium</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Fluxonium Device.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>@struct.dataclass\nclass Fluxonium(FluxDevice):\n    \"\"\"\n    Fluxonium Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        ops[\"cos(\u03c6/2)\"] = cosm(ops[\"phi\"] / 2)\n        ops[\"sin(\u03c6/2)\"] = sinm(ops[\"phi\"] / 2)\n\n        return ops\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        phi_op = self.linear_ops[\"phi\"]\n        return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n\n    def get_H_nonlinear(self, phi_op):\n        op_cos_phi = cosm(phi_op)\n        op_sin_phi = sinm(phi_op)\n\n        phi_ext = self.params[\"phi_ext\"]\n        Hcos = op_cos_phi * jnp.cos(2.0 * jnp.pi * phi_ext) + op_sin_phi * jnp.sin(\n            2.0 * jnp.pi * phi_ext\n        )\n        H_nl = -self.params[\"Ej\"] * Hcos\n        return H_nl\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        phi_ext = self.params[\"phi_ext\"]\n        V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return V_linear\n\n        V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n        if self.hamiltonian == HamiltonianTypes.full:\n            return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Fluxonium.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    ops[\"cos(\u03c6/2)\"] = cosm(ops[\"phi\"] / 2)\n    ops[\"sin(\u03c6/2)\"] = sinm(ops[\"phi\"] / 2)\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Fluxonium.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    phi_op = self.linear_ops[\"phi\"]\n    return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Fluxonium.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Fluxonium.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Fluxonium.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Fluxonium.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    phi_ext = self.params[\"phi_ext\"]\n    V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return V_linear\n\n    V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n    if self.hamiltonian == HamiltonianTypes.full:\n        return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.IdealQubit","title":"<code>IdealQubit</code>","text":"<p>               Bases: <code>Device</code></p> <p>Ideal qubit Device.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>@struct.dataclass\nclass IdealQubit(Device):\n    \"\"\"\n    Ideal qubit Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, (\n            \"IdealQubit is a two-level system defined in the Fock basis.\"\n        )\n        assert hamiltonian == HamiltonianTypes.full, (\n            \"IdealQubit requires a full Hamiltonian.\"\n        )\n        assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n        assert \"f\" in params, \"IdealQubit requires a frequency parameter 'f'.\"\n\n        params[\"\u0394\"] = params.get(\"\u0394\", 0.0)\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        assert self.N_pre_diag == 2\n        assert self.N == 2\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"sigmaz\"] = sigmaz()\n        ops[\"sigmax\"] = sigmax()\n        ops[\"sigmay\"] = sigmay()\n        ops[\"sigmam\"] = sigmam()\n        ops[\"sigmap\"] = sigmap()\n\n        return ops\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"f\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return (w / 2) * self.linear_ops[\"sigmaz\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        return self.get_H_linear() + self.params[\"\u0394\"] / 2 * self.linear_ops[\"sigmax\"] \n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.IdealQubit.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    assert self.N_pre_diag == 2\n    assert self.N == 2\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"sigmaz\"] = sigmaz()\n    ops[\"sigmax\"] = sigmax()\n    ops[\"sigmay\"] = sigmay()\n    ops[\"sigmam\"] = sigmam()\n    ops[\"sigmap\"] = sigmap()\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.IdealQubit.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    return self.get_H_linear() + self.params[\"\u0394\"] / 2 * self.linear_ops[\"sigmax\"] \n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.IdealQubit.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return (w / 2) * self.linear_ops[\"sigmaz\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.IdealQubit.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"f\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.IdealQubit.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, (\n        \"IdealQubit is a two-level system defined in the Fock basis.\"\n    )\n    assert hamiltonian == HamiltonianTypes.full, (\n        \"IdealQubit requires a full Hamiltonian.\"\n    )\n    assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n    assert \"f\" in params, \"IdealQubit requires a frequency parameter 'f'.\"\n\n    params[\"\u0394\"] = params.get(\"\u0394\", 0.0)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.KNO","title":"<code>KNO</code>","text":"<p>               Bases: <code>Device</code></p> <p>Kerr Nonlinear Oscillator Device.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>@struct.dataclass\nclass KNO(Device):\n    \"\"\"\n    Kerr Nonlinear Oscillator Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, (\n            \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\"\n        )\n        assert hamiltonian == HamiltonianTypes.full, (\n            \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n        )\n        assert \"f\" in params and \"\u03b1\" in params, (\n            \"Kerr Nonlinear Oscillator requires frequency 'f' and anharmonicity '\u03b1' as parameters.\"\n        )\n\n    def common_ops(self):\n        ops = {}\n\n        N = self.N\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = (ops[\"a\"] + ops[\"a_dag\"]) / jnp.sqrt(2)\n        ops[\"n\"] = 1j * (ops[\"a_dag\"] - ops[\"a\"]) / jnp.sqrt(2)\n        return ops\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"f\"]\n\n    def get_anharm(self):\n        \"\"\"Get anharmonicity.\"\"\"\n        return self.params[\"\u03b1\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        \u03b1 = self.get_anharm()\n\n        return self.get_H_linear() + (\u03b1 / 2) * (\n            self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a\"]\n            @ self.linear_ops[\"a\"]\n        )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.KNO.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    \u03b1 = self.get_anharm()\n\n    return self.get_H_linear() + (\u03b1 / 2) * (\n        self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a\"]\n        @ self.linear_ops[\"a\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.KNO.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.KNO.get_anharm","title":"<code>get_anharm()</code>","text":"<p>Get anharmonicity.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_anharm(self):\n    \"\"\"Get anharmonicity.\"\"\"\n    return self.params[\"\u03b1\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.KNO.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"f\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.KNO.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, (\n        \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\"\n    )\n    assert hamiltonian == HamiltonianTypes.full, (\n        \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n    )\n    assert \"f\" in params and \"\u03b1\" in params, (\n        \"Kerr Nonlinear Oscillator requires frequency 'f' and anharmonicity '\u03b1' as parameters.\"\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray","title":"<code>Qarray</code>","text":"Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@struct.dataclass  # this allows us to send in and return Qarray from jitted functions\nclass Qarray:\n    _data: Array\n    _qdims: Qdims = struct.field(pytree_node=False)\n    _bdims: tuple[int] = struct.field(pytree_node=False)\n\n    # Initialization ----\n    @classmethod\n    def create(cls, data, dims=None, bdims=None):\n        # Step 1: Prepare data ----\n        data = jnp.asarray(data)\n\n        if len(data.shape) == 1 and data.shape[0] &gt; 0:\n            data = data.reshape(data.shape[0], 1)\n\n        if len(data.shape) &gt;= 2:\n            if data.shape[-2] != data.shape[-1] and not (\n                data.shape[-2] == 1 or data.shape[-1] == 1\n            ):\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n\n        if bdims is not None:\n            if len(data.shape) - len(bdims) == 1:\n                data = data.reshape(*data.shape[:-1], data.shape[-1], 1)\n        # ----\n\n        # Step 2: Prepare dimensions ----\n        if bdims is None:\n            bdims = tuple(data.shape[:-2])\n\n        if dims is None:\n            dims = ((data.shape[-2],), (data.shape[-1],))\n\n        if not isinstance(dims[0], (list, tuple)):\n            # This handles the case where only the hilbert space dimensions are sent in.\n            if data.shape[-1] == 1:\n                dims = (tuple(dims), tuple([1 for _ in dims]))\n            elif data.shape[-2] == 1:\n                dims = (tuple([1 for _ in dims]), tuple(dims))\n            else:\n                dims = (tuple(dims), tuple(dims))\n        else:\n            dims = (tuple(dims[0]), tuple(dims[1]))\n\n        check_dims(dims, bdims, data.shape)\n\n        qdims = Qdims(dims)\n\n        # NOTE: Constantly tidying up on Qarray creation might be a bit overkill.\n        # It increases the compilation time, but only very slightly\n        # increased the runtime of the jit compiled function.\n        # We could instead use this tidy_up where we think we need it.\n        data = tidy_up(data, SETTINGS[\"auto_tidyup_atol\"])\n\n        return cls(data, qdims, bdims)\n\n    # ----\n\n    @classmethod\n    def from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n        \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n        data = jnp.array([qarr.data for qarr in qarr_list])\n\n        if len(qarr_list) == 0:\n            dims = ((), ())\n            bdims = ()\n        else:\n            dims = qarr_list[0].dims\n            bdims = qarr_list[0].bdims\n\n        if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n            raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n        bdims = (len(qarr_list),) + bdims\n\n        return cls.create(data, dims=dims, bdims=bdims)\n\n    @classmethod\n    def from_array(cls, qarr_arr) -&gt; Qarray:\n        \"\"\"Create a Qarray from a nested list of Qarrays.\n\n        Args:\n            qarr_arr (list): nested list of Qarrays\n\n        Returns:\n            Qarray: Qarray object\n        \"\"\"\n        if isinstance(qarr_arr, Qarray):\n            return qarr_arr\n\n        bdims = ()\n        lvl = qarr_arr\n        while not isinstance(lvl, Qarray):\n            bdims = bdims + (len(lvl),)\n            if len(lvl) &gt; 0:\n                lvl = lvl[0]\n            else:\n                break\n\n        def flat(lis):\n            flatList = []\n            for element in lis:\n                if type(element) is list:\n                    flatList += flat(element)\n                else:\n                    flatList.append(element)\n            return flatList\n\n        qarr_list = flat(qarr_arr)\n        qarr = cls.from_list(qarr_list)\n        qarr = qarr.reshape_bdims(*bdims)\n        return qarr\n\n    # Properties ----\n    @property\n    def qtype(self):\n        return self._qdims.qtype\n\n    @property\n    def dtype(self):\n        return self._data.dtype\n\n    @property\n    def dims(self):\n        return self._qdims.dims\n\n    @property\n    def bdims(self):\n        return self._bdims\n\n    @property\n    def qdims(self):\n        return self._qdims\n\n    @property\n    def space_dims(self):\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return self.dims[0]\n        elif self.qtype == Qtypes.bra:\n            return self.dims[1]\n        else:\n            # TODO: not reached for some reason\n            raise ValueError(\"Unsupported qtype.\")\n\n    @property\n    def data(self):\n        return self._data\n\n    @property\n    def shaped_data(self):\n        return self._data.reshape(self.bdims + self.dims[0] + self.dims[1])\n\n    @property\n    def shape(self):\n        return self.data.shape\n\n    @property\n    def is_batched(self):\n        return len(self.bdims) &gt; 0\n\n    def __getitem__(self, index):\n        if len(self.bdims) &gt; 0:\n            return Qarray.create(\n                self.data[index],\n                dims=self.dims,\n            )\n        else:\n            raise ValueError(\"Cannot index a non-batched Qarray.\")\n\n    def reshape_bdims(self, *args):\n        \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n        new_bdims = tuple(args)\n\n        if prod(new_bdims) == 0:\n            new_shape = new_bdims\n        else:\n            new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n        return Qarray.create(\n            self.data.reshape(new_shape),\n            dims=self.dims,\n            bdims=new_bdims,\n        )\n\n    def space_to_qdims(self, space_dims: List[int]):\n        if isinstance(space_dims[0], (list, tuple)):\n            return space_dims\n\n        if self.qtype in [Qtypes.oper, Qtypes.ket]:\n            return (tuple(space_dims), tuple([1 for _ in range(len(space_dims))]))\n        elif self.qtype == Qtypes.bra:\n            return (tuple([1 for _ in range(len(space_dims))]), tuple(space_dims))\n        else:\n            raise ValueError(\"Unsupported qtype for space_to_qdims conversion.\")\n\n    def reshape_qdims(self, *args):\n        \"\"\"Reshape the quantum dimensions of the Qarray.\n\n        Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n        Args:\n            *args: new Hilbert dimensions for the Qarray.\n\n        Returns:\n            Qarray: reshaped Qarray.\n        \"\"\"\n\n        new_space_dims = tuple(args)\n        current_space_dims = self.space_dims\n        assert prod(new_space_dims) == prod(current_space_dims)\n\n        new_qdims = self.space_to_qdims(new_space_dims)\n        new_bdims = self.bdims\n\n        return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n\n    def resize(self, new_shape):\n        \"\"\"Resize the Qarray to a new shape.\n\n        TODO: review and maybe deprecate this method.\n        \"\"\"\n        dims = self.dims\n        data = jnp.resize(self.data, new_shape)\n        return Qarray.create(\n            data,\n            dims=dims,\n        )\n\n    def __len__(self):\n        \"\"\"Length of the Qarray.\"\"\"\n        if len(self.bdims) &gt; 0:\n            return self.data.shape[0]\n        else:\n            raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Qarray):\n            raise ValueError(\"Cannot calculate equality of a Qarray with a non-Qarray.\")\n\n        if self.dims != other.dims:\n            return False\n\n        if self.bdims != other.bdims:\n            return False\n\n        return jnp.all(self.data == other.data)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # ----\n\n    # Elementary Math ----\n    def __matmul__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        _qdims_new = self._qdims @ other._qdims\n        return Qarray.create(\n            self.data @ other.data,\n            dims=_qdims_new.dims,\n        )\n\n    # NOTE: not possible to reach this.\n    # def __rmatmul__(self, other):\n    #     if not isinstance(other, Qarray):\n    #         return NotImplemented\n\n    #     _qdims_new = other._qdims @ self._qdims\n    #     return Qarray.create(\n    #         other.data @ self.data,\n    #         dims=_qdims_new.dims,\n    #     )\n\n    def __mul__(self, other):\n        if isinstance(other, Qarray):\n            return self.__matmul__(other)\n\n        other = other + 0.0j\n        if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n            other = other.reshape(other.shape + (1, 1))\n\n        return Qarray.create(\n            other * self.data,\n            dims=self._qdims.dims,\n        )\n\n    def __rmul__(self, other):\n        # NOTE: not possible to reach this.\n        # if isinstance(other, Qarray):\n        #     return self.__rmatmul__(other)\n\n        return self.__mul__(other)\n\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    def __truediv__(self, other):\n        \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n        if isinstance(other, Qarray):\n            raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n        return self.__mul__(1 / other)\n\n    def __add__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data + other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__add__(other)\n\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Qarray):\n            if self.dims != other.dims:\n                msg = (\n                    \"Dimensions are incompatible: \"\n                    + repr(self.dims)\n                    + \" and \"\n                    + repr(other.dims)\n                )\n                raise ValueError(msg)\n            return Qarray.create(self.data - other.data, dims=self.dims)\n\n        if robust_isscalar(other) and other == 0:\n            return self.copy()\n\n        if self.data.shape[-2] == self.data.shape[-1]:\n            other = other + 0.0j\n            if not robust_isscalar(other) and len(other.shape) &gt; 0:  # not a scalar\n                other = other.reshape(other.shape + (1, 1))\n            other = Qarray.create(\n                other * jnp.eye(self.data.shape[-2], dtype=self.data.dtype),\n                dims=self.dims,\n            )\n            return self.__sub__(other)\n\n        return NotImplemented\n\n    def __rsub__(self, other):\n        return self.__neg__().__add__(other)\n\n    def __xor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(self, other)\n\n    def __rxor__(self, other):\n        if not isinstance(other, Qarray):\n            return NotImplemented\n        return tensor(other, self)\n\n    def __pow__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n\n        return powm(self, other)\n\n    # ----\n\n    # String Representation ----\n    def _str_header(self):\n        out = \", \".join(\n            [\n                \"Quantum array: dims = \" + str(self.dims),\n                \"bdims = \" + str(self.bdims),\n                \"shape = \" + str(self._data.shape),\n                \"type = \" + str(self.qtype),\n            ]\n        )\n        return out\n\n    def __str__(self):\n        return self._str_header() + \"\\nQarray data =\\n\" + str(self.data)\n\n    @property\n    def header(self):\n        \"\"\"Print the header of the Qarray.\"\"\"\n        return self._str_header()\n\n    def __repr__(self):\n        return self.__str__()\n\n    # ----\n\n    # Utilities ----\n    def copy(self, memo=None):\n        # return Qarray.create(deepcopy(self.data), dims=self.dims)\n        return self.__deepcopy__(memo)\n\n    def __deepcopy__(self, memo):\n        \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n        return Qarray(\n            _data=deepcopy(self._data, memo=memo),\n            _qdims=deepcopy(self._qdims, memo=memo),\n            _bdims=deepcopy(self._bdims, memo=memo),\n        )\n\n    def __getattr__(self, method_name):\n        if \"__\" == method_name[:2]:\n            # NOTE: we return NotImplemented for binary special methods logic in python, plus things like __jax_array__\n            return lambda *args, **kwargs: NotImplemented\n\n        modules = [jnp, jnp.linalg, jsp, jsp.linalg]\n\n        method_f = None\n        for mod in modules:\n            method_f = getattr(mod, method_name, None)\n            if method_f is not None:\n                break\n\n        if method_f is None:\n            raise NotImplementedError(\n                f\"Method {method_name} does not exist. No backup method found in {modules}.\"\n            )\n\n        def func(*args, **kwargs):\n            res = method_f(self.data, *args, **kwargs)\n\n            if getattr(res, \"shape\", None) is None or res.shape != self.data.shape:\n                return res\n            else:\n                return Qarray.create(res, dims=self._qdims.dims)\n\n        return func\n\n    # ----\n\n    # Conversions / Reshaping ----\n    def dag(self):\n        return dag(self)\n\n    def to_dm(self):\n        return ket2dm(self)\n\n    def is_dm(self):\n        return self.qtype == Qtypes.oper\n\n    def is_vec(self):\n        return self.qtype == Qtypes.ket or self.qtype == Qtypes.bra\n\n    def to_ket(self):\n        return to_ket(self)\n\n    def transpose(self, *args):\n        return transpose(self, *args)\n\n    def keep_only_diag_elements(self):\n        return keep_only_diag_elements(self)\n\n    # ----\n\n    # Math Functions ----\n    def unit(self):\n        return unit(self)\n\n    def norm(self):\n        return norm(self)\n\n    def expm(self):\n        return expm(self)\n\n    def powm(self, n):\n        return powm(self, n)\n\n    def cosm(self):\n        return cosm(self)\n\n    def sinm(self):\n        return sinm(self)\n\n    def tr(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def trace(self, **kwargs):\n        return tr(self, **kwargs)\n\n    def ptrace(self, indx):\n        return ptrace(self, indx)\n\n    def eigenstates(self):\n        return eigenstates(self)\n\n    def eigenenergies(self):\n        return eigenenergies(self)\n\n    def collapse(self, mode=\"sum\"):\n        return collapse(self, mode=mode)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.header","title":"<code>header</code>  <code>property</code>","text":"<p>Print the header of the Qarray.</p>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Need to override this when defininig getattr.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"Need to override this when defininig __getattr__.\"\"\"\n\n    return Qarray(\n        _data=deepcopy(self._data, memo=memo),\n        _qdims=deepcopy(self._qdims, memo=memo),\n        _bdims=deepcopy(self._bdims, memo=memo),\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.__len__","title":"<code>__len__()</code>","text":"<p>Length of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __len__(self):\n    \"\"\"Length of the Qarray.\"\"\"\n    if len(self.bdims) &gt; 0:\n        return self.data.shape[0]\n    else:\n        raise ValueError(\"Cannot get length of a non-batched Qarray.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>For Qarray's, this only really makes sense in the context of division by a scalar.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"For Qarray's, this only really makes sense in the context of division by a scalar.\"\"\"\n\n    if isinstance(other, Qarray):\n        raise ValueError(\"Cannot divide a Qarray by another Qarray.\")\n\n    return self.__mul__(1 / other)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.from_array","title":"<code>from_array(qarr_arr)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a nested list of Qarrays.</p> <p>Parameters:</p> Name Type Description Default <code>qarr_arr</code> <code>list</code> <p>nested list of Qarrays</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <code>Qarray</code> <p>Qarray object</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_array(cls, qarr_arr) -&gt; Qarray:\n    \"\"\"Create a Qarray from a nested list of Qarrays.\n\n    Args:\n        qarr_arr (list): nested list of Qarrays\n\n    Returns:\n        Qarray: Qarray object\n    \"\"\"\n    if isinstance(qarr_arr, Qarray):\n        return qarr_arr\n\n    bdims = ()\n    lvl = qarr_arr\n    while not isinstance(lvl, Qarray):\n        bdims = bdims + (len(lvl),)\n        if len(lvl) &gt; 0:\n            lvl = lvl[0]\n        else:\n            break\n\n    def flat(lis):\n        flatList = []\n        for element in lis:\n            if type(element) is list:\n                flatList += flat(element)\n            else:\n                flatList.append(element)\n        return flatList\n\n    qarr_list = flat(qarr_arr)\n    qarr = cls.from_list(qarr_list)\n    qarr = qarr.reshape_bdims(*bdims)\n    return qarr\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.from_list","title":"<code>from_list(qarr_list)</code>  <code>classmethod</code>","text":"<p>Create a Qarray from a list of Qarrays.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>@classmethod\ndef from_list(cls, qarr_list: List[Qarray]) -&gt; Qarray:\n    \"\"\"Create a Qarray from a list of Qarrays.\"\"\"\n\n    data = jnp.array([qarr.data for qarr in qarr_list])\n\n    if len(qarr_list) == 0:\n        dims = ((), ())\n        bdims = ()\n    else:\n        dims = qarr_list[0].dims\n        bdims = qarr_list[0].bdims\n\n    if not all(qarr.dims == dims and qarr.bdims == bdims for qarr in qarr_list):\n        raise ValueError(\"All Qarrays in the list must have the same dimensions.\")\n\n    bdims = (len(qarr_list),) + bdims\n\n    return cls.create(data, dims=dims, bdims=bdims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.reshape_bdims","title":"<code>reshape_bdims(*args)</code>","text":"<p>Reshape the batch dimensions of the Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_bdims(self, *args):\n    \"\"\"Reshape the batch dimensions of the Qarray.\"\"\"\n    new_bdims = tuple(args)\n\n    if prod(new_bdims) == 0:\n        new_shape = new_bdims\n    else:\n        new_shape = new_bdims + (prod(self.dims[0]),) + (-1,)\n    return Qarray.create(\n        self.data.reshape(new_shape),\n        dims=self.dims,\n        bdims=new_bdims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.reshape_qdims","title":"<code>reshape_qdims(*args)</code>","text":"<p>Reshape the quantum dimensions of the Qarray.</p> <p>Note that this does not take in qdims but rather the new Hilbert space dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>new Hilbert dimensions for the Qarray.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>reshaped Qarray.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def reshape_qdims(self, *args):\n    \"\"\"Reshape the quantum dimensions of the Qarray.\n\n    Note that this does not take in qdims but rather the new Hilbert space dimensions.\n\n    Args:\n        *args: new Hilbert dimensions for the Qarray.\n\n    Returns:\n        Qarray: reshaped Qarray.\n    \"\"\"\n\n    new_space_dims = tuple(args)\n    current_space_dims = self.space_dims\n    assert prod(new_space_dims) == prod(current_space_dims)\n\n    new_qdims = self.space_to_qdims(new_space_dims)\n    new_bdims = self.bdims\n\n    return Qarray.create(self.data, dims=new_qdims, bdims=new_bdims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Qarray.resize","title":"<code>resize(new_shape)</code>","text":"<p>Resize the Qarray to a new shape.</p> <p>TODO: review and maybe deprecate this method.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def resize(self, new_shape):\n    \"\"\"Resize the Qarray to a new shape.\n\n    TODO: review and maybe deprecate this method.\n    \"\"\"\n    dims = self.dims\n    data = jnp.resize(self.data, new_shape)\n    return Qarray.create(\n        data,\n        dims=dims,\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Resonator","title":"<code>Resonator</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Resonator Device.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>@struct.dataclass\nclass Resonator(FluxDevice):\n    \"\"\"\n    Resonator Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"] + 1 / 2)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Resonator.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Resonator.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Resonator.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"] + 1 / 2)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Resonator.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Resonator.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Resonator.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL","title":"<code>SNAIL</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>SNAIL Device.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>@struct.dataclass\nclass SNAIL(FluxDevice):\n    \"\"\"\n    SNAIL Device.\n    \"\"\"\n\n    DEFAULT_BASIS = BasisTypes.charge\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n\n        assert params[\"m\"] % 1 == 0, \"m must be an integer.\"\n        assert params[\"m\"] &gt;= 2, \"m must be greater than or equal to 2.\"\n\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            charge_basis_types = [\n                BasisTypes.charge\n            ]\n            assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n            assert (N_pre_diag - 1) % 2 * (params[\"m\"]) == 0, \"(N_pre_diag - 1)/2 must be divisible by m.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = identity(N)\n            ops[\"a\"] = destroy(N)\n            ops[\"a_dag\"] = create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            m = self.params[\"m\"]\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6/m)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6/m)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=m) + jnp.eye(N, k=-m)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=m) - jnp.eye(N, k=-m)))\n\n            n_max = (N - 1) // 2\n            n_array = jnp.arange(-n_max, n_max + 1) / self.params[\"m\"]\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n\n            n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n\n        \u03b1 = self.params[\"alpha\"]\n        m = self.params[\"m\"]\n        phi_ext = self.params[\"phi_ext\"]\n        Ej = self.Ej\n\n        H_charge = self.original_ops[\"H_charge\"]\n        H_inductive = - \u03b1 * Ej * self.original_ops[\"cos(\u03c6)\"] - m * Ej * (\n            jnp.cos(2 * jnp.pi * phi_ext/m) * self.original_ops[\"cos(\u03c6/m)\"] + jnp.sin(2 * jnp.pi * phi_ext/m) * self.original_ops[\"sin(\u03c6/m)\"]\n        )\n        return H_charge + H_inductive\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        raise NotImplementedError(\"Truncated Hamiltonian not implemented for SNAIL.\")\n        # phi_op = self.original_ops[\"phi\"]  \n        # fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        # sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        # return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n\n            \u03b1 = self.params[\"alpha\"]\n            m = self.params[\"m\"]\n            phi_ext = self.params[\"phi_ext\"]\n\n            return - \u03b1 * self.Ej * jnp.cos(2 * jnp.pi * phi) - (\n                m * self.Ej * jnp.cos(2 * jnp.pi * (phi_ext - phi) / m)\n            )\n\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            raise NotImplementedError(\"Truncated potential not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        m = self.params[\"m\"]\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6/m)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6/m)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=m) + jnp.eye(N, k=-m)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=m) - jnp.eye(N, k=-m)))\n\n        n_max = (N - 1) // 2\n        n_array = jnp.arange(-n_max, n_max + 1) / self.params[\"m\"]\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n\n        n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n\n    \u03b1 = self.params[\"alpha\"]\n    m = self.params[\"m\"]\n    phi_ext = self.params[\"phi_ext\"]\n    Ej = self.Ej\n\n    H_charge = self.original_ops[\"H_charge\"]\n    H_inductive = - \u03b1 * Ej * self.original_ops[\"cos(\u03c6)\"] - m * Ej * (\n        jnp.cos(2 * jnp.pi * phi_ext/m) * self.original_ops[\"cos(\u03c6/m)\"] + jnp.sin(2 * jnp.pi * phi_ext/m) * self.original_ops[\"sin(\u03c6/m)\"]\n    )\n    return H_charge + H_inductive\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    raise NotImplementedError(\"Truncated Hamiltonian not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n\n    assert params[\"m\"] % 1 == 0, \"m must be an integer.\"\n    assert params[\"m\"] &gt;= 2, \"m must be greater than or equal to 2.\"\n\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        charge_basis_types = [\n            BasisTypes.charge\n        ]\n        assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        assert (N_pre_diag - 1) % 2 * (params[\"m\"]) == 0, \"(N_pre_diag - 1)/2 must be divisible by m.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.SNAIL.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n\n        \u03b1 = self.params[\"alpha\"]\n        m = self.params[\"m\"]\n        phi_ext = self.params[\"phi_ext\"]\n\n        return - \u03b1 * self.Ej * jnp.cos(2 * jnp.pi * phi) - (\n            m * self.Ej * jnp.cos(2 * jnp.pi * (phi_ext - phi) / m)\n        )\n\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        raise NotImplementedError(\"Truncated potential not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon","title":"<code>Transmon</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Transmon Device.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>@struct.dataclass\nclass Transmon(FluxDevice):\n    \"\"\"\n    Transmon Device.\n    \"\"\"\n\n    DEFAULT_BASIS = BasisTypes.charge\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            charge_basis_types = [\n                BasisTypes.charge,\n                BasisTypes.singlecharge,\n                BasisTypes.singlecharge_even,\n                BasisTypes.singlecharge_odd,\n            ]\n            assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n        if basis in [BasisTypes.singlecharge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            assert (N_pre_diag) % 2 == 0, \"N_pre_diag must be even for single charge bases.\"\n        else:\n            assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = identity(N)\n            ops[\"a\"] = destroy(N)\n            ops[\"a_dag\"] = create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n            ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n            ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n\n            n_max = (N - 1) // 2\n            n_array = jnp.arange(-n_max, n_max + 1)\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            n_max = N\n\n            if self.basis == BasisTypes.singlecharge_even:\n                n_array = jnp.arange(-n_max, n_max, 2)\n            elif self.basis == BasisTypes.singlecharge_odd:\n                n_array = jnp.arange(-n_max + 1, n_max, 2)\n\n            ops[\"id\"] = identity(n_max)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=1) + jnp.eye(n_max, k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=1) - jnp.eye(n_max, k=-1)))\n            ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=2) + jnp.eye(n_max, k=-2)))\n            ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=2) - jnp.eye(n_max, k=-2)))\n\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(n_max)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis == BasisTypes.singlecharge:\n            \"\"\"\n            Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n            thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n            not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n            (as done in Kyle's thesis).\n            \"\"\"\n            n_max = (N) // 2\n\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n            ops[\"cos(\u03c6/2)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6/2)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n\n            n_array = jnp.arange(-n_max, n_max)\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n        return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        phi_op = self.original_ops[\"phi\"]  \n        fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            phi_scaled = 2 * jnp.pi * phi\n            second_order = 0.5 * self.Ej * phi_scaled ** 2\n            fourth_order =  -(1 / 24) * self.Ej * phi_scaled ** 4\n            sixth_order = (1 / 720) * self.Ej * phi_scaled ** 6\n            return second_order + fourth_order + sixth_order\n\n    def calculate_wavefunctions(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\n\n        TODO: this is not currently being used for plotting... needs to be updated!\n        \"\"\"\n\n        if self.basis == BasisTypes.fock:\n            return super().calculate_wavefunctions(phi_vals)\n        elif self.basis == BasisTypes.singlecharge:\n            raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n        elif self.basis in [BasisTypes.charge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            phi_vals = jnp.array(phi_vals)\n\n            if self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n                n_labels = 1/2 * jnp.diag(self.original_ops[\"n\"].data)\n            else:\n                n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n            wavefunctions = []\n            for nj in range(self.N_pre_diag):\n                wavefunction = []\n                for phi in phi_vals:\n                    wavefunction.append(\n                        (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                            self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                        )\n                    )\n                wavefunctions.append(jnp.array(wavefunction))\n            return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.calculate_wavefunctions","title":"<code>calculate_wavefunctions(phi_vals)</code>","text":"<p>Calculate wavefunctions at phi_exts.</p> <p>TODO: this is not currently being used for plotting... needs to be updated!</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def calculate_wavefunctions(self, phi_vals):\n    \"\"\"Calculate wavefunctions at phi_exts.\n\n    TODO: this is not currently being used for plotting... needs to be updated!\n    \"\"\"\n\n    if self.basis == BasisTypes.fock:\n        return super().calculate_wavefunctions(phi_vals)\n    elif self.basis == BasisTypes.singlecharge:\n        raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n    elif self.basis in [BasisTypes.charge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        phi_vals = jnp.array(phi_vals)\n\n        if self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            n_labels = 1/2 * jnp.diag(self.original_ops[\"n\"].data)\n        else:\n            n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n        wavefunctions = []\n        for nj in range(self.N_pre_diag):\n            wavefunction = []\n            for phi in phi_vals:\n                wavefunction.append(\n                    (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                        self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                    )\n                )\n            wavefunctions.append(jnp.array(wavefunction))\n        return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n        ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n        ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n\n        n_max = (N - 1) // 2\n        n_array = jnp.arange(-n_max, n_max + 1)\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        n_max = N\n\n        if self.basis == BasisTypes.singlecharge_even:\n            n_array = jnp.arange(-n_max, n_max, 2)\n        elif self.basis == BasisTypes.singlecharge_odd:\n            n_array = jnp.arange(-n_max + 1, n_max, 2)\n\n        ops[\"id\"] = identity(n_max)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=1) + jnp.eye(n_max, k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=1) - jnp.eye(n_max, k=-1)))\n        ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=2) + jnp.eye(n_max, k=-2)))\n        ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=2) - jnp.eye(n_max, k=-2)))\n\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(n_max)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis == BasisTypes.singlecharge:\n        \"\"\"\n        Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n        thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n        not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n        (as done in Kyle's thesis).\n        \"\"\"\n        n_max = (N) // 2\n\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n        ops[\"cos(\u03c6/2)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6/2)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n\n        n_array = jnp.arange(-n_max, n_max)\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n    return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    phi_op = self.original_ops[\"phi\"]  \n    fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n    sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n    return self.get_H_linear() + fourth_order_term + sixth_order_term\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        charge_basis_types = [\n            BasisTypes.charge,\n            BasisTypes.singlecharge,\n            BasisTypes.singlecharge_even,\n            BasisTypes.singlecharge_odd,\n        ]\n        assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n\n    if basis in [BasisTypes.singlecharge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        assert (N_pre_diag) % 2 == 0, \"N_pre_diag must be even for single charge bases.\"\n    else:\n        assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.Transmon.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n        return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        phi_scaled = 2 * jnp.pi * phi\n        second_order = 0.5 * self.Ej * phi_scaled ** 2\n        fourth_order =  -(1 / 24) * self.Ej * phi_scaled ** 4\n        sixth_order = (1 / 720) * self.Ej * phi_scaled ** 6\n        return second_order + fourth_order + sixth_order\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.TunableTransmon","title":"<code>TunableTransmon</code>","text":"<p>               Bases: <code>Transmon</code></p> <p>Tunable Transmon Device.</p> Source code in <code>jaxquantum/devices/superconducting/tunable_transmon.py</code> <pre><code>@struct.dataclass\nclass TunableTransmon(Transmon):\n    \"\"\"\n    Tunable Transmon Device.\n    \"\"\"\n\n    @property\n    def Ej(self):\n        Ejsum = self.params[\"Ej1\"] + self.params[\"Ej2\"]\n        phi_ext = 2 * jnp.pi * self.params[\"phi_ext\"]\n        gamma = self.params[\"Ej2\"] / self.params[\"Ej1\"]\n        d = (gamma - 1) / (gamma + 1)\n        external_flux_factor = jnp.abs(\n            jnp.sqrt(jnp.cos(phi_ext / 2) ** 2 + d**2 * jnp.sin(phi_ext / 2) ** 2)\n        )\n        return Ejsum * external_flux_factor\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.cosm","title":"<code>cosm(qarr)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Matrix cosine wrapper.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    dims = qarr.dims\n    data = cosm_data(qarr.data)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.harm_osc_wavefunction","title":"<code>harm_osc_wavefunction(n, x, l_osc)</code>","text":"<p>Taken from scqubits... not jit-able</p> <p>For given quantum number n=0,1,2,... return the value of the harmonic oscillator wave function :math:<code>\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{ osc})</code>, N being the proper normalization factor.</p> <p>Directly uses <code>scipy.special.pbdv</code> (implementation of the parabolic cylinder function) to mitigate numerical stability issues with the more commonly used expression in terms of a Gaussian and a Hermite polynomial factor.</p>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.harm_osc_wavefunction--parameters","title":"Parameters","text":"<p>n:     index of wave function, n=0 is ground state x:     coordinate(s) where wave function is evaluated l_osc:     oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2</p>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.harm_osc_wavefunction--returns","title":"Returns","text":"<pre><code>value of harmonic oscillator wave function\n</code></pre> Source code in <code>jaxquantum/devices/common/utils.py</code> <pre><code>def harm_osc_wavefunction(n, x, l_osc):\n    r\"\"\"\n    Taken from scqubits... not jit-able\n\n    For given quantum number n=0,1,2,... return the value of the harmonic\n    oscillator wave function :math:`\\psi_n(x) = N H_n(x/l_{osc}) \\exp(-x^2/2l_\\text{\n    osc})`, N being the proper normalization factor.\n\n    Directly uses `scipy.special.pbdv` (implementation of the parabolic cylinder\n    function) to mitigate numerical stability issues with the more commonly used\n    expression in terms of a Gaussian and a Hermite polynomial factor.\n\n    Parameters\n    ----------\n    n:\n        index of wave function, n=0 is ground state\n    x:\n        coordinate(s) where wave function is evaluated\n    l_osc:\n        oscillator length, defined via &lt;0|x^2|0&gt; = l_osc^2/2\n\n    Returns\n    -------\n        value of harmonic oscillator wave function\n    \"\"\"\n    x = 2 * jnp.pi * x\n    result = pbdv(n, jnp.sqrt(2.0) * x / l_osc)[0]\n    result = result / jnp.sqrt(l_osc * jnp.sqrt(jnp.pi) * factorial_approx(n))\n    return result\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.jnp2jqt","title":"<code>jnp2jqt(arr, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnp2jqt(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n        dims: Qarray dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    dims = extract_dims(arr, dims) if dims is not None else None\n    return Qarray.create(arr, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.sigmam","title":"<code>sigmam()</code>","text":"<p>\u03c3-</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3- Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmam() -&gt; Qarray:\n    \"\"\"\u03c3-\n\n    Returns:\n        \u03c3- Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 0.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.sigmap","title":"<code>sigmap()</code>","text":"<p>\u03c3+</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3+ Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmap() -&gt; Qarray:\n    \"\"\"\u03c3+\n\n    Returns:\n        \u03c3+ Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [0.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/index.html#jaxquantum.devices.superconducting.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html","title":"ats","text":"<p>ATS.</p>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS","title":"<code>ATS</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>ATS Device.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>@struct.dataclass\nclass ATS(FluxDevice):\n    \"\"\"\n    ATS Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.params[\"El\"] / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    @staticmethod\n    def get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta):\n        cos_phi_op = cosm(phi_op)\n        sin_phi_op = sinm(phi_op)\n\n        cos_2phi_op = cos_phi_op @ cos_phi_op - sin_phi_op @ sin_phi_op\n        sin_2phi_op = 2 * cos_phi_op @ sin_phi_op\n\n        H_nl_Ej = (\n            -2\n            * Ej\n            * (\n                cos_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n                - sin_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n            )\n            * jnp.cos(2 * jnp.pi * phi_sum)\n        )\n        H_nl_dEj = (\n            2\n            * dEj\n            * (\n                sin_phi_op * jnp.cos(2 * jnp.pi * phi_delta)\n                + cos_phi_op * jnp.sin(2 * jnp.pi * phi_delta)\n            )\n            * jnp.sin(2 * jnp.pi * phi_sum)\n        )\n        H_nl_Ej2 = (\n            2\n            * Ej2\n            * (\n                cos_2phi_op * jnp.cos(2 * 2 * jnp.pi * phi_delta)\n                - sin_2phi_op * jnp.sin(2 * 2 * jnp.pi * phi_delta)\n            )\n            * jnp.cos(2 * 2 * jnp.pi * phi_sum)\n        )\n\n        H_nl = H_nl_Ej + H_nl_dEj + H_nl_Ej2\n\n        # id_op = jqt.identity_like(phi_op)\n        # phi_delta_ext_op = self.params[\"phi_delta_ext\"] * id_op\n        # H_nl_old = - 2 * Ej * jqt.cosm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * dEj * jqt.sinm(phi_op + 2 * jnp.pi * phi_delta_ext_op) * jnp.sin(2 * jnp.pi * self.params[\"phi_sum_ext\"])\n        # H_nl_old += 2 * Ej2 * jqt.cosm(2*phi_op + 2 * 2 * jnp.pi * phi_delta_ext_op) * jnp.cos(2 * 2 * jnp.pi * self.params[\"phi_sum_ext\"])\n\n        return H_nl\n\n    def get_H_nonlinear(self, phi_op):\n        \"\"\"Return nonlinear terms in H.\"\"\"\n\n        Ej = self.params[\"Ej\"]\n        dEj = self.params[\"dEj\"]\n        Ej2 = self.params[\"Ej2\"]\n\n        phi_sum = self.params[\"phi_sum_ext\"]\n        phi_delta = self.params[\"phi_delta_ext\"]\n\n        return ATS.get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        phi_b = self.linear_ops[\"phi\"]\n        H_nl = self.get_H_nonlinear(phi_b)\n        H = self.get_H_linear() + H_nl\n        return H\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n\n        phi_delta_ext = self.params[\"phi_delta_ext\"]\n        phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n        V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n        V += (\n            -2\n            * self.params[\"Ej\"]\n            * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.cos(2 * jnp.pi * phi_sum_ext)\n        )\n        V += (\n            2\n            * self.params[\"dEj\"]\n            * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.sin(2 * jnp.pi * phi_sum_ext)\n        )\n        V += (\n            2\n            * self.params[\"Ej2\"]\n            * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext))\n            * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n        )\n\n        return V\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    phi_b = self.linear_ops[\"phi\"]\n    H_nl = self.get_H_nonlinear(phi_b)\n    H = self.get_H_linear() + H_nl\n    return H\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS.get_H_nonlinear","title":"<code>get_H_nonlinear(phi_op)</code>","text":"<p>Return nonlinear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_H_nonlinear(self, phi_op):\n    \"\"\"Return nonlinear terms in H.\"\"\"\n\n    Ej = self.params[\"Ej\"]\n    dEj = self.params[\"dEj\"]\n    Ej2 = self.params[\"Ej2\"]\n\n    phi_sum = self.params[\"phi_sum_ext\"]\n    phi_delta = self.params[\"phi_delta_ext\"]\n\n    return ATS.get_H_nonlinear_static(phi_op, Ej, dEj, Ej2, phi_sum, phi_delta)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.params[\"El\"] / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ats.html#jaxquantum.devices.superconducting.ats.ATS.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/ats.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n\n    phi_delta_ext = self.params[\"phi_delta_ext\"]\n    phi_sum_ext = self.params[\"phi_sum_ext\"]\n\n    V = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n    V += (\n        -2\n        * self.params[\"Ej\"]\n        * jnp.cos(2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.cos(2 * jnp.pi * phi_sum_ext)\n    )\n    V += (\n        2\n        * self.params[\"dEj\"]\n        * jnp.sin(2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.sin(2 * jnp.pi * phi_sum_ext)\n    )\n    V += (\n        2\n        * self.params[\"Ej2\"]\n        * jnp.cos(2 * 2 * jnp.pi * (phi + phi_delta_ext))\n        * jnp.cos(2 * 2 * jnp.pi * phi_sum_ext)\n    )\n\n    return V\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/drive.html","title":"drive","text":"<p>Base Drive.</p>"},{"location":"reference/jaxquantum/devices/superconducting/drive.html#jaxquantum.devices.superconducting.drive.Drive","title":"<code>Drive</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>jaxquantum/devices/superconducting/drive.py</code> <pre><code>@struct.dataclass\nclass Drive(ABC):\n    N: int = struct.field(pytree_node=False)\n    fd: float\n    _label: int = struct.field(pytree_node=False)\n\n    @classmethod\n    def create(cls, M_max, fd, label=0):\n        cls.M_max = M_max\n        N = 2 * M_max + 1\n        return cls(N, fd, label)\n\n    @property\n    def label(self):\n        return self.__class__.__name__ + str(self._label)\n\n    @property\n    def ops(self):\n        return self.common_ops()\n\n    def common_ops(self) -&gt; Dict[str, Qarray]:\n        ops = {}\n\n        M_max = self.M_max\n\n        # Construct M = \u2211\u2098 m|m&gt;&lt;m| operator in drive charge basis\n        ops[\"M\"] = jnp2jqt(jnp.diag(jnp.arange(-M_max, M_max + 1)))\n\n        # Construct Id = \u2211\u2098|m&gt;&lt;m| in the drive charge basis\n        ops[\"id\"] = jnp2jqt(jnp.identity(2 * M_max + 1))\n\n        # Construct M\u208a \u2261 exp(i\u03b8) and M\u208b \u2261 exp(-i\u03b8) operators for drive\n        ops[\"M-\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=1))\n        ops[\"M+\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=-1))\n\n        # Construct cos(\u03b8) \u2261 1/2 * [M\u208a + M\u208b] = 1/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"cos(\u03b8)\"] = 0.5 * (ops[\"M+\"] + ops[\"M-\"])\n\n        # Construct sin(\u03b8) \u2261 -i/2 * [M\u208a - M\u208b] = -i/2 * \u2211\u2098|m+1&gt;&lt;m| + h.c\n        ops[\"sin(\u03b8)\"] = -0.5j * (ops[\"M+\"] - ops[\"M-\"])\n\n        # Construct more general drive operators cos(k\u03b8) and sin(k\u03b8)\n        for k in range(2, M_max + 1):\n            ops[f\"M_+{k}\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=-k))\n            ops[f\"M_-{k}\"] = jnp2jqt(jnp.eye(2 * M_max + 1, k=k))\n            ops[f\"cos({k}\u03b8)\"] = 0.5 * (ops[f\"M_+{k}\"] + ops[f\"M_-{k}\"])\n            ops[f\"sin({k}\u03b8)\"] = -0.5j * (ops[f\"M_+{k}\"] - ops[f\"M_-{k}\"])\n\n        return ops\n\n    #############################################################\n\n    def get_H(self):\n        \"\"\"\n        Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.\n        \"\"\"\n        return self.fd * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/drive.html#jaxquantum.devices.superconducting.drive.Drive.get_H","title":"<code>get_H()</code>","text":"<p>Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.</p> Source code in <code>jaxquantum/devices/superconducting/drive.py</code> <pre><code>def get_H(self):\n    \"\"\"\n    Bare \"drive\" Hamiltonian (fd * M) in the extended Hilbert space.\n    \"\"\"\n    return self.fd * self.ops[\"M\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/flux_base.html","title":"flux_base","text":"<p>Flux base device.</p>"},{"location":"reference/jaxquantum/devices/superconducting/flux_base.html#jaxquantum.devices.superconducting.flux_base.FluxDevice","title":"<code>FluxDevice</code>","text":"<p>               Bases: <code>Device</code></p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@struct.dataclass\nclass FluxDevice(Device):\n    @abstractmethod\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n\n    def _calculate_wavefunctions_fock(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\"\"\"\n        phi_osc = self.phi_zpf() * jnp.sqrt(2)  # length of oscillator\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        for n in range(self.N_pre_diag):\n            basis_functions.append(\n                harm_osc_wavefunction(n, phi_vals, jnp.real(phi_osc))\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(\n            basis_functions\n        )\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        wavefunctions = basis_functions_in_H_eigenbasis\n        return wavefunctions\n\n    def _calculate_wavefunctions_charge(self, phi_vals):\n        phi_vals = jnp.array(phi_vals)\n\n        # calculate basis functions\n        basis_functions = []\n        n_labels = jnp.diag(self.original_ops[\"n\"].data)\n        for n in n_labels:\n            basis_functions.append(\n                1 / (jnp.sqrt(2 * jnp.pi)) * jnp.exp(1j * n * (2 * jnp.pi * -1 * phi_vals)) # Added a -1 to work with the SNAIL\n            )\n        basis_functions = jnp.array(basis_functions)\n\n        # transform to better diagonal basis\n        basis_functions_in_H_eigenbasis = self.get_vec_data_in_H_eigenbasis(\n            basis_functions\n        )\n\n        # the below is equivalent to evecs_in_H_eigenbasis @ basis_functions_in_H_eigenbasis\n        # since evecs in H_eigenbasis is diagonal, i.e. the identity matrix\n        num_eigenstates = basis_functions_in_H_eigenbasis.shape[0]\n        phase_correction_factors = (1j ** (jnp.arange(0, num_eigenstates))).reshape(\n            num_eigenstates, 1\n        )  # TODO: review why these are needed...\n        wavefunctions = basis_functions_in_H_eigenbasis * phase_correction_factors\n        return wavefunctions\n\n    @abstractmethod\n    def potential(self, phi):\n        \"\"\"Return potential energy as a function of phi.\"\"\"\n\n    def plot_wavefunctions(self, phi_vals, max_n=None, which=None, ax=None, mode=\"abs\", ylim=None, y_scale_factor=1, zero_potential=False, wavefunction_color=None):\n        if self.basis == BasisTypes.fock:\n            _calculate_wavefunctions = self._calculate_wavefunctions_fock\n        elif self.basis == BasisTypes.charge:\n            _calculate_wavefunctions = self._calculate_wavefunctions_charge\n        else:\n            raise NotImplementedError(\n                f\"The {self.basis} is not yet supported for plotting wavefunctions.\"\n            )\n\n        \"\"\"Plot wavefunctions at phi_exts.\"\"\"\n        wavefunctions = _calculate_wavefunctions(phi_vals)\n        energy_levels = self.eig_systems[\"vals\"][: self.N]\n\n        potential = self.potential(phi_vals)\n\n        min_potential = 0 if not zero_potential else jnp.min(potential)\n        if ax is None:\n            fig, ax = plt.subplots(1, 1, figsize=(3.5, 2.5), dpi=1000)\n        else:\n            fig = ax.get_figure()\n\n        min_val = None\n        max_val = None\n\n        assert max_n is None or which is None, \"Can't specify both max_n and which\"\n\n        max_n = self.N if max_n is None else max_n\n        levels = range(max_n) if which is None else which\n\n        for n in levels:\n            if mode == \"abs\":\n                wf_vals = jnp.abs(wavefunctions[n, :]) ** 2\n            elif mode == \"real\":\n                wf_vals = wavefunctions[n, :].real\n            elif mode == \"imag\":\n                wf_vals = wavefunctions[n, :].imag\n\n            wf_vals += energy_levels[n]\n            curr_min_val = min(wf_vals)\n            curr_max_val = max(wf_vals)\n\n            if min_val is None or curr_min_val &lt; min_val:\n                min_val = curr_min_val\n\n            if max_val is None or curr_max_val &gt; max_val:\n                max_val = curr_max_val\n\n            extra_kwargs = {}\n            if wavefunction_color is not None:\n                if isinstance(wavefunction_color, list):\n                    extra_kwargs[\"color\"] = wavefunction_color[n]\n                else:\n                    extra_kwargs[\"color\"] = wavefunction_color\n\n            ax.plot(\n                phi_vals, (wf_vals - min_potential)*y_scale_factor, label=f\"$|${n}$\\\\rangle$\", linestyle=\"-\", linewidth=1, **extra_kwargs\n            )\n\n            ax.fill_between(phi_vals, (energy_levels[n] - min_potential)*y_scale_factor, (wf_vals - min_potential)*y_scale_factor, alpha=0.5, **extra_kwargs)\n\n        ax.plot(\n            phi_vals,\n            (potential - min_potential)*y_scale_factor,\n            label=\"potential\",\n            color=\"black\",\n            linestyle=\"-\",\n            linewidth=1,\n        )\n\n        ylim = ylim if ylim is not None else [jnp.min(jnp.array([min_val - 1 - min_potential, jnp.min(potential) - min_potential]))*y_scale_factor, (max_val + 1 - min_potential)*y_scale_factor]\n        ax.set_ylim(ylim)\n        ax.set_xlabel(r\"$\\varphi/2\\pi$\")\n        ax.set_ylabel(r\"Energy [GHz]\")\n\n        if mode == \"abs\":\n            title_str = r\"$|\\psi_n(\\Phi)|^2$\"\n        elif mode == \"real\":\n            title_str = r\"Re($\\psi_n(\\Phi)$)\"\n        elif mode == \"imag\":\n            title_str = r\"Im($\\psi_n(\\Phi)$)\"\n\n        ax.set_title(f\"{title_str}\")\n\n        ax.legend(fontsize='xx-small')\n        fig.tight_layout()\n\n        return ax\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/flux_base.html#jaxquantum.devices.superconducting.flux_base.FluxDevice.phi_zpf","title":"<code>phi_zpf()</code>  <code>abstractmethod</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@abstractmethod\ndef phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/flux_base.html#jaxquantum.devices.superconducting.flux_base.FluxDevice.potential","title":"<code>potential(phi)</code>  <code>abstractmethod</code>","text":"<p>Return potential energy as a function of phi.</p> Source code in <code>jaxquantum/devices/superconducting/flux_base.py</code> <pre><code>@abstractmethod\ndef potential(self, phi):\n    \"\"\"Return potential energy as a function of phi.\"\"\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/fluxonium.html","title":"fluxonium","text":"<p>Fluxonium.</p>"},{"location":"reference/jaxquantum/devices/superconducting/fluxonium.html#jaxquantum.devices.superconducting.fluxonium.Fluxonium","title":"<code>Fluxonium</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Fluxonium Device.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>@struct.dataclass\nclass Fluxonium(FluxDevice):\n    \"\"\"\n    Fluxonium Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        ops[\"cos(\u03c6/2)\"] = cosm(ops[\"phi\"] / 2)\n        ops[\"sin(\u03c6/2)\"] = sinm(ops[\"phi\"] / 2)\n\n        return ops\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (\n            self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n            + 0.5 * self.linear_ops[\"id\"]\n        )\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        phi_op = self.linear_ops[\"phi\"]\n        return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n\n    def get_H_nonlinear(self, phi_op):\n        op_cos_phi = cosm(phi_op)\n        op_sin_phi = sinm(phi_op)\n\n        phi_ext = self.params[\"phi_ext\"]\n        Hcos = op_cos_phi * jnp.cos(2.0 * jnp.pi * phi_ext) + op_sin_phi * jnp.sin(\n            2.0 * jnp.pi * phi_ext\n        )\n        H_nl = -self.params[\"Ej\"] * Hcos\n        return H_nl\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        phi_ext = self.params[\"phi_ext\"]\n        V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return V_linear\n\n        V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n        if self.hamiltonian == HamiltonianTypes.full:\n            return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/fluxonium.html#jaxquantum.devices.superconducting.fluxonium.Fluxonium.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    ops[\"cos(\u03c6/2)\"] = cosm(ops[\"phi\"] / 2)\n    ops[\"sin(\u03c6/2)\"] = sinm(ops[\"phi\"] / 2)\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/fluxonium.html#jaxquantum.devices.superconducting.fluxonium.Fluxonium.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    phi_op = self.linear_ops[\"phi\"]\n    return self.get_H_linear() + self.get_H_nonlinear(phi_op)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/fluxonium.html#jaxquantum.devices.superconducting.fluxonium.Fluxonium.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (\n        self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n        + 0.5 * self.linear_ops[\"id\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/fluxonium.html#jaxquantum.devices.superconducting.fluxonium.Fluxonium.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.params[\"El\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/fluxonium.html#jaxquantum.devices.superconducting.fluxonium.Fluxonium.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/fluxonium.html#jaxquantum.devices.superconducting.fluxonium.Fluxonium.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/fluxonium.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    phi_ext = self.params[\"phi_ext\"]\n    V_linear = 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return V_linear\n\n    V_nonlinear = -self.params[\"Ej\"] * jnp.cos(2.0 * jnp.pi * (phi - phi_ext))\n    if self.hamiltonian == HamiltonianTypes.full:\n        return V_linear + V_nonlinear\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ideal_qubit.html","title":"ideal_qubit","text":"<p>IdealQubit.</p>"},{"location":"reference/jaxquantum/devices/superconducting/ideal_qubit.html#jaxquantum.devices.superconducting.ideal_qubit.IdealQubit","title":"<code>IdealQubit</code>","text":"<p>               Bases: <code>Device</code></p> <p>Ideal qubit Device.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>@struct.dataclass\nclass IdealQubit(Device):\n    \"\"\"\n    Ideal qubit Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, (\n            \"IdealQubit is a two-level system defined in the Fock basis.\"\n        )\n        assert hamiltonian == HamiltonianTypes.full, (\n            \"IdealQubit requires a full Hamiltonian.\"\n        )\n        assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n        assert \"f\" in params, \"IdealQubit requires a frequency parameter 'f'.\"\n\n        params[\"\u0394\"] = params.get(\"\u0394\", 0.0)\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        assert self.N_pre_diag == 2\n        assert self.N == 2\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"sigmaz\"] = sigmaz()\n        ops[\"sigmax\"] = sigmax()\n        ops[\"sigmay\"] = sigmay()\n        ops[\"sigmam\"] = sigmam()\n        ops[\"sigmap\"] = sigmap()\n\n        return ops\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"f\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return (w / 2) * self.linear_ops[\"sigmaz\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n\n        return self.get_H_linear() + self.params[\"\u0394\"] / 2 * self.linear_ops[\"sigmax\"] \n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ideal_qubit.html#jaxquantum.devices.superconducting.ideal_qubit.IdealQubit.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    assert self.N_pre_diag == 2\n    assert self.N == 2\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"sigmaz\"] = sigmaz()\n    ops[\"sigmax\"] = sigmax()\n    ops[\"sigmay\"] = sigmay()\n    ops[\"sigmam\"] = sigmam()\n    ops[\"sigmap\"] = sigmap()\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ideal_qubit.html#jaxquantum.devices.superconducting.ideal_qubit.IdealQubit.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n\n    return self.get_H_linear() + self.params[\"\u0394\"] / 2 * self.linear_ops[\"sigmax\"] \n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ideal_qubit.html#jaxquantum.devices.superconducting.ideal_qubit.IdealQubit.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return (w / 2) * self.linear_ops[\"sigmaz\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ideal_qubit.html#jaxquantum.devices.superconducting.ideal_qubit.IdealQubit.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"f\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/ideal_qubit.html#jaxquantum.devices.superconducting.ideal_qubit.IdealQubit.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/ideal_qubit.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, (\n        \"IdealQubit is a two-level system defined in the Fock basis.\"\n    )\n    assert hamiltonian == HamiltonianTypes.full, (\n        \"IdealQubit requires a full Hamiltonian.\"\n    )\n    assert N == N_pre_diag == 2, \"IdealQubit is a two-level system.\"\n    assert \"f\" in params, \"IdealQubit requires a frequency parameter 'f'.\"\n\n    params[\"\u0394\"] = params.get(\"\u0394\", 0.0)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/kno.html","title":"kno","text":"<p>Kerr Nonlinear Oscillator</p>"},{"location":"reference/jaxquantum/devices/superconducting/kno.html#jaxquantum.devices.superconducting.kno.KNO","title":"<code>KNO</code>","text":"<p>               Bases: <code>Device</code></p> <p>Kerr Nonlinear Oscillator Device.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>@struct.dataclass\nclass KNO(Device):\n    \"\"\"\n    Kerr Nonlinear Oscillator Device.\n    \"\"\"\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        assert basis == BasisTypes.fock, (\n            \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\"\n        )\n        assert hamiltonian == HamiltonianTypes.full, (\n            \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n        )\n        assert \"f\" in params and \"\u03b1\" in params, (\n            \"Kerr Nonlinear Oscillator requires frequency 'f' and anharmonicity '\u03b1' as parameters.\"\n        )\n\n    def common_ops(self):\n        ops = {}\n\n        N = self.N\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = (ops[\"a\"] + ops[\"a_dag\"]) / jnp.sqrt(2)\n        ops[\"n\"] = 1j * (ops[\"a_dag\"] - ops[\"a\"]) / jnp.sqrt(2)\n        return ops\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return self.params[\"f\"]\n\n    def get_anharm(self):\n        \"\"\"Get anharmonicity.\"\"\"\n        return self.params[\"\u03b1\"]\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        \u03b1 = self.get_anharm()\n\n        return self.get_H_linear() + (\u03b1 / 2) * (\n            self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a_dag\"]\n            @ self.linear_ops[\"a\"]\n            @ self.linear_ops[\"a\"]\n        )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/kno.html#jaxquantum.devices.superconducting.kno.KNO.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    \u03b1 = self.get_anharm()\n\n    return self.get_H_linear() + (\u03b1 / 2) * (\n        self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a_dag\"]\n        @ self.linear_ops[\"a\"]\n        @ self.linear_ops[\"a\"]\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/kno.html#jaxquantum.devices.superconducting.kno.KNO.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/kno.html#jaxquantum.devices.superconducting.kno.KNO.get_anharm","title":"<code>get_anharm()</code>","text":"<p>Get anharmonicity.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_anharm(self):\n    \"\"\"Get anharmonicity.\"\"\"\n    return self.params[\"\u03b1\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/kno.html#jaxquantum.devices.superconducting.kno.KNO.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return self.params[\"f\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/kno.html#jaxquantum.devices.superconducting.kno.KNO.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/kno.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    assert basis == BasisTypes.fock, (\n        \"Kerr Nonlinear Oscillator must be defined in the Fock basis.\"\n    )\n    assert hamiltonian == HamiltonianTypes.full, (\n        \"Kerr Nonlinear Oscillator uses a full Hamiltonian.\"\n    )\n    assert \"f\" in params and \"\u03b1\" in params, (\n        \"Kerr Nonlinear Oscillator requires frequency 'f' and anharmonicity '\u03b1' as parameters.\"\n    )\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/resonator.html","title":"resonator","text":"<p>Resonator.</p>"},{"location":"reference/jaxquantum/devices/superconducting/resonator.html#jaxquantum.devices.superconducting.resonator.Resonator","title":"<code>Resonator</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Resonator Device.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>@struct.dataclass\nclass Resonator(FluxDevice):\n    \"\"\"\n    Resonator Device.\n    \"\"\"\n\n    def common_ops(self):\n        \"\"\"Written in the linear basis.\"\"\"\n        ops = {}\n\n        N = self.N_pre_diag\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        return ops\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n\n    def n_zpf(self):\n        n_zpf = (self.params[\"El\"] / (32.0 * self.params[\"Ec\"])) ** (0.25)\n        return n_zpf\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * (self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"] + 1 / 2)\n\n    def get_H_full(self):\n        \"\"\"Return full H in linear basis.\"\"\"\n        return self.get_H_linear()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/resonator.html#jaxquantum.devices.superconducting.resonator.Resonator.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def common_ops(self):\n    \"\"\"Written in the linear basis.\"\"\"\n    ops = {}\n\n    N = self.N_pre_diag\n    ops[\"id\"] = identity(N)\n    ops[\"a\"] = destroy(N)\n    ops[\"a_dag\"] = create(N)\n    ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n    ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/resonator.html#jaxquantum.devices.superconducting.resonator.Resonator.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in linear basis.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in linear basis.\"\"\"\n    return self.get_H_linear()\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/resonator.html#jaxquantum.devices.superconducting.resonator.Resonator.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * (self.linear_ops[\"a_dag\"] @ self.linear_ops[\"a\"] + 1 / 2)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/resonator.html#jaxquantum.devices.superconducting.resonator.Resonator.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"El\"] * self.params[\"Ec\"])\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/resonator.html#jaxquantum.devices.superconducting.resonator.Resonator.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.params[\"El\"]) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/resonator.html#jaxquantum.devices.superconducting.resonator.Resonator.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/resonator.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    return 0.5 * self.params[\"El\"] * (2 * jnp.pi * phi) ** 2\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html","title":"snail","text":"<p>Transmon.</p>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL","title":"<code>SNAIL</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>SNAIL Device.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>@struct.dataclass\nclass SNAIL(FluxDevice):\n    \"\"\"\n    SNAIL Device.\n    \"\"\"\n\n    DEFAULT_BASIS = BasisTypes.charge\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n\n        assert params[\"m\"] % 1 == 0, \"m must be an integer.\"\n        assert params[\"m\"] &gt;= 2, \"m must be greater than or equal to 2.\"\n\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            charge_basis_types = [\n                BasisTypes.charge\n            ]\n            assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n            assert (N_pre_diag - 1) % 2 * (params[\"m\"]) == 0, \"(N_pre_diag - 1)/2 must be divisible by m.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = identity(N)\n            ops[\"a\"] = destroy(N)\n            ops[\"a_dag\"] = create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            m = self.params[\"m\"]\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6/m)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6/m)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=m) + jnp.eye(N, k=-m)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=m) - jnp.eye(N, k=-m)))\n\n            n_max = (N - 1) // 2\n            n_array = jnp.arange(-n_max, n_max + 1) / self.params[\"m\"]\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n\n            n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n\n        \u03b1 = self.params[\"alpha\"]\n        m = self.params[\"m\"]\n        phi_ext = self.params[\"phi_ext\"]\n        Ej = self.Ej\n\n        H_charge = self.original_ops[\"H_charge\"]\n        H_inductive = - \u03b1 * Ej * self.original_ops[\"cos(\u03c6)\"] - m * Ej * (\n            jnp.cos(2 * jnp.pi * phi_ext/m) * self.original_ops[\"cos(\u03c6/m)\"] + jnp.sin(2 * jnp.pi * phi_ext/m) * self.original_ops[\"sin(\u03c6/m)\"]\n        )\n        return H_charge + H_inductive\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        raise NotImplementedError(\"Truncated Hamiltonian not implemented for SNAIL.\")\n        # phi_op = self.original_ops[\"phi\"]  \n        # fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        # sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        # return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n\n            \u03b1 = self.params[\"alpha\"]\n            m = self.params[\"m\"]\n            phi_ext = self.params[\"phi_ext\"]\n\n            return - \u03b1 * self.Ej * jnp.cos(2 * jnp.pi * phi) - (\n                m * self.Ej * jnp.cos(2 * jnp.pi * (phi_ext - phi) / m)\n            )\n\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            raise NotImplementedError(\"Truncated potential not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        m = self.params[\"m\"]\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6/m)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6/m)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=m) + jnp.eye(N, k=-m)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=m) - jnp.eye(N, k=-m)))\n\n        n_max = (N - 1) // 2\n        n_array = jnp.arange(-n_max, n_max + 1) / self.params[\"m\"]\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n\n        n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n\n    \u03b1 = self.params[\"alpha\"]\n    m = self.params[\"m\"]\n    phi_ext = self.params[\"phi_ext\"]\n    Ej = self.Ej\n\n    H_charge = self.original_ops[\"H_charge\"]\n    H_inductive = - \u03b1 * Ej * self.original_ops[\"cos(\u03c6)\"] - m * Ej * (\n        jnp.cos(2 * jnp.pi * phi_ext/m) * self.original_ops[\"cos(\u03c6/m)\"] + jnp.sin(2 * jnp.pi * phi_ext/m) * self.original_ops[\"sin(\u03c6/m)\"]\n    )\n    return H_charge + H_inductive\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    raise NotImplementedError(\"Truncated Hamiltonian not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n\n    assert params[\"m\"] % 1 == 0, \"m must be an integer.\"\n    assert params[\"m\"] &gt;= 2, \"m must be greater than or equal to 2.\"\n\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        charge_basis_types = [\n            BasisTypes.charge\n        ]\n        assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        assert (N_pre_diag - 1) % 2 * (params[\"m\"]) == 0, \"(N_pre_diag - 1)/2 must be divisible by m.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/snail.html#jaxquantum.devices.superconducting.snail.SNAIL.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/snail.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n\n        \u03b1 = self.params[\"alpha\"]\n        m = self.params[\"m\"]\n        phi_ext = self.params[\"phi_ext\"]\n\n        return - \u03b1 * self.Ej * jnp.cos(2 * jnp.pi * phi) - (\n            m * self.Ej * jnp.cos(2 * jnp.pi * (phi_ext - phi) / m)\n        )\n\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        raise NotImplementedError(\"Truncated potential not implemented for SNAIL.\")\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html","title":"transmon","text":"<p>Transmon.</p>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon","title":"<code>Transmon</code>","text":"<p>               Bases: <code>FluxDevice</code></p> <p>Transmon Device.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>@struct.dataclass\nclass Transmon(FluxDevice):\n    \"\"\"\n    Transmon Device.\n    \"\"\"\n\n    DEFAULT_BASIS = BasisTypes.charge\n    DEFAULT_HAMILTONIAN = HamiltonianTypes.full\n\n    @classmethod\n    def param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n        \"\"\"This can be overridden by subclasses.\"\"\"\n        if hamiltonian == HamiltonianTypes.linear:\n            assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.truncated:\n            assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n        elif hamiltonian == HamiltonianTypes.full:\n            charge_basis_types = [\n                BasisTypes.charge,\n                BasisTypes.singlecharge,\n                BasisTypes.singlecharge_even,\n                BasisTypes.singlecharge_odd,\n            ]\n            assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n        # Set the gate offset charge to zero if not provided\n        if \"ng\" not in params:\n            params[\"ng\"] = 0.0\n\n        if basis in [BasisTypes.singlecharge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            assert (N_pre_diag) % 2 == 0, \"N_pre_diag must be even for single charge bases.\"\n        else:\n            assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n\n    def common_ops(self):\n        \"\"\" Written in the specified basis. \"\"\"\n\n        ops = {}\n\n        N = self.N_pre_diag\n\n        if self.basis == BasisTypes.fock:\n            ops[\"id\"] = identity(N)\n            ops[\"a\"] = destroy(N)\n            ops[\"a_dag\"] = create(N)\n            ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n            ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n        elif self.basis == BasisTypes.charge:\n            \"\"\"\n            Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n            \"\"\"\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n            ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n            ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n\n            n_max = (N - 1) // 2\n            n_array = jnp.arange(-n_max, n_max + 1)\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            n_max = N\n\n            if self.basis == BasisTypes.singlecharge_even:\n                n_array = jnp.arange(-n_max, n_max, 2)\n            elif self.basis == BasisTypes.singlecharge_odd:\n                n_array = jnp.arange(-n_max + 1, n_max, 2)\n\n            ops[\"id\"] = identity(n_max)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=1) + jnp.eye(n_max, k=-1)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=1) - jnp.eye(n_max, k=-1)))\n            ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=2) + jnp.eye(n_max, k=-2)))\n            ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=2) - jnp.eye(n_max, k=-2)))\n\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(n_max)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        elif self.basis == BasisTypes.singlecharge:\n            \"\"\"\n            Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n            thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n            not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n            (as done in Kyle's thesis).\n            \"\"\"\n            n_max = (N) // 2\n\n            ops[\"id\"] = identity(N)\n            ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n            ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n            ops[\"cos(\u03c6/2)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n            ops[\"sin(\u03c6/2)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n\n            n_array = jnp.arange(-n_max, n_max)\n            ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n            n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(N)\n            ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n        return ops\n\n    @property\n    def Ej(self):\n        return self.params[\"Ej\"]\n\n    def phi_zpf(self):\n        \"\"\"Return Phase ZPF.\"\"\"\n        return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n\n    def n_zpf(self):\n        \"\"\"Return Charge ZPF.\"\"\"\n        return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n\n    def get_linear_frequency(self):\n        \"\"\"Get frequency of linear terms.\"\"\"\n        return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n\n    def get_H_linear(self):\n        \"\"\"Return linear terms in H.\"\"\"\n        w = self.get_linear_frequency()\n        return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n\n    def get_H_full(self):\n        \"\"\"Return full H in specified basis.\"\"\"\n        return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n\n    def get_H_truncated(self):\n        \"\"\"Return truncated H in specified basis.\"\"\"\n        phi_op = self.original_ops[\"phi\"]  \n        fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n        sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n        return self.get_H_linear() + fourth_order_term + sixth_order_term\n\n    def _get_H_in_original_basis(self):\n        \"\"\" This returns the Hamiltonian in the original specified basis. This can be overridden by subclasses.\"\"\"\n\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return self.get_H_linear()\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return self.get_H_full()\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            return self.get_H_truncated()\n\n    def potential(self, phi):\n        \"\"\"Return potential energy for a given phi.\"\"\"\n        if self.hamiltonian == HamiltonianTypes.linear:\n            return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n        elif self.hamiltonian == HamiltonianTypes.full:\n            return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n        elif self.hamiltonian == HamiltonianTypes.truncated:\n            phi_scaled = 2 * jnp.pi * phi\n            second_order = 0.5 * self.Ej * phi_scaled ** 2\n            fourth_order =  -(1 / 24) * self.Ej * phi_scaled ** 4\n            sixth_order = (1 / 720) * self.Ej * phi_scaled ** 6\n            return second_order + fourth_order + sixth_order\n\n    def calculate_wavefunctions(self, phi_vals):\n        \"\"\"Calculate wavefunctions at phi_exts.\n\n        TODO: this is not currently being used for plotting... needs to be updated!\n        \"\"\"\n\n        if self.basis == BasisTypes.fock:\n            return super().calculate_wavefunctions(phi_vals)\n        elif self.basis == BasisTypes.singlecharge:\n            raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n        elif self.basis in [BasisTypes.charge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            phi_vals = jnp.array(phi_vals)\n\n            if self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n                n_labels = 1/2 * jnp.diag(self.original_ops[\"n\"].data)\n            else:\n                n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n            wavefunctions = []\n            for nj in range(self.N_pre_diag):\n                wavefunction = []\n                for phi in phi_vals:\n                    wavefunction.append(\n                        (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                            self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                        )\n                    )\n                wavefunctions.append(jnp.array(wavefunction))\n            return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.calculate_wavefunctions","title":"<code>calculate_wavefunctions(phi_vals)</code>","text":"<p>Calculate wavefunctions at phi_exts.</p> <p>TODO: this is not currently being used for plotting... needs to be updated!</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def calculate_wavefunctions(self, phi_vals):\n    \"\"\"Calculate wavefunctions at phi_exts.\n\n    TODO: this is not currently being used for plotting... needs to be updated!\n    \"\"\"\n\n    if self.basis == BasisTypes.fock:\n        return super().calculate_wavefunctions(phi_vals)\n    elif self.basis == BasisTypes.singlecharge:\n        raise NotImplementedError(\"Wavefunctions for single charge basis not yet implemented.\")\n    elif self.basis in [BasisTypes.charge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        phi_vals = jnp.array(phi_vals)\n\n        if self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n            n_labels = 1/2 * jnp.diag(self.original_ops[\"n\"].data)\n        else:\n            n_labels = jnp.diag(self.original_ops[\"n\"].data)\n\n        wavefunctions = []\n        for nj in range(self.N_pre_diag):\n            wavefunction = []\n            for phi in phi_vals:\n                wavefunction.append(\n                    (1j ** nj / jnp.sqrt(2*jnp.pi)) * jnp.sum(\n                        self.eig_systems[\"vecs\"][:,nj] * jnp.exp(1j * phi * n_labels)\n                    )\n                )\n            wavefunctions.append(jnp.array(wavefunction))\n        return jnp.array(wavefunctions)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.common_ops","title":"<code>common_ops()</code>","text":"<p>Written in the specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def common_ops(self):\n    \"\"\" Written in the specified basis. \"\"\"\n\n    ops = {}\n\n    N = self.N_pre_diag\n\n    if self.basis == BasisTypes.fock:\n        ops[\"id\"] = identity(N)\n        ops[\"a\"] = destroy(N)\n        ops[\"a_dag\"] = create(N)\n        ops[\"phi\"] = self.phi_zpf() * (ops[\"a\"] + ops[\"a_dag\"])\n        ops[\"n\"] = 1j * self.n_zpf() * (ops[\"a_dag\"] - ops[\"a\"])\n\n    elif self.basis == BasisTypes.charge:\n        \"\"\"\n        Here H = 4 * Ec (n - ng)\u00b2 - Ej cos(\u03c6) in the Cooper pair charge basis. \n        \"\"\"\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n        ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n        ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n\n        n_max = (N - 1) // 2\n        n_array = jnp.arange(-n_max, n_max + 1)\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(4 * self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis in [BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        n_max = N\n\n        if self.basis == BasisTypes.singlecharge_even:\n            n_array = jnp.arange(-n_max, n_max, 2)\n        elif self.basis == BasisTypes.singlecharge_odd:\n            n_array = jnp.arange(-n_max + 1, n_max, 2)\n\n        ops[\"id\"] = identity(n_max)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=1) + jnp.eye(n_max, k=-1)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=1) - jnp.eye(n_max, k=-1)))\n        ops[\"cos(2\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(n_max, k=2) + jnp.eye(n_max, k=-2)))\n        ops[\"sin(2\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(n_max, k=2) - jnp.eye(n_max, k=-2)))\n\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(n_max)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    elif self.basis == BasisTypes.singlecharge:\n        \"\"\"\n        Here H = Ec (n - 2ng)\u00b2 - Ej cos(\u03c6) in the single-electron charge basis. Using Eq. (5.36) of Kyle Serniak's\n        thesis, we have H = Ec \u2211\u2099(n - 2*ng) |n\u27e9\u27e8n| - Ej/2 * \u2211\u2099|n\u27e9\u27e8n+2| + h.c where n counts the number of electrons, \n        not Cooper pairs. Note, we use 2ng instead of ng to match the gate offset charge convention of the transmon \n        (as done in Kyle's thesis).\n        \"\"\"\n        n_max = (N) // 2\n\n        ops[\"id\"] = identity(N)\n        ops[\"cos(\u03c6)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=2) + jnp.eye(N, k=-2)))\n        ops[\"sin(\u03c6)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=2) - jnp.eye(N, k=-2)))\n        ops[\"cos(\u03c6/2)\"] = 0.5 * (jnp2jqt(jnp.eye(N, k=1) + jnp.eye(N, k=-1)))\n        ops[\"sin(\u03c6/2)\"] = 0.5j * (jnp2jqt(jnp.eye(N, k=1) - jnp.eye(N, k=-1)))\n\n        n_array = jnp.arange(-n_max, n_max)\n        ops[\"n\"] = jnp2jqt(jnp.diag(n_array))\n        n_minus_ng_array = n_array - 2 * self.params[\"ng\"] * jnp.ones(N)\n        ops[\"H_charge\"] = jnp2jqt(jnp.diag(self.params[\"Ec\"] * n_minus_ng_array**2))\n\n    return ops\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.get_H_full","title":"<code>get_H_full()</code>","text":"<p>Return full H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_full(self):\n    \"\"\"Return full H in specified basis.\"\"\"\n    return self.original_ops[\"H_charge\"] - self.Ej * self.original_ops[\"cos(\u03c6)\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.get_H_linear","title":"<code>get_H_linear()</code>","text":"<p>Return linear terms in H.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_linear(self):\n    \"\"\"Return linear terms in H.\"\"\"\n    w = self.get_linear_frequency()\n    return w * self.original_ops[\"a_dag\"] @ self.original_ops[\"a\"]\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.get_H_truncated","title":"<code>get_H_truncated()</code>","text":"<p>Return truncated H in specified basis.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_H_truncated(self):\n    \"\"\"Return truncated H in specified basis.\"\"\"\n    phi_op = self.original_ops[\"phi\"]  \n    fourth_order_term =  -(1 / 24) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op \n    sixth_order_term = (1 / 720) * self.Ej * phi_op @ phi_op @ phi_op @ phi_op @ phi_op @ phi_op\n    return self.get_H_linear() + fourth_order_term + sixth_order_term\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.get_linear_frequency","title":"<code>get_linear_frequency()</code>","text":"<p>Get frequency of linear terms.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def get_linear_frequency(self):\n    \"\"\"Get frequency of linear terms.\"\"\"\n    return jnp.sqrt(8 * self.params[\"Ec\"] * self.Ej)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.n_zpf","title":"<code>n_zpf()</code>","text":"<p>Return Charge ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def n_zpf(self):\n    \"\"\"Return Charge ZPF.\"\"\"\n    return (self.Ej / (32 * self.params[\"Ec\"])) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.param_validation","title":"<code>param_validation(N, N_pre_diag, params, hamiltonian, basis)</code>  <code>classmethod</code>","text":"<p>This can be overridden by subclasses.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>@classmethod\ndef param_validation(cls, N, N_pre_diag, params, hamiltonian, basis):\n    \"\"\"This can be overridden by subclasses.\"\"\"\n    if hamiltonian == HamiltonianTypes.linear:\n        assert basis == BasisTypes.fock, \"Linear Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.truncated:\n        assert basis == BasisTypes.fock, \"Truncated Hamiltonian only works with Fock basis.\"\n    elif hamiltonian == HamiltonianTypes.full:\n        charge_basis_types = [\n            BasisTypes.charge,\n            BasisTypes.singlecharge,\n            BasisTypes.singlecharge_even,\n            BasisTypes.singlecharge_odd,\n        ]\n        assert basis in charge_basis_types, \"Full Hamiltonian only works with Cooper pair charge or single-electron charge bases.\"\n\n    # Set the gate offset charge to zero if not provided\n    if \"ng\" not in params:\n        params[\"ng\"] = 0.0\n\n    if basis in [BasisTypes.singlecharge, BasisTypes.singlecharge_even, BasisTypes.singlecharge_odd]:\n        assert (N_pre_diag) % 2 == 0, \"N_pre_diag must be even for single charge bases.\"\n    else:\n        assert (N_pre_diag - 1) % 2 == 0, \"N_pre_diag must be odd.\"\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.phi_zpf","title":"<code>phi_zpf()</code>","text":"<p>Return Phase ZPF.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def phi_zpf(self):\n    \"\"\"Return Phase ZPF.\"\"\"\n    return (2 * self.params[\"Ec\"] / self.Ej) ** (0.25)\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/transmon.html#jaxquantum.devices.superconducting.transmon.Transmon.potential","title":"<code>potential(phi)</code>","text":"<p>Return potential energy for a given phi.</p> Source code in <code>jaxquantum/devices/superconducting/transmon.py</code> <pre><code>def potential(self, phi):\n    \"\"\"Return potential energy for a given phi.\"\"\"\n    if self.hamiltonian == HamiltonianTypes.linear:\n        return 0.5 * self.Ej * (2 * jnp.pi * phi) ** 2\n    elif self.hamiltonian == HamiltonianTypes.full:\n        return - self.Ej * jnp.cos(2 * jnp.pi * phi)\n    elif self.hamiltonian == HamiltonianTypes.truncated:\n        phi_scaled = 2 * jnp.pi * phi\n        second_order = 0.5 * self.Ej * phi_scaled ** 2\n        fourth_order =  -(1 / 24) * self.Ej * phi_scaled ** 4\n        sixth_order = (1 / 720) * self.Ej * phi_scaled ** 6\n        return second_order + fourth_order + sixth_order\n</code></pre>"},{"location":"reference/jaxquantum/devices/superconducting/tunable_transmon.html","title":"tunable_transmon","text":"<p>Tunable Transmon.</p>"},{"location":"reference/jaxquantum/devices/superconducting/tunable_transmon.html#jaxquantum.devices.superconducting.tunable_transmon.TunableTransmon","title":"<code>TunableTransmon</code>","text":"<p>               Bases: <code>Transmon</code></p> <p>Tunable Transmon Device.</p> Source code in <code>jaxquantum/devices/superconducting/tunable_transmon.py</code> <pre><code>@struct.dataclass\nclass TunableTransmon(Transmon):\n    \"\"\"\n    Tunable Transmon Device.\n    \"\"\"\n\n    @property\n    def Ej(self):\n        Ejsum = self.params[\"Ej1\"] + self.params[\"Ej2\"]\n        phi_ext = 2 * jnp.pi * self.params[\"phi_ext\"]\n        gamma = self.params[\"Ej2\"] / self.params[\"Ej1\"]\n        d = (gamma - 1) / (gamma + 1)\n        external_flux_factor = jnp.abs(\n            jnp.sqrt(jnp.cos(phi_ext / 2) ** 2 + d**2 * jnp.sin(phi_ext / 2) ** 2)\n        )\n        return Ejsum * external_flux_factor\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html","title":"utils","text":"<p>Utils</p>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.Ec_to_inv_pF","title":"<code>Ec_to_inv_pF(Ec)</code>","text":"<p>GHz -&gt; 1/picoFarad</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def Ec_to_inv_pF(Ec):\n    \"\"\"\n    GHz -&gt; 1/picoFarad\n    \"\"\"\n    joule = GHz_to_joule(Ec)\n    Gjoule = joule / 1e9\n    inv_nFarad = Gjoule / ((constants.e) ** 2 / (2))\n    return inv_nFarad * 1e-3\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.as_series","title":"<code>as_series(*arrs)</code>","text":"<p>Return arguments as a list of 1-d arrays.</p> <p>The returned list contains array(s) of dtype double, complex double, or object.  A 1-d argument of shape <code>(N,)</code> is parsed into <code>N</code> arrays of size one; a 2-d argument of shape <code>(M,N)</code> is parsed into <code>M</code> arrays of size <code>N</code> (i.e., is \"parsed by row\"); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</p>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.as_series--parameters","title":"Parameters","text":"<p>arrs : array_like     1- or 2-d array_like trim : boolean, optional     When True, trailing zeros are removed from the inputs.     When False, the inputs are passed through intact.</p>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.as_series--returns","title":"Returns","text":"<p>a1, a2,... : 1-D arrays     A copy of the input data as 1-d arrays.</p> Source code in <code>jaxquantum/utils/hermgauss.py</code> <pre><code>def as_series(*arrs):\n    \"\"\"Return arguments as a list of 1-d arrays.\n\n    The returned list contains array(s) of dtype double, complex double, or\n    object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of\n    size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays\n    of size ``N`` (i.e., is \"parsed by row\"); and a higher dimensional array\n    raises a Value Error if it is not first reshaped into either a 1-d or 2-d\n    array.\n\n    Parameters\n    ----------\n    arrs : array_like\n        1- or 2-d array_like\n    trim : boolean, optional\n        When True, trailing zeros are removed from the inputs.\n        When False, the inputs are passed through intact.\n\n    Returns\n    -------\n    a1, a2,... : 1-D arrays\n        A copy of the input data as 1-d arrays.\n\n    \"\"\"\n    arrays = tuple(jnp.array(a, ndmin=1) for a in arrs)\n    arrays = promote_dtypes_inexact(*arrays)\n    if len(arrays) == 1:\n        return arrays[0]\n    return tuple(arrays)\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.comb","title":"<code>comb(N, k)</code>","text":"<p>NCk</p>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.comb--todo-replace-with-jspspecialcomb-once-issue-is-closed","title":"TODO: replace with jsp.special.comb once issue is closed:","text":"<p>https://github.com/google/jax/issues/9709</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>total items</p> required <code>k</code> required <p>Returns:</p> Name Type Description <code>NCk</code> <p>N choose k</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def comb(N, k):\n    \"\"\"\n    NCk\n\n    #TODO: replace with jsp.special.comb once issue is closed:\n    https://github.com/google/jax/issues/9709\n\n    Args:\n        N: total items\n        k: # of items to choose\n\n    Returns:\n        NCk: N choose k\n    \"\"\"\n    one = 1\n    N_plus_1 = lax.add(N, one)\n    k_plus_1 = lax.add(k, one)\n    return lax.exp(\n        lax.sub(\n            gammaln(N_plus_1), lax.add(gammaln(k_plus_1), gammaln(lax.sub(N_plus_1, k)))\n        )\n    )\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.comb--of-items-to-choose","title":"of items to choose","text":""},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.hermcompanion","title":"<code>hermcompanion(c)</code>","text":"<p>Return the scaled companion matrix of c.</p> <p>The basis polynomials are scaled so that the companion matrix is symmetric when <code>c</code> is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if <code>jax.numpy.linalg.eigvalsh</code> is used to obtain them.</p>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.hermcompanion--parameters","title":"Parameters","text":"<p>c : array_like     1-D array of Hermite series coefficients ordered from low to high     degree.</p>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.hermcompanion--returns","title":"Returns","text":"<p>mat : ndarray     Scaled companion matrix of dimensions (deg, deg).</p> Source code in <code>jaxquantum/utils/hermgauss.py</code> <pre><code>@jit\ndef hermcompanion(c):\n    \"\"\"Return the scaled companion matrix of c.\n\n    The basis polynomials are scaled so that the companion matrix is\n    symmetric when `c` is an Hermite basis polynomial. This provides\n    better eigenvalue estimates than the unscaled case and for basis\n    polynomials the eigenvalues are guaranteed to be real if\n    `jax.numpy.linalg.eigvalsh` is used to obtain them.\n\n    Parameters\n    ----------\n    c : array_like\n        1-D array of Hermite series coefficients ordered from low to high\n        degree.\n\n    Returns\n    -------\n    mat : ndarray\n        Scaled companion matrix of dimensions (deg, deg).\n\n    \"\"\"\n    c = as_series(c)\n    if len(c) &lt; 2:\n        raise ValueError(\"Series must have maximum degree of at least 1.\")\n    if len(c) == 2:\n        return jnp.array([[-0.5 * c[0] / c[1]]])\n\n    n = len(c) - 1\n    mat = jnp.zeros((n, n), dtype=c.dtype)\n    scl = jnp.hstack((1.0, 1.0 / jnp.sqrt(2.0 * jnp.arange(n - 1, 0, -1))))\n    scl = jnp.cumprod(scl)[::-1]\n    shp = mat.shape\n    mat = mat.flatten()\n    mat = mat.at[1 :: n + 1].set(jnp.sqrt(0.5 * jnp.arange(1, n)))\n    mat = mat.at[n :: n + 1].set(jnp.sqrt(0.5 * jnp.arange(1, n)))\n    mat = mat.reshape(shp)\n    mat = mat.at[:, -1].add(-scl * c[:-1] / (2.0 * c[-1]))\n    return mat\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.inductance_to_inductive_energy","title":"<code>inductance_to_inductive_energy(L)</code>","text":"<p>Convert inductance to inductive energy E_L.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>float</code> <p>Inductance in nH.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Inductive energy in GHz.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inductance_to_inductive_energy(L):\n    \"\"\"Convert inductance to inductive energy E_L.\n\n    Args:\n        L (float): Inductance in nH.\n\n    Returns:\n        float: Inductive energy in GHz.\n    \"\"\"\n\n    inv_L = 1e9 / L\n    El_joules = inv_L * (FLUX_QUANTUM**2) / (2 * np.pi) ** 2\n    return joule_to_GHz(El_joules)\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.inductive_energy_to_inductance","title":"<code>inductive_energy_to_inductance(El)</code>","text":"<p>Convert inductive energy E_L to inductance.</p> <p>Parameters:</p> Name Type Description Default <code>El</code> <code>float</code> <p>inductive energy in GHz.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Inductance in nH.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inductive_energy_to_inductance(El):\n    \"\"\"Convert inductive energy E_L to inductance.\n\n    Args:\n        El (float): inductive energy in GHz.\n\n    Returns:\n        float: Inductance in nH.\n    \"\"\"\n\n    inv_L = GHz_to_joule(El) * (2 * np.pi) ** 2 / (FLUX_QUANTUM**2)\n    return 1e9 / inv_L\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.inv_pF_to_Ec","title":"<code>inv_pF_to_Ec(inv_pfarad)</code>","text":"<p>1/picoFarad -&gt; GHz</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inv_pF_to_Ec(inv_pfarad):\n    \"\"\"\n    1/picoFarad -&gt; GHz\n    \"\"\"\n    inv_nFarad = inv_pfarad * 1e3\n    Gjoule = (constants.e) ** 2 / (2) * inv_nFarad\n    return joule_to_GHz(Gjoule * 1e9)\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.n_thermal","title":"<code>n_thermal(frequency, temperature)</code>","text":"<p>Calculate the average thermal photon number for a given frequency and temperature.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Frequency in GHz.</p> required <code>temperature</code> <code>float</code> <p>Temperature in Kelvin.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Average thermal photon number.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def n_thermal(frequency: float, temperature: float) -&gt; float:\n    \"\"\"Calculate the average thermal photon number for a given frequency and temperature.\n\n    Args:\n        frequency (float): Frequency in GHz.\n        temperature (float): Temperature in Kelvin.\n\n    Returns:\n        float: Average thermal photon number.\n    \"\"\"\n    k_B = constants.k  # Boltzmann constant in J/K\n    h = constants.h  # Planck constant in J\u00b7s\n\n    exponent = h * (frequency * 1e9) / (k_B * temperature)\n    n_avg = 1 / (np.exp(exponent) - 1)\n    return n_avg\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.set_precision","title":"<code>set_precision(precision)</code>","text":"<p>Set the precision of JAX operations.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>Literal['single', 'double']</code> <p>'single' or 'double'</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if precision is not 'single' or 'double'</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def set_precision(precision: Literal[\"single\", \"double\"]):\n    \"\"\"\n    Set the precision of JAX operations.\n\n    Args:\n        precision: 'single' or 'double'\n\n    Raises:\n        ValueError: if precision is not 'single' or 'double'\n    \"\"\"\n    if precision == \"single\":\n        config.update(\"jax_enable_x64\", False)\n    elif precision == \"double\":\n        config.update(\"jax_enable_x64\", True)\n    else:\n        raise ValueError(\"precision must be 'single' or 'double'\")\n</code></pre>"},{"location":"reference/jaxquantum/utils/hermgauss.html","title":"hermgauss","text":""},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.as_series","title":"<code>as_series(*arrs)</code>","text":"<p>Return arguments as a list of 1-d arrays.</p> <p>The returned list contains array(s) of dtype double, complex double, or object.  A 1-d argument of shape <code>(N,)</code> is parsed into <code>N</code> arrays of size one; a 2-d argument of shape <code>(M,N)</code> is parsed into <code>M</code> arrays of size <code>N</code> (i.e., is \"parsed by row\"); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</p>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.as_series--parameters","title":"Parameters","text":"<p>arrs : array_like     1- or 2-d array_like trim : boolean, optional     When True, trailing zeros are removed from the inputs.     When False, the inputs are passed through intact.</p>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.as_series--returns","title":"Returns","text":"<p>a1, a2,... : 1-D arrays     A copy of the input data as 1-d arrays.</p> Source code in <code>jaxquantum/utils/hermgauss.py</code> <pre><code>def as_series(*arrs):\n    \"\"\"Return arguments as a list of 1-d arrays.\n\n    The returned list contains array(s) of dtype double, complex double, or\n    object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of\n    size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays\n    of size ``N`` (i.e., is \"parsed by row\"); and a higher dimensional array\n    raises a Value Error if it is not first reshaped into either a 1-d or 2-d\n    array.\n\n    Parameters\n    ----------\n    arrs : array_like\n        1- or 2-d array_like\n    trim : boolean, optional\n        When True, trailing zeros are removed from the inputs.\n        When False, the inputs are passed through intact.\n\n    Returns\n    -------\n    a1, a2,... : 1-D arrays\n        A copy of the input data as 1-d arrays.\n\n    \"\"\"\n    arrays = tuple(jnp.array(a, ndmin=1) for a in arrs)\n    arrays = promote_dtypes_inexact(*arrays)\n    if len(arrays) == 1:\n        return arrays[0]\n    return tuple(arrays)\n</code></pre>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.hermcompanion","title":"<code>hermcompanion(c)</code>","text":"<p>Return the scaled companion matrix of c.</p> <p>The basis polynomials are scaled so that the companion matrix is symmetric when <code>c</code> is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if <code>jax.numpy.linalg.eigvalsh</code> is used to obtain them.</p>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.hermcompanion--parameters","title":"Parameters","text":"<p>c : array_like     1-D array of Hermite series coefficients ordered from low to high     degree.</p>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.hermcompanion--returns","title":"Returns","text":"<p>mat : ndarray     Scaled companion matrix of dimensions (deg, deg).</p> Source code in <code>jaxquantum/utils/hermgauss.py</code> <pre><code>@jit\ndef hermcompanion(c):\n    \"\"\"Return the scaled companion matrix of c.\n\n    The basis polynomials are scaled so that the companion matrix is\n    symmetric when `c` is an Hermite basis polynomial. This provides\n    better eigenvalue estimates than the unscaled case and for basis\n    polynomials the eigenvalues are guaranteed to be real if\n    `jax.numpy.linalg.eigvalsh` is used to obtain them.\n\n    Parameters\n    ----------\n    c : array_like\n        1-D array of Hermite series coefficients ordered from low to high\n        degree.\n\n    Returns\n    -------\n    mat : ndarray\n        Scaled companion matrix of dimensions (deg, deg).\n\n    \"\"\"\n    c = as_series(c)\n    if len(c) &lt; 2:\n        raise ValueError(\"Series must have maximum degree of at least 1.\")\n    if len(c) == 2:\n        return jnp.array([[-0.5 * c[0] / c[1]]])\n\n    n = len(c) - 1\n    mat = jnp.zeros((n, n), dtype=c.dtype)\n    scl = jnp.hstack((1.0, 1.0 / jnp.sqrt(2.0 * jnp.arange(n - 1, 0, -1))))\n    scl = jnp.cumprod(scl)[::-1]\n    shp = mat.shape\n    mat = mat.flatten()\n    mat = mat.at[1 :: n + 1].set(jnp.sqrt(0.5 * jnp.arange(1, n)))\n    mat = mat.at[n :: n + 1].set(jnp.sqrt(0.5 * jnp.arange(1, n)))\n    mat = mat.reshape(shp)\n    mat = mat.at[:, -1].add(-scl * c[:-1] / (2.0 * c[-1]))\n    return mat\n</code></pre>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.hermgauss","title":"<code>hermgauss(deg)</code>","text":"<p>Gauss-Hermite quadrature.</p> <p>Computes the sample points and weights for Gauss-Hermite quadrature. These sample points and weights will correctly integrate polynomials of degree :math:<code>2*deg - 1</code> or less over the interval :math:<code>[-\\inf, \\inf]</code> with the weight function :math:<code>f(x) = \\exp(-x^2)</code>.</p>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.hermgauss--parameters","title":"Parameters","text":"<p>deg : int     Number of sample points and weights. It must be &gt;= 1.</p>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.hermgauss--returns","title":"Returns","text":"<p>x : ndarray     1-D ndarray containing the sample points. y : ndarray     1-D ndarray containing the weights.</p>"},{"location":"reference/jaxquantum/utils/hermgauss.html#jaxquantum.utils.hermgauss.hermgauss--notes","title":"Notes","text":"<p>The results have only been tested up to degree 100, higher degrees may be problematic. The weights are determined by using the fact that</p> <p>.. math:: w_k = c / (H'n(x_k) * H(x_k))</p> <p>where :math:<code>c</code> is a constant independent of :math:<code>k</code> and :math:<code>x_k</code> is the k'th root of :math:<code>H_n</code>, and then scaling the results to get the right value when integrating 1.</p> Source code in <code>jaxquantum/utils/hermgauss.py</code> <pre><code>def hermgauss(deg):\n    r\"\"\"Gauss-Hermite quadrature.\n\n    Computes the sample points and weights for Gauss-Hermite quadrature.\n    These sample points and weights will correctly integrate polynomials of\n    degree :math:`2*deg - 1` or less over the interval :math:`[-\\inf, \\inf]`\n    with the weight function :math:`f(x) = \\exp(-x^2)`.\n\n    Parameters\n    ----------\n    deg : int\n        Number of sample points and weights. It must be &gt;= 1.\n\n    Returns\n    -------\n    x : ndarray\n        1-D ndarray containing the sample points.\n    y : ndarray\n        1-D ndarray containing the weights.\n\n    Notes\n    -----\n    The results have only been tested up to degree 100, higher degrees may\n    be problematic. The weights are determined by using the fact that\n\n    .. math:: w_k = c / (H'_n(x_k) * H_{n-1}(x_k))\n\n    where :math:`c` is a constant independent of :math:`k` and :math:`x_k`\n    is the k'th root of :math:`H_n`, and then scaling the results to get\n    the right value when integrating 1.\n\n    \"\"\"\n    deg = int(deg)\n    if deg &lt;= 0:\n        raise ValueError(\"deg must be a positive integer\")\n\n    # first approximation of roots. We use the fact that the companion\n    # matrix is symmetric in this case in order to obtain better zeros.\n    c = jnp.zeros(deg + 1).at[-1].set(1)\n    m = hermcompanion(c)\n    x = jnp.linalg.eigvalsh(m)\n\n    # improve roots by one application of Newton\n    dy = _normed_hermite_n(x, deg)\n    df = _normed_hermite_n(x, deg - 1) * jnp.sqrt(2 * deg)\n    x -= dy / df\n\n    # compute the weights. We scale the factor to avoid possible numerical\n    # overflow.\n    fm = _normed_hermite_n(x, deg - 1)\n    fm /= jnp.abs(fm).max()\n    w = 1 / (fm * fm)\n\n    # for Hermite we can also symmetrize\n    w = (w + w[::-1]) / 2\n    x = (x - x[::-1]) / 2\n\n    # scale w to get the right value\n    w *= jnp.sqrt(jnp.pi) / w.sum()\n\n    return x, w\n</code></pre>"},{"location":"reference/jaxquantum/utils/units.html","title":"units","text":"<p>Units handling.</p>"},{"location":"reference/jaxquantum/utils/units.html#jaxquantum.utils.units.Ec_to_inv_pF","title":"<code>Ec_to_inv_pF(Ec)</code>","text":"<p>GHz -&gt; 1/picoFarad</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def Ec_to_inv_pF(Ec):\n    \"\"\"\n    GHz -&gt; 1/picoFarad\n    \"\"\"\n    joule = GHz_to_joule(Ec)\n    Gjoule = joule / 1e9\n    inv_nFarad = Gjoule / ((constants.e) ** 2 / (2))\n    return inv_nFarad * 1e-3\n</code></pre>"},{"location":"reference/jaxquantum/utils/units.html#jaxquantum.utils.units.inductance_to_inductive_energy","title":"<code>inductance_to_inductive_energy(L)</code>","text":"<p>Convert inductance to inductive energy E_L.</p> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>float</code> <p>Inductance in nH.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Inductive energy in GHz.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inductance_to_inductive_energy(L):\n    \"\"\"Convert inductance to inductive energy E_L.\n\n    Args:\n        L (float): Inductance in nH.\n\n    Returns:\n        float: Inductive energy in GHz.\n    \"\"\"\n\n    inv_L = 1e9 / L\n    El_joules = inv_L * (FLUX_QUANTUM**2) / (2 * np.pi) ** 2\n    return joule_to_GHz(El_joules)\n</code></pre>"},{"location":"reference/jaxquantum/utils/units.html#jaxquantum.utils.units.inductive_energy_to_inductance","title":"<code>inductive_energy_to_inductance(El)</code>","text":"<p>Convert inductive energy E_L to inductance.</p> <p>Parameters:</p> Name Type Description Default <code>El</code> <code>float</code> <p>inductive energy in GHz.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Inductance in nH.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inductive_energy_to_inductance(El):\n    \"\"\"Convert inductive energy E_L to inductance.\n\n    Args:\n        El (float): inductive energy in GHz.\n\n    Returns:\n        float: Inductance in nH.\n    \"\"\"\n\n    inv_L = GHz_to_joule(El) * (2 * np.pi) ** 2 / (FLUX_QUANTUM**2)\n    return 1e9 / inv_L\n</code></pre>"},{"location":"reference/jaxquantum/utils/units.html#jaxquantum.utils.units.inv_pF_to_Ec","title":"<code>inv_pF_to_Ec(inv_pfarad)</code>","text":"<p>1/picoFarad -&gt; GHz</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def inv_pF_to_Ec(inv_pfarad):\n    \"\"\"\n    1/picoFarad -&gt; GHz\n    \"\"\"\n    inv_nFarad = inv_pfarad * 1e3\n    Gjoule = (constants.e) ** 2 / (2) * inv_nFarad\n    return joule_to_GHz(Gjoule * 1e9)\n</code></pre>"},{"location":"reference/jaxquantum/utils/units.html#jaxquantum.utils.units.n_thermal","title":"<code>n_thermal(frequency, temperature)</code>","text":"<p>Calculate the average thermal photon number for a given frequency and temperature.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Frequency in GHz.</p> required <code>temperature</code> <code>float</code> <p>Temperature in Kelvin.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Average thermal photon number.</p> Source code in <code>jaxquantum/utils/units.py</code> <pre><code>def n_thermal(frequency: float, temperature: float) -&gt; float:\n    \"\"\"Calculate the average thermal photon number for a given frequency and temperature.\n\n    Args:\n        frequency (float): Frequency in GHz.\n        temperature (float): Temperature in Kelvin.\n\n    Returns:\n        float: Average thermal photon number.\n    \"\"\"\n    k_B = constants.k  # Boltzmann constant in J/K\n    h = constants.h  # Planck constant in J\u00b7s\n\n    exponent = h * (frequency * 1e9) / (k_B * temperature)\n    n_avg = 1 / (np.exp(exponent) - 1)\n    return n_avg\n</code></pre>"},{"location":"reference/jaxquantum/utils/utils.html","title":"utils","text":"<p>JAX Utils</p>"},{"location":"reference/jaxquantum/utils/utils.html#jaxquantum.utils.utils.comb","title":"<code>comb(N, k)</code>","text":"<p>NCk</p>"},{"location":"reference/jaxquantum/utils/utils.html#jaxquantum.utils.utils.comb--todo-replace-with-jspspecialcomb-once-issue-is-closed","title":"TODO: replace with jsp.special.comb once issue is closed:","text":"<p>https://github.com/google/jax/issues/9709</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>total items</p> required <code>k</code> required <p>Returns:</p> Name Type Description <code>NCk</code> <p>N choose k</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def comb(N, k):\n    \"\"\"\n    NCk\n\n    #TODO: replace with jsp.special.comb once issue is closed:\n    https://github.com/google/jax/issues/9709\n\n    Args:\n        N: total items\n        k: # of items to choose\n\n    Returns:\n        NCk: N choose k\n    \"\"\"\n    one = 1\n    N_plus_1 = lax.add(N, one)\n    k_plus_1 = lax.add(k, one)\n    return lax.exp(\n        lax.sub(\n            gammaln(N_plus_1), lax.add(gammaln(k_plus_1), gammaln(lax.sub(N_plus_1, k)))\n        )\n    )\n</code></pre>"},{"location":"reference/jaxquantum/utils/utils.html#jaxquantum.utils.utils.comb--of-items-to-choose","title":"of items to choose","text":""},{"location":"reference/jaxquantum/utils/utils.html#jaxquantum.utils.utils.set_precision","title":"<code>set_precision(precision)</code>","text":"<p>Set the precision of JAX operations.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>Literal['single', 'double']</code> <p>'single' or 'double'</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if precision is not 'single' or 'double'</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def set_precision(precision: Literal[\"single\", \"double\"]):\n    \"\"\"\n    Set the precision of JAX operations.\n\n    Args:\n        precision: 'single' or 'double'\n\n    Raises:\n        ValueError: if precision is not 'single' or 'double'\n    \"\"\"\n    if precision == \"single\":\n        config.update(\"jax_enable_x64\", False)\n    elif precision == \"double\":\n        config.update(\"jax_enable_x64\", True)\n    else:\n        raise ValueError(\"precision must be 'single' or 'double'\")\n</code></pre>"}]}